[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Apuntes de Juegos en Red",
    "section": "",
    "text": "Guía de estudio\nLos videojuegos en red representan uno de los sectores más dinámicos y desafiantes de la industria del software, donde la capacidad de diseñar e implementar sistemas de comunicación eficientes y robustos es fundamental. En este contexto, comprender las arquitecturas de red, los protocolos de comunicación y las técnicas de programación tanto del lado del cliente como del servidor se ha convertido en una habilidad esencial para cualquier desarrollador de juegos modernos. Este libro está diseñado para proporcionar una comprensión profunda y práctica de estas tecnologías, basándose en el contenido de la asignatura Juegos en Red.\nEl desarrollo de juegos en red tiene múltiples facetas que exploraremos en profundidad: desde los fundamentos de las redes de comunicación hasta la programación en el cliente con JavaScript y Phaser, y finalmente la comunicación cliente-servidor mediante APIs REST y WebSockets. Entender esta progresión es clave para desarrollar juegos multijugador escalables y eficientes.\nComenzaremos sentando las bases de las redes de ordenadores, explorando las diferentes capas del modelo TCP/IP. A partir de ahí, aprenderemos a desarrollar aplicaciones web interactivas usando JavaScript y el motor de juegos Phaser. Finalmente, dominaremos las técnicas de comunicación cliente-servidor mediante APIs REST para operaciones síncronas y WebSockets para comunicación en tiempo real.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "index.html#objetivos-de-la-asignatura",
    "href": "index.html#objetivos-de-la-asignatura",
    "title": "Apuntes de Juegos en Red",
    "section": "Objetivos de la asignatura",
    "text": "Objetivos de la asignatura\n\nComprender los fundamentos de las redes de ordenadores y los protocolos de comunicación del modelo TCP/IP.\nDominar el lenguaje JavaScript para el desarrollo de aplicaciones web interactivas.\nAprender a utilizar el motor de juegos Phaser para crear juegos 2D en el navegador.\nDiseñar e implementar APIs REST para la comunicación cliente-servidor.\nDesarrollar sistemas de comunicación en tiempo real utilizando WebSockets.\nIntegrar todas estas tecnologías para crear juegos multijugador funcionales.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "index.html#temario-de-la-asignatura",
    "href": "index.html#temario-de-la-asignatura",
    "title": "Apuntes de Juegos en Red",
    "section": "Temario de la asignatura",
    "text": "Temario de la asignatura\nLa asignatura está dividida en 5 partes, que se corresponden con la categorización de la guia docente. Además, cada uno de estas partes está dividida en diferentes capítulos, con el fin de facilitar su lectura.\n\nParte 1: Introducción a los juegos en red y a las redes de comunicaciones\n\nCapítulo 1: Introducción a las Redes de Ordenadores\nCapítulo 2: Capa de Acceso a la Red\nCapítulo 3: Capa de Red\nCapítulo 4: Capa de Transporte\nCapítulo 5: Capa de Aplicación\n\n\n\nParte 2: Desarrollo en el lado del cliente\n\nCapítulo 6: JavaScript\nCapítulo 7: HTML y CSS\n\n\n\nParte 3: Desarrollo de juegos con tecnología web\n\nCapítulo 8: Phaser - Motor de Juegos 2D\n\n\n\nParte 4: Desarrollo en el lado del servidor\n\nCapítulo 9: APIs REST - Introducción, Cliente y Servidor\n\n\n\nParte 5: Comunicación asíncrona cliente - servidor\n\nCapítulo 10: WebSockets - Introducción, Cliente y Servidor",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "index.html#desarrollo-de-la-asignatura",
    "href": "index.html#desarrollo-de-la-asignatura",
    "title": "Apuntes de Juegos en Red",
    "section": "Desarrollo de la asignatura",
    "text": "Desarrollo de la asignatura\nEl curso se desarrolla a lo largo de 15 semanas, con dos sesiones semanales. La metodología busca integrar la teoría y la práctica de forma fluida: los conceptos teóricos se presentarán junto con su implementación práctica, fomentando un aprendizaje aplicado en cada clase.\n\nCalendario de clases\n\n\n\n\n\n\n\n\nSemana\nDia 1\nDia 2\n\n\n\n\n1\nClase 1: Introducción a asignatura y a las Redes de Ordenadores\nClase 2: Capa de Acceso a la Red\n\n\n2\nClase 3: Capa de Red\nClase 4: Capa de Transporte\n\n\n3\nClase 5: Capa de Aplicación\nClase 6: Repaso y Prácticas de Redes\n\n\n4\nClase 7: Repaso y Prácticas de Redes\nClase 8: Presentación e Introducción a JavaScript\n\n\n5\nClase 9: Examen Parcial\nClase 10: JavaScript Orientado a Objetos\n\n\n6\nClase 11: Introducción a Phaser\nClase 12: Phaser (continuación)\n\n\n7\nClase 13: Phaser (continuación)\nClase 14: Phaser (continuación)\n\n\n8\nClase 15: Phaser (continuación)\nClase 16: APIs REST - Introducción y Cliente\n\n\n9\nClase 17: APIs REST - Cliente (continuación)\nClase 18: Presentación prácticas\n\n\n10\nClase 19: Examen\nClase 20: APIs REST - Servidor\n\n\n11\nClase 21: APIs REST - Servidor (continuación)\nClase 22: APIs REST - Servidor (continuación)\n\n\n12\nClase 23: APIs REST - Servidor (continuación)\nClase 24: WebSockets - Cliente y Servidor\n\n\n13\nClase 25: WebSockets (continuación)\nClase 26: WebSockets (continuación)\n\n\n14\nClase 27: WebSockets (continuación)\nClase 28: WebSockets (continuación)\n\n\n15\nClase 29: Examen\nClase 30: Presentación prácticas\n\n\n\n\n\nClase 1: Presentación a asignatura e itroducción a las Redes de Ordenadores\n\nContenidos: Presentación de la asignatura, guía docente y sistema de evaluación.Introducción de los conceptos fundamentales de redes de ordenadores. Arquitectura de red por capas. Modelo TCP/IP. Protocolos y estándares. Historia y evolución de Internet.\nObjetivos de Aprendizaje:\n\nComprender la arquitectura en capas de las redes de ordenadores.\nIdentificar los componentes fundamentales de Internet.\nEntender el papel de los protocolos en la comunicación de red.\n\nMateriales Utilizados:\n\nApuntes: 2  Introducción a las Redes de Ordenadores\nDiapositivas: Introducción a la asignatura Introducción a las Redes de Ordenadores\nEjercicios: Introducción a Redes\n\nActividades Planificadas:\n\nDiscusión sobre la importancia de las redes en los videojuegos.\nAnálisis de la arquitectura de red de juegos multijugador populares.\n\nTrabajo Personal Recomendado:\n\nLectura completa de los apuntes de introducción a redes.\nRealización del ejercicio práctico de trazado de rutas.\n\n\n\n\nClase 2: Capa de Acceso a la Red\n\nContenidos: Funciones de la capa de acceso. Tecnologías de acceso físico. Ethernet. WiFi. Direccionamiento MAC. Conmutación y dominios de colisión.\nObjetivos de Aprendizaje:\n\nComprender las funciones de la capa de acceso a la red.\nIdentificar las diferencias entre distintas tecnologías de acceso.\nEntender el funcionamiento de las direcciones MAC.\n\nMateriales Utilizados:\n\nApuntes: 3  Capa de Acceso a la Red\nDiapositivas: Capa de Acceso\nEjercicios: Capa de Acceso\n\nActividades Planificadas:\n\nAnálisis de tramas Ethernet.\nConfiguración de redes locales.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre la capa de acceso.\nRealización del ejercicio práctico.\n\n\n\n\nClase 3: Capa de Red\n\nContenidos: Protocolo IP. Direccionamiento IPv4 e IPv6. Subredes y máscaras. Enrutamiento. Protocolo ARP. ICMP y herramientas de diagnóstico (ping, traceroute).\nObjetivos de Aprendizaje:\n\nComprender el funcionamiento del protocolo IP.\nDominar el direccionamiento IP y el concepto de subredes.\nUtilizar herramientas de diagnóstico de red.\n\nMateriales Utilizados:\n\nApuntes: 4  Capa de red\nDiapositivas: Capa de Red\nEjercicios: Capa de Red\n\nActividades Planificadas:\n\nPrácticas con herramientas de diagnóstico (ping, traceroute).\nAnálisis de tablas de enrutamiento.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre la capa de red.\nRealización del ejercicio de direccionamiento IP.\n\n\n\n\nClase 4: Capa de Transporte\n\nContenidos: Protocolo TCP. Protocolo UDP. Control de flujo y congestión. Establecimiento y cierre de conexiones. Puertos y sockets. Comparación TCP vs UDP para videojuegos.\nObjetivos de Aprendizaje:\n\nComprender las diferencias entre TCP y UDP.\nEntender cuándo utilizar cada protocolo en el desarrollo de juegos.\nDominar el concepto de puertos y sockets.\n\nMateriales Utilizados:\n\nApuntes: 5  Capa de transporte\nDiapositivas: Capa de Transporte\nEjercicios: Capa de Transporte\n\nActividades Planificadas:\n\nAnálisis del tráfico TCP y UDP.\nDiscusión sobre las necesidades de latencia en juegos multijugador.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre la capa de transporte.\nRealización del ejercicio práctico.\n\n\n\n\nClase 5: Capa de Aplicación\n\nContenidos: Protocolos de aplicación. HTTP y HTTPS. DNS. Arquitecturas cliente-servidor y peer-to-peer. APIs web. Introducción a los servicios web.\nObjetivos de Aprendizaje:\n\nComprender los protocolos de la capa de aplicación.\nEntender el funcionamiento de HTTP/HTTPS.\nConocer diferentes arquitecturas de aplicación en red.\n\nMateriales Utilizados:\n\nApuntes: 6  Capa de aplicación\nDiapositivas: Capa de Aplicación\nEjercicios: Capa de Aplicación\n\nActividades Planificadas:\n\nAnálisis de peticiones HTTP.\nExploración de APIs públicas.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre la capa de aplicación.\nRealización del ejercicio de análisis de tráfico HTTP.\n\n\n\n\nClase 6-7: Repaso y Prácticas de Redes\n\nContenidos: Repaso integral de los conceptos de redes de ordenadores. Resolución de ejercicios prácticos. Preparación para la siguiente fase del curso.\nObjetivos de Aprendizaje:\n\nConsolidar los conocimientos de todas las capas del modelo TCP/IP.\nIntegrar los conceptos en casos prácticos.\n\nMateriales Utilizados:\n\nTodos los materiales de las semanas 1-5.\nEjercicios de repaso.\n\nActividades Planificadas:\n\nSesión de resolución de dudas.\nPrácticas guiadas de configuración y análisis de redes.\n\nTrabajo Personal Recomendado:\n\nRepaso de todos los capítulos de redes.\nPreparación del entorno de desarrollo para JavaScript.\n\n\n\n\nClase 8: Presentación e Introducción a JavaScript\n\nContenidos: Presentación de la segunda parte del curso. Fundamentos de JavaScript: variables, tipos de datos, operadores, estructuras de control. Funciones y ámbito.\nObjetivos de Aprendizaje:\n\nComprender la sintaxis básica de JavaScript.\nDominar las estructuras de control de flujo.\nCrear y utilizar funciones en JavaScript.\n\nMateriales Utilizados:\n\nApuntes: 7  JavaScript\nDiapositivas: JavaScript\nEjercicios: JavaScript\n\nActividades Planificadas:\n\nConfiguración del entorno de desarrollo.\nPrimeros programas en JavaScript.\n\nTrabajo Personal Recomendado:\n\nLectura de las secciones introductorias de JavaScript.\nPráctica con ejercicios básicos de programación.\n\n\n\n\nClase 9: Examen Parcial\n\nContenidos: Evaluación de los contenidos de redes de ordenadores (Clases 1-7).\nObjetivos de Aprendizaje:\n\nDemostrar comprensión de los fundamentos de redes.\nAplicar los conocimientos a problemas prácticos.\n\nMateriales Utilizados:\n\nTodos los materiales de las clases 1-7.\n\nActividades Planificadas:\n\nExamen parcial teórico-práctico.\n\nTrabajo Personal Recomendado:\n\nContinuar con el aprendizaje de JavaScript.\n\n\n\n\nClase 10: JavaScript Orientado a Objetos\n\nContenidos: Objetos y arrays. Programación orientada a objetos en JavaScript. Clases y prototipos. Manipulación del DOM. Eventos.\nObjetivos de Aprendizaje:\n\nDominar el trabajo con objetos y arrays.\nComprender la programación orientada a objetos en JavaScript.\nManipular el DOM y gestionar eventos.\n\nMateriales Utilizados:\n\nApuntes: 7  JavaScript\nDiapositivas: JavaScript OOP\nEjercicios: JavaScript\n\nActividades Planificadas:\n\nCreación de aplicaciones interactivas simples.\nPrácticas con eventos del navegador.\n\nTrabajo Personal Recomendado:\n\nLectura de las secciones avanzadas de JavaScript.\nDesarrollo de pequeños proyectos personales.\n\n\n\n\nClase 11-15: Introducción a Phaser\n\nContenidos: Introducción al motor de juegos Phaser. Escenas y ciclo de vida. Sprites y texturas. Sistema de físicas. Gestión de entrada (teclado, ratón, táctil).\nObjetivos de Aprendizaje:\n\nComprender la arquitectura de Phaser.\nCrear escenas y gestionar el ciclo de vida del juego.\nImplementar físicas básicas y controles.\n\nMateriales Utilizados:\n\nApuntes: 9  Phaser 3\nDiapositivas: Phaser\nEjercicios: Phaser\n\nActividades Planificadas:\n\nDesarrollo de un proyecto de juego completo.\nSesión de depuración y optimización.\n\nTrabajo Personal Recomendado:\n\nFinalización del proyecto de juego.\nLectura de 8  HTML y CSS para crear la base web del juego.\nPreparación para la integración con servicios de red.\n\n\n\n\nClase 16-17: APIs REST - Introducción y Cliente\n\nContenidos: Arquitectura REST. Métodos HTTP (GET, POST, PUT, DELETE). Formato JSON. Consumo de APIs REST desde JavaScript. Fetch API. Manejo de promesas y async/await.\nObjetivos de Aprendizaje:\n\nComprender los principios de la arquitectura REST.\nConsumir APIs REST desde el cliente.\nManejar operaciones asíncronas en JavaScript.\n\nMateriales Utilizados:\n\nApuntes: 10  API REST, 11  Cliente API REST con Javascript\nDiapositivas: APIs REST\nEjercicios: REST - Introducción, REST - Cliente\n\nActividades Planificadas:\n\nConsumo de APIs públicas.\nIntegración de datos externos en aplicaciones.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre REST.\nRealización de los ejercicios de consumo de APIs.\n\n\n\n\nClase 18: Presentación prácticas\n\nContenidos: Presentación del proyecto de juego desarrollado con Phaser. Demostración de funcionalidades implementadas. Revisión del código y arquitectura del juego.\nObjetivos de Aprendizaje:\n\nPresentar de forma efectiva un proyecto de desarrollo de juegos.\nExplicar las decisiones de diseño y arquitectura del juego.\nDemostrar dominio de JavaScript y Phaser.\n\nMateriales Utilizados:\n\nProyecto personal de juego con Phaser.\nCódigo fuente del proyecto.\n\nActividades Planificadas:\n\nPresentaciones de los proyectos de juego.\nSesión de preguntas y respuestas sobre las implementaciones.\n\nTrabajo Personal Recomendado:\n\nPreparación de la presentación del proyecto.\nRevisión y refinamiento del código del juego.\nEstudio para el examen de JavaScript y Phaser.\n\n\n\n\nClase 19: Examen\n\nContenidos: Evaluación de los contenidos de JavaScript y Phaser (Clases 8-15).\nObjetivos de Aprendizaje:\n\nDemostrar dominio de JavaScript y programación orientada a objetos.\nAplicar los conocimientos de Phaser en problemas prácticos.\nResolver ejercicios de desarrollo de juegos.\n\nMateriales Utilizados:\n\nTodos los materiales de las clases 8-17.\nApuntes de JavaScript y Phaser.\n\nActividades Planificadas:\n\nExamen teórico-práctico de JavaScript y Phaser.\n\nTrabajo Personal Recomendado:\n\nContinuar con el aprendizaje de APIs REST.\nLectura de los apuntes sobre desarrollo de servidores.\n\n\n\n\nClase 20-23: APIs REST - Servidor\n\nContenidos: Desarrollo de APIs REST con Node.js y Express. Diseño de endpoints. Middleware. Gestión de errores. Validación de datos. Persistencia de datos.\nObjetivos de Aprendizaje:\n\nDiseñar e implementar una API REST.\nGestionar peticiones y respuestas HTTP.\nImplementar la lógica de negocio del servidor.\n\nMateriales Utilizados:\n\nApuntes: 12  Servidor API REST con Javascript\nDiapositivas: APIs REST\nEjercicios: REST - Servidor\n\nActividades Planificadas:\n\nDesarrollo de una API REST completa.\nPruebas de endpoints con herramientas como Postman.\n\nTrabajo Personal Recomendado:\n\nLectura de los apuntes sobre desarrollo de servidores REST.\nImplementación de la API del proyecto final.\n\n\n\n\nClase 24-28: WebSockets - Cliente y Servidor\n\nContenidos: Introducción a WebSockets. Comunicación bidireccional en tiempo real. Socket.IO. Gestión de conexiones. Salas y broadcast. Sincronización de estado en juegos multijugador.\nObjetivos de Aprendizaje:\n\nComprender las ventajas de WebSockets sobre HTTP.\nImplementar comunicación en tiempo real.\nSincronizar el estado del juego entre múltiples clientes.\n\nMateriales Utilizados:\n\nApuntes: 13  Introducción a WebSockets, 14  Cliente WebSockets con JavasScript, 15  Servidor WebSockets con JavasScript\nDiapositivas: WebSockets\nEjercicios: WebSockets - Introducción, WebSockets - Cliente, WebSockets - Servidor\n\nActividades Planificadas:\n\nImplementación de chat en tiempo real.\nDesarrollo de la comunicación multijugador para el proyecto final.\n\nTrabajo Personal Recomendado:\n\nLectura de todos los apuntes sobre WebSockets.\nIntegración de WebSockets en el proyecto final.\n\n\n\n\nClase 29: Examen\n\nContenidos: Evaluación de los contenidos de APIs REST y WebSockets (Clases 16-17, 20-28).\nObjetivos de Aprendizaje:\n\nDemostrar comprensión de la arquitectura REST y WebSockets.\nAplicar los conocimientos de comunicación cliente-servidor.\nImplementar soluciones de comunicación en tiempo real.\n\nMateriales Utilizados:\n\nTodos los materiales de las clases 16-17 y 20-28.\nApuntes de REST y WebSockets.\n\nActividades Planificadas:\n\nExamen teórico-práctico de REST y WebSockets.\n\nTrabajo Personal Recomendado:\n\nFinalización del proyecto final con comunicación en tiempo real.\nPreparación de la presentación final del proyecto.\n\n\n\n\nClase 30: Presentación prácticas\n\nContenidos: Presentación del proyecto de juego multijugador con API REST. Demostración de la integración cliente-servidor. Arquitectura del sistema completo.\nObjetivos de Aprendizaje:\n\nPresentar un proyecto completo de juego en red con API REST.\nExplicar la arquitectura cliente-servidor implementada.\nDemostrar dominio de todas las tecnologías del curso.\n\nMateriales Utilizados:\n\nProyecto final de juego multijugador.\nCódigo fuente del cliente y servidor.\nDocumentación de la API REST implementada.\n\nActividades Planificadas:\n\nPresentaciones de los proyectos finales.\nDemostración en vivo de las funcionalidades multijugador.\nSesión de retroalimentación y evaluación.\n\nTrabajo Personal Recomendado:\n\nPreparación exhaustiva de la presentación final.\nDocumentación completa del proyecto.\nEstudio para el examen de la evaluación ordinaria.\n\n\n\n\nExamen de la evaluación ordinaria (Proyecto final)\n\nContenidos: Desarrollo de un juego multijugador completo con WebSockets.\nObjetivos de Aprendizaje:\n\nDemostrar comprensión integral de redes de ordenadores, JavaScript, Phaser, APIs REST y WebSockets.\nImplementar un juego multijugador funcional con comunicación en tiempo real.\nAplicar todos los conocimientos adquiridos durante el curso.\n\nMateriales Utilizados:\n\nTodos los materiales del curso (Clases 1-30).\nApuntes completos de redes, JavaScript, Phaser, REST y WebSockets.\nDocumentación de todas las tecnologías utilizadas.\n\nActividades Planificadas:\n\nDesarrollo y presentación final de un juego multijugador con WebSockets.\n\nTrabajo Personal Recomendado:\n\nRepaso exhaustivo de todos los contenidos de la asignatura.\nPráctica con proyectos personales integrando todas las tecnologías.\nRevisión de todos los ejercicios y proyectos del curso.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "index.html#recursos-adicionales",
    "href": "index.html#recursos-adicionales",
    "title": "Apuntes de Juegos en Red",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\nLos siguientes recursos complementarios pueden ser útiles durante el curso:\n\nDocumentación oficial de JavaScript (Mozilla Developer Network 2024): MDN Web Docs\nDocumentación oficial de Phaser (Photonstorm 2024): Phaser.io\nDocumentación de Node.js: Node.js Docs\nDocumentación de Socket.IO: Socket.IO\nPlataforma con visualizaciones: JER Games (Para información sobre el código fuente ver 18  Software utilizado en la asignatura)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "index.html#bibliografía-recomendada",
    "href": "index.html#bibliografía-recomendada",
    "title": "Apuntes de Juegos en Red",
    "section": "Bibliografía recomendada",
    "text": "Bibliografía recomendada\nPara profundizar en los conceptos del curso, se recomienda consultar:\n\nRedes de ordenadores: Los fundamentos de redes están basados en (Kurose y Ross 2021). También es recomendable (Tanenbaum y Wetherall 2021).\nJavaScript: Para dominar el lenguaje, consultar (Flanagan 2020) y (Haverbeke 2018).\nDesarrollo de juegos en red: Recursos esenciales incluyen (Gambetta 2014), (Fiedler 2024), (Claypool y Claypool 2006), (Bernier 2001), (Aldridge 2011), y (Glazer y Madhav 2015).\nAPIs REST: La arquitectura REST está definida en (Fielding 2000). Guías prácticas incluyen (Masse 2011), (Richardson y Ruby 2013), y (Sturgeon 2016).\nWebSockets: El protocolo está especificado en (Fette y Melnikov 2011). Para implementación práctica, ver (Wang, Salim, y Moskovits 2013) y (Doglio 2015).\nNode.js y Express: Referencias recomendadas incluyen (Wilson 2018), (Hahn 2014), y (Young, Meck, y Cantelon 2017).\n\nTodas las referencias completas se encuentran en la sección de referencias del libro.\n\n\n\n\nAldridge, David. 2011. «I Shot You First: Networking the Gameplay of Halo: Reach». En Game Developers Conference.\n\n\nBernier, Yahn W. 2001. «Latency compensating methods in client/server in-game protocol design and optimization». En Game Developers Conference.\n\n\nClaypool, Mark, y Kajal Claypool. 2006. «Latency and player actions in online games». Commun. ACM 49 (11): 40-45. https://doi.org/10.1145/1167838.1167860.\n\n\nDoglio, Fernando. 2015. Pro REST API Development with Node.js. Berkeley, CA: Apress.\n\n\nFette, Ian, y Alexey Melnikov. 2011. «The WebSocket Protocol». RFC 6455. Internet Engineering Task Force. https://tools.ietf.org/html/rfc6455.\n\n\nFiedler, Glenn. 2024. «Gaffer on Games: Networking for Game Programmers». https://gafferongames.com/.\n\n\nFielding, Roy Thomas. 2000. «Architectural Styles and the Design of Network-based Software Architectures». Tesis doctoral, University of California, Irvine.\n\n\nFlanagan, David. 2020. JavaScript: The Definitive Guide. 7.ª ed. Sebastopol, CA: O’Reilly Media.\n\n\nGambetta, Gabriel. 2014. «Fast-Paced Multiplayer». https://www.gabrielgambetta.com/client-server-game-architecture.html.\n\n\nGlazer, Joshua, y Sanjay Madhav. 2015. Multiplayer Game Programming: Architecting Networked Games. Boston, MA: Addison-Wesley Professional.\n\n\nHahn, Evan. 2014. Express in Action: Writing, building, and testing Node.js applications. Shelter Island, NY: Manning Publications.\n\n\nHaverbeke, Marijn. 2018. Eloquent JavaScript: A Modern Introduction to Programming. 3.ª ed. San Francisco, CA: No Starch Press.\n\n\nKurose, James F., y Keith W. Ross. 2021. Computer Networks: A Top-Down Approach. 8.ª ed. Boston, MA: Pearson.\n\n\nMasse, Mark. 2011. REST API Design Rulebook. Sebastopol, CA: O’Reilly Media.\n\n\nMozilla Developer Network. 2024. «JavaScript Guide». https://developer.mozilla.org/.\n\n\nPhotonstorm. 2024. «Phaser 3 Documentation». https://phaser.io/.\n\n\nRichardson, Leonard, y Sam Ruby. 2013. RESTful Web APIs. Sebastopol, CA: O’Reilly Media.\n\n\nSturgeon, Phil. 2016. Build APIs You Won’t Hate. LeanPub.\n\n\nTanenbaum, Andrew S., y David J. Wetherall. 2021. Computer Networks. 6.ª ed. Harlow, England: Pearson.\n\n\nWang, Vanessa, Frank Salim, y Peter Moskovits. 2013. The Definitive Guide to HTML5 WebSocket. Berkeley, CA: Apress.\n\n\nWilson, Jim. 2018. Node.js 8 the Right Way: Practical, Server-Side JavaScript That Scales. Raleigh, NC: Pragmatic Bookshelf.\n\n\nYoung, Alex, Bradley Meck, y Mike Cantelon. 2017. Node.js in Action. 2.ª ed. Shelter Island, NY: Manning Publications.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>index.html</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/part_intro.html",
    "href": "ch/part_networks/part_intro.html",
    "title": "Parte: Introducción a los juegos en red y a las redes de comunicaciones",
    "section": "",
    "text": "Los videojuegos en red representan uno de los sectores más dinámicos de la industria del software, donde comprender las redes de comunicación es fundamental para desarrollar sistemas eficientes y robustos. Esta primera parte del curso establece los cimientos necesarios explorando el modelo TCP/IP capa por capa: desde la capa de acceso a la red con tecnologías como Ethernet y WiFi, pasando por la capa de red con el protocolo IP y el direccionamiento, la capa de transporte con TCP y UDP, hasta llegar a la capa de aplicación con protocolos como HTTP y DNS. Comprenderemos cómo funcionan las comunicaciones en Internet, analizaremos las diferencias entre TCP y UDP en el contexto de los videojuegos, y dominaremos herramientas de diagnóstico esenciales. Estos conocimientos son imprescindibles para tomar decisiones arquitectónicas acertadas al diseñar juegos multijugador.",
    "crumbs": [
      "Introducción a redes",
      "Parte: Introducción a los juegos en red y a las redes de comunicaciones"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html",
    "href": "ch/part_networks/network_intro/network_intro.html",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "",
    "text": "2.1 Introducción\nLa etimología de Internet es “Interconnected Networks” (Redes interconectadas), lo cual nos da una pista sobre qué es: una red global interconectada de redes más pequeñas que permite la comunicación entre los diferentes dispositivos conectados. Internet opera como un sistema descentralizado compuesto por varias capas de redes, desde las LAN (Local Area Networks), que son los nodos donde nos conectamos, hasta las WAN (Wide Area Networks) que abarcan continentes.\nEn la Figura 2.1 podemos ver una organización jerárquica de Internet, donde múltiples redes del mismo nivel se agregan para formar el siguiente nivel superior. A medida que ascendemos en la jerarquía, el número de dispositivos que se pueden conectar se incrementa exponencialmente. Las PAN son redes que conectan dispositivos personales como smartphones y sirven para conectar con smartwatches y electrodomésticos, entre otros. Desde las PAN podemos tomar dos rutas principales hasta el Internet, a través de las LAN o directamente con las MAN (5G o 4G). Las LAN son redes que cubren hogares, oficinas u otras unidades donde el número de dispositivos es reducido. La conexión a las LAN puede ser cableada o inalámbrica, por ejemplo con WLAN (Wi-Fi). Una CAN es una agrupación de redes LAN, generalmente en campus universitarios o grandes empresas donde el número de dispositivos es elevado. Las redes CAN, LANs individuales y las redes de telefonía móvil (e.g., 4G/5G) se juntan para dar lugar a las MAN. Las MAN generalmente abarcan ciudades o grupos de ciudades, que interconectadas dan lugar a las WANs. Finalmente, múltiples WANs dan lugar al Internet global. Las VPN (Virtual Private Network) operan como túneles seguros sobre toda esta infraestructura, permitiendo que los dispositivos cambien dinámicamente entre rutas según la tecnología disponible en cada momento.\nPara ilustrar el funcionamiento de Internet vamos a utilizar un ejemplo simplificado. Supongamos que María quiere enviar un mensaje desde un Smartphone conectado a Internet a través del WiFi de su casa en Madrid a Takeshi, conectado a una LAN en la universidad de Tokio (dentro de una CAN). Puede que algunos términos no os suenen, no os preocupéis, los iremos viendo a lo largo de la asignatura. El proceso de envío sería el siguiente:\nEn este ejemplo simplificado de envío de un mensaje por Internet ya estamos dispuestos para comprender algunos de sus componentes y identificadores. Si os fijáis, hay dos componentes que están presentes a lo largo del ejemplo, los switches y routers. El router es un dispositivo que conecta diferentes redes entre sí usando direcciones IP. Es como un “director de tráfico” que conoce las rutas entre redes distantes. Su funcionamiento a grandes rasgos es el siguiente: Llega un paquete, se identifica a través de la IP destino el camino de salida obteniendo la MAC del siguiente salto (hop), y se envía el paquete. Este proceso, denominado enrutamiento 1, se repite hasta llegar a la red destino, por eso estos algoritmos, y por ello se determinan hop by hop. El switch por otra parte es un dispositivo que conecta equipos dentro de una misma red local usando direcciones MAC. Funciona como un “repartidor inteligente” que conoce exactamente dónde está cada dispositivo en su red. Completando la analogía, Los switches manejan el tráfico local, mientras que cuando necesitan enviar datos fuera de su red, los entregan a los routers. Los routers, a su vez, se conectan a otros routers o switches según el destino.\nEl procedimiento de envío se realiza con dos identificadores que hemos mencionado durante el ejemplo, la MAC y la dirección IP. La dirección IP funciona como la dirección postal de una casa y permite localizar el dispositivo en las redes (como 192.168.1.100), y la dirección MAC, que es como el DNI del dispositivo: único, asignado por el fabricante y que no cambia nunca. Los routers usan direcciones IP para decidir hacia dónde enviar los paquetes, mientras que los switches usan direcciones MAC para entregar los datos al dispositivo correcto dentro de la red local. Por último, tenemos ARP, un protocolo que nos permite relacionarlas. El protocolo ARP es como un servicio de directorio telefónico: cuando un dispositivo conoce la “dirección postal” (IP) pero necesita el “DNI” (MAC) para hacer la entrega final, envía una consulta ARP preguntando “¿quién vive en esta dirección?”. El dispositivo correspondiente responde con su MAC, permitiendo que la comunicación se complete. ARP traduce entre el mundo de las direcciones (IP) y el mundo de las identidades físicas (MAC).\nUna vez vistos los componentes principales de Internet, vamos a realizar unas observaciones. Primero, Internet es un sistema distribuido. Esto quiere decir que es una unión de dispositivos que operan juntos con el fin de ofrecer una funcionalidad. Segundo, Internet tiene una arquitectura descentralizada2. Por lo tanto, la caída de alguna parte de Internet no tiene porque implicar la caída de Internet globalmente. Tercero, la ejecución de los procesos de enrutamiento es local. Cada nodo de la red sólo necesita saber cual va a ser el siguiente destino (“hop”). Es decir, no hay una planificación global para el envío de los paquetes. Debido a esto los algoritmos de enrutamiento normalmente se denominan “hop by hop” e incorporan información de tiempo real 3, por lo que dos mensajes enviados al mismo destino no tienen por qué seguir la misma ruta. Todo esto facilita la escalabilidad del sistema, disminuye la congestión de la red y además proporciona resiliencia a fallos.\nHasta ahora hemos visto un ejemplo simplificado de envío de mensaje, los principales componentes de Internet y algunos conceptos técnicos. Pero aún falta algo. Hemos dicho que Internet es un sistema distribuido formado por redes interconectadas. Pero, ¿Cómo se entienden entre sí?. La respuesta son los protocolos. Un protocolo es una serie de pasos bien definidos que se realizan con un objetivo. En redes de computadores, es como un manual de instrucciones que especifica cómo dos dispositivos deben intercambiar información. Es un conjunto de reglas que define exactamente cómo deben estructurarse los mensajes, en qué orden enviarlos, qué estructura y formato tienen los mensajes que recibimos, y cómo se debe actuar. Internet funciona gracias a una familia de protocolos organizados en capas, que veremos a lo largo de esta introducción.\nPor ejemplificar los protocolos de red con una analogía, son como las reglas de tráfico en una ciudad: así como los autos necesitan semáforos, señales y carriles para circular ordenadamente sin chocar, los datos en una red necesitan protocolos que definan cómo moverse, comunicarse y llegar a su destino correctamente. Sin estas reglas, tanto el tráfico vehicular como el flujo de datos serían un caos total, con “accidentes” y pérdida de información constante. Desde un punto de vista más formal, podríamos definir un protocolo como:\nEn los siguientes apartados vamos a profundizar en los conceptos introducidos hasta ahora, obteniendo un mejor entendimiento de cómo funciona Internet, cuales son los principales actores involucrados, y cómo podemos realizar nuestras propias aplicaciones que funcionen sobre la red. Los puntos se abordarán de la siguiente manera. Primero, se verán desde un enfoque “informático”, y después contextualizaremos como encaja cada uno de los puntos desde el punto de vista de desarrollo de videojuegos.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#introducción",
    "href": "ch/part_networks/network_intro/network_intro.html#introducción",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "",
    "text": "Figura 2.1: Topología jerárquica de Internet.\n\n\n\n\n\n\n1. Origen - LAN Madrid: El smartphone de María crea el paquete (podéis pensar en el como un mensaje) con la dirección IP de destino de Tokio y la dirección MAC del router WiFi como destino inmediato. El router WiFi recibe el frame Ethernet, examina la dirección IP de destino y se da cuenta de que no pertenece a su red local. Reemplaza la dirección MAC de destino por la de su gateway (ISP) y reenvía el paquete.\n2. Router local a MAN: El router del ISP local recibe el frame con su propia dirección MAC como destino. Extrae el paquete IP, examina la dirección IP de destino y determina que debe enviarlo hacia la MAN de Madrid. Encapsula el paquete en un nuevo frame con la dirección MAC del siguiente router como destino.\n3. MAN a WAN nacional: El router de la MAN de Madrid recibe el frame dirigido a su dirección MAC, extrae el paquete IP y analiza el destino. Al comprender que Tokio está fuera de España, encapsula el paquete en un nuevo frame con la dirección MAC del router de la WAN española como destino.\n4. WAN a Internet global: El router de la WAN española recibe el frame con su dirección MAC, consulta sus tablas de rutas internacionales para Japón y encapsula el paquete con la dirección MAC del siguiente router en la ruta internacional. En cada salto a través del backbone de Internet, los routers intercambian las direcciones MAC (origen y destino) mientras preservan las direcciones IP originales.\n5. Llegada a Japón - WAN a MAN: Un router de la WAN japonesa recibe el frame dirigido a su dirección MAC, reconoce que el destino IP está dentro de Japón y encapsula el paquete con la dirección MAC del router de la MAN de Tokio como nuevo destino.\n6. MAN a CAN: El router de la MAN de Tokio recibe el frame con su dirección MAC como destino, examina la IP y determina que pertenece a la universidad de Tokio. Encapsula el paquete en un nuevo frame dirigido a la dirección MAC del router gateway de la CAN universitaria.\n7. CAN a LAN destino: El router de la CAN universitaria recibe el frame dirigido a su dirección MAC, analiza la IP de destino para identificar qué LAN específica del campus corresponde, y encapsula el paquete con la dirección MAC del router de esa LAN como destino.\n8. Destino final - LAN universitaria: El router de la LAN recibe el frame con su dirección MAC como destino, extrae el paquete IP y lo entrega al switch. El switch examina sus tablas ARP para encontrar la dirección MAC correspondiente a la IP de Takeshi, y finalmente envía el frame con la dirección MAC real de Takeshi como destino, completando el viaje desde Madrid.\n\n\n\n\n\n\n\n\n\n\n\n\nTipProtocolo\n\n\n\nUn protocolo define una serie de tipos de mensaje, su sintáxis y su semántica, así como las reglas de cuándo y cómo enviar/responder los mensajes.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#la-historia-de-internet",
    "href": "ch/part_networks/network_intro/network_intro.html#la-historia-de-internet",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "2.2 La Historia de Internet",
    "text": "2.2 La Historia de Internet\nInternet, como otros muchos avances de la sociedad, nació como una necesidad de guerra. En concreto, en la Guerra Fría. En una guerra la información y poder comunicarla es poder. El objetivo inicial del germen de Internet, llamado ARPANET, era precisamente la comunicación de información y que estos medios fuesen capaces de sobrevivir a un ataque nuclear. En 1969 la red experimental contaba con 4 host: UCLA, Stanford, UC Santa Bárbara y la Universidad de Utah. Esta red utilizaba un mecanismo para la comunicación de información llamada conmutación de paquetes, donde los mensajes se dividían en paquetes más pequeños que podían tomar diferentes rutas hasta llegar a su destino. Así cumplieron los requisitos de tolerancia a fallos en el envío de información a través de la descentralización y duplicidad, y además sentaron la semilla que permitiría una escalabilidad natural. En 1971 ya contaba con 23 host (ver Figura 2.2), y en 1973 se realizó la primera conexión internacional con Noruega y Londres a través de tecnología satelital. En esa época la red se incrementaba a razón de 1 host cada aproximadamente 20 días.\n\n\n\n\n\n\nFigura 2.2: Distribución geográfica de los nodos de ARPANET en 1971 (BBC Brasil 2019).\n\n\n\nEn la década de los 80 ocurrirían 4 eventos que darían forma al Internet que conocemos hoy en día. En primer lugar, en 1983 se adoptó oficialmente la pila de protocolos TCP/IP como estándar para ARPANET, que estableció las reglas de comunicación que aún seguimos hoy en día. Una de las grandes ventajas de TCP/IP fue que permitió que diferentes tipos de redes se pudiesen comunicar entre sí de manera estándar. Es decir, empezamos a tener redes formadas por redes interconectadas. En este momento fue cuando se empezó a hablar del término “Internet” para describir esta red de redes interconectadas. En segundo lugar, ARPANET se dividió en 1983, creándose MILNET como una red independiente para fines militares, mientras ARPANET continuó creciendo en su uso académico. En tercer lugar, el CERN empezó a interconectar sus ordenadores utilizando TCP/IP, sentando la base para el último evento. En cuarto y último lugar, Tim Berners-Lee, trabajando en el CERN, inventó la World Wide Web en 1989-1990. Propuso un sistema de intercambio de información basado en hipertexto así como las direcciones URL, el protocolo HTTP y el lenguaje HTML, que son omnipresentes hoy en día.\nLos años 90 fueron testigos de la transformación de Internet de un proyecto académico a una infraestructura comercial global. El tráfico de ARPANET fue absorbido por Internet y se desmanteló en 1990. En 1991, la World Wide Web fue anunciada públicamente cuando Tim Berners-Lee publicó el primer sitio web. Ese mismo año se creó el primer navegador web gráfico, Mosaic, desarrollado en la Universidad de Illinois en 1993, que revolucionó la experiencia de usuario al permitir la visualización de imágenes junto con texto. La eliminación de las restricciones comerciales sobre el uso de Internet por parte de la National Science Foundation en 1995 marcó un punto de inflexión crucial. Comenzaron a aparecer los primeros proveedores comerciales de servicios de Internet (ISP) como America Online (AOL), que llevó Internet a millones de hogares. Las empresas empezaron a ver el potencial no solo como un medio de comunicación, sino como una plataforma de negocio, surgiendo los primeros sitios de comercio electrónico como Amazon (1995) y eBay (1995). Yahoo! se estableció como uno de los primeros directorios web populares, mientras que motores de búsqueda como AltaVista comenzaron a indexar la creciente web. A finales de la década, Google fue fundado en 1998, revolucionando la búsqueda en Internet. Finalmente, se completó la transición de Internet de un proyecto gubernamental y académico a una infraestructura comercial global.\nEl cambio de milenio trajo la adopción masiva de Internet, inicialmente centrada en la conectividad de banda ancha en hogares y oficinas. La llamada “burbuja de las punto-com” explotó en 2000-2001, pero esto no frenó la innovación. Surgió la Web 2.0 a mediados de la década, caracterizada por sitios interactivos y generados por usuarios. Plataformas como MySpace (2003), Facebook (2004), YouTube (2005) y Twitter (2006) transformaron Internet en un medio social y participativo. La revolución móvil comenzó realmente con el lanzamiento del iPhone en 2007, que democratizó el acceso a Internet desde dispositivos móviles. Esto fue seguido por el desarrollo del sistema operativo Android y la proliferación de smartphones. El concepto de “Internet de las Cosas” (IoT) comenzó a materializarse con dispositivos domésticos inteligentes, wearables y sensores conectados. La década de 2010 vio el surgimiento de la computación en la nube con servicios como Amazon Web Services, la popularización de las redes sociales móviles, el auge del comercio electrónico móvil, y el desarrollo de tecnologías como la realidad virtual y aumentada. Más recientemente, la inteligencia artificial, el machine learning, la tecnología blockchain y las criptomonedas han redefinido las posibilidades de Internet.\nEl número de dispositivos conectados se ha incrementado exponencialmente, pasando de millones en los 90 a miles de millones en la actualidad, marcando el desarrollo de nuevas tecnologías como 5G para soportar el creciente número de dispositivos. En la Figura 2.3 podéis apreciar cómo se han ido incrementando exponencialmente, y esta tendencia está lejos de revertirse. Las redes sociales, herramientas de teletrabajo, VoIP y videollamadas, inteligencia artificial, streaming de video, realidad virtual y aumentada, y otras muchas aplicaciones hacen que no solo se incremente el número de dispositivos conectados, sino también las necesidades de ancho de banda y tiempos de respuesta cada vez más exigentes.\n\n\n\n\n\n\nFigura 2.3: Número de dispositivos conectados por década desde ARPANET hasta Internet en 2025 (Ritchie et al. 2023; Analytics 2020)\n\n\n\nEn conclusión, la evolución de Internet (ver resumen en la Figura 2.4) desde sus orígenes militares como ARPANET hasta convertirse en la infraestructura global actual ilustra una transformación extraordinaria que ha redefinido la sociedad moderna. Lo que comenzó en 1969 como una red experimental de 4 hosts diseñada para resistir ataques nucleares, se ha convertido en un ecosistema interconectado de miles de millones de dispositivos. En los siguientes apartados veremos en detalle la tecnología que sustenta Internet y obtendremos el conocimiento necesario para poder realizar aplicaciones y juegos en red.\n\n\n\n\n\n\nFigura 2.4: Esquema de tiempo de los eventos más significativos desde la creación de ARPANET hasta 2025.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#infraestructura-de-la-red-y-tecnologías-de-transmisión",
    "href": "ch/part_networks/network_intro/network_intro.html#infraestructura-de-la-red-y-tecnologías-de-transmisión",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "2.3 Infraestructura de la red y tecnologías de transmisión",
    "text": "2.3 Infraestructura de la red y tecnologías de transmisión\nEn los capítulos anteriores hemos visto una pequeña introducción a Internet y sus componentes. Ahora pasaremos a ver brevemente la parte física (Hardware) de Internet antes de ver la parte Software en los siguientes capítulos. En la Figura 2.5 tenemos un ejemplo de diagrama donde se muestran los componentes de la red y parte de la taxonomía que veremos en este capítulo.\n\n\n\n\n\n\nFigura 2.5: Red simplificada (Kurose y Ross 2017).\n\n\n\nEmpezando por la parte más externa, vamos a hablar de los sistemas terminales (“end systems”). De forma simplificada, podríamos decir que estos son los sistemas que utilizan la Internet, y que el resto de componentes son los que sustentan la red. En esta categoría tendríamos los ordenadores, smartphones, dispositivos inteligentes.. es decir, los componentes conectados. En la jerga de Internet estos componentes se conocen como “host”, por que son los que tienen aplicaciones que funcionan sobre internet. Estos dispositivos se pueden conectar a la red a través de diferentes tecnologías que veremos posteriormente en este capítulo como WiFi o 5g. Los hosts, dependiendo de su uso, también se pueden clasificar como clientes y servidores. Los servidores generalmente ofrecen un servicio que los clientes utilizan. Por ejemplo, cuando hablamos por Whatsapp, nuestro teléfono y el teléfono destino son clientes, y los “ordenadores” de Whatsapp que ofrecen el servidor son servidores. Esto no es clasificación estática y fija, y un cliente puede actuar de servidor también. Este tipo de clasificación la veremos en más detalle en el Capítulo 6.\nMoviéndonos a la capa más interna tenemos las redes de acceso (“access network”). Las redes de acceso es la red en la cual se conecta un host con el router (también conocido router de borde, o inglés “edge router”) en el camino hacia el núcleo de la red (core network). El router de borde junto a los hosts también forman parte de lo que se denomina el borde de la red (“edge of the network”). Siguiendo con los ejemplos anteriores, cuando nos conectamos a Internet por WiFi/Ethernet en nuestra casa, universidad, etc, nos conectamos al “router”, que sería el router de borde.\nAquí merece la pena hacer una aclaración técnica sobre el “router” doméstico del ejemplo anterior. En realidad, estos dispositivos son equipos multifunción que integran varias tecnologías: un switch para la red local, un router para el enrutamiento entre redes, y típicamente un punto de acceso WiFi. Cuando nos conectamos por cable o WiFi, técnicamente nos conectamos primero al switch integrado, y cuando la comunicación debe salir hacia Internet, el componente router se encarga del enrutamiento hacia otras redes. Aunque en el uso cotidiano llamamos “router” a todo el dispositivo, es importante entender que internamente realiza múltiples funciones de red.\nEn el router doméstico, o router de borde, tenemos dos tipos de conexiones principales: la conexión con los hosts y la conexión con el siguiente router. Vamos a ver brevemente los tipos de tecnología para cada caso. Empezando por la conexión host-router, tenemos dos tipos principalmente: conexión cableada tipo Ethernet y conexión inalámbrica WiFi. En la Tabla 2.1 podéis ver una comparativa de sus principales características.\n\n\n\nTabla 2.1: Tabla comparativa de tecnologías de acceso host-router. *Simétrica en teoría, asimétrica en la práctica.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTecnología\nMedio Físico\nTipo Conexión\nSimetría\nVelocidad Típica\nAlcance\nEstado 2025\n\n\n\n\nWiFi 6\nRadio 2.4/5/6 GHz\nCompartida\nSimétrica*\n200-400 Mb/s\n30-50 m\nEstándar\n\n\nEthernet\nPar trenzado\nDedicada\nSimétrica\n1000/1000 Mb/s\n&lt;100 m\nEstándar\n\n\n4G LTE\nRadio móvil\nCompartida\nAsimétrica\n50/15 Mb/s\nVarios km\nEstable\n\n\n5G\nRadio móvil\nCompartida\nAsimétrica\n300/50 Mb/s\n1-5 km\nEn despliegue\n\n\n\n\n\n\nWiFi 6 es una tecnología de acceso inalámbrico, es decir, no requiere una conexión física entre los dispositivos. Como contrapartida a la flexibilidad de no tener el vínculo físico, el alcance se ve reducido. La máxima distancia entre el router y el dispositivo es típicamente de 30-50 metros, pero puede verse reducida por obstáculos entre ambos. Los estándares WiFi van desde el original 802.11 hasta el más moderno 802.11ax (WiFi 6E), que es capaz de alcanzar velocidades teóricas de hasta 9.6 Gb/s mediante múltiples antenas y técnicas avanzadas. Además, en las últimas versiones se ha incrementado el ancho de banda disponible, incluyendo la banda de 6 GHz, proporcionando espectro adicional para reducir la congestión. La conexión mediante WiFi es simétrica en teoría, aunque en la práctica las velocidades pueden variar según las condiciones del entorno, y del hardware del router y del host. Una de las principales desventajas de los medios inalámbricos es que el medio de transmisión es compartido entre todos los dispositivos, lo que puede causar problemas de congestión cuando hay muchos dispositivos conectados simultáneamente.\nPor otra parte, tenemos el acceso tipo Ethernet, que se realiza mediante un cable físico de par trenzado (que explicaremos más adelante). En este caso, el alcance se extiende hasta algo menos de 100 metros. Al ser una conexión física, generalmente no importa qué obstáculos haya entre ambos puntos4. Algunas personas han intentado empalmar cables para lograr longitudes superiores a 100 metros, pero esto no funciona adecuadamente. Las causas principales son la degradación de la señal y que los protocolos Ethernet están diseñados asumiendo tiempos específicos de propagación en el cable5. Al ser un tipo de conexión dedicada, cuando nos conectamos por cable no tenemos problemas de congestión del medio de transmisión. Las velocidades estándar actuales suelen ser de 1000 Mb/s (Gigabit Ethernet), aunque existen estándares más rápidos como 10 Gigabit Ethernet.\nFinalmente, tenemos las tecnologías de acceso móvil como alternativa de conectividad. Tanto 4G LTE como 5G utilizan ondas de radio en el espectro móvil licenciado para conectar dispositivos con las torres de telefonía, que actúan como puntos de acceso a la red del operador. Su principal ventaja es el amplio alcance (varios kilómetros para 4G, 1-5 km para 5G según la banda), lo que las hace ideales para ubicaciones sin infraestructura fija o como backup de conectividad. Ambas tecnologías son asimétricas y utilizan un medio compartido, con 4G LTE ofreciendo velocidades típicas de 50/15 Mb/s y 5G alcanzando hasta 300/50 Mb/s en condiciones reales. El 5G representa una evolución significativa al usar un espectro más amplio, incluyendo frecuencias milimétricas, aunque presenta un compromiso entre velocidad y alcance: las frecuencias más altas proporcionan mayor velocidad pero menor penetración. Mientras 4G LTE está completamente desplegado, 5G se encuentra en fase de despliegue activo con cobertura variable según ubicación y operador6.\nAhora pasaremos a la conexión del router de borde con el siguiente router. Las tecnologías disponibles\n\nComparativa de diferentes tecnologías {#tab-ni-infra-edge-core}\n\n\n\n\n\n\n\n\n\n\n\nTecnología\nMedio Físico\nTipo Conexión\nSimetría\nVelocidad Típica\nAlcance\nEstado 2025\n\n\n\n\nDial-up\nPar trenzado\nDedicada\nSimétrica\n56 kb/s\nIlimitado*\nObsoleta\n\n\nDSL/VDSL\nPar trenzado\nDedicada\nAsimétrica\n50/15 Mb/s\n&lt;3 km de central\nEn declive\n\n\nCable HFC\nCoaxial/Fibra\nCompartida\nAsimétrica\n300/30 Mb/s\nRed local\nEstable\n\n\nFTTH PON\nFibra óptica\nCompartida\nSimétrica\n1000/1000 Mb/s\n&lt;20 km\nEn expansión\n\n\nFTTH P2P\nFibra óptica\nDedicada\nSimétrica\n10000/10000 Mb/s\n&lt;40 km\nPremium\n\n\nSatelital\nMicroondas\nCompartida\nAsimétrica\n100/20 Mb/s\nGlobal\nNicho\n\n\n\nPara la conexión entre el router de borde y el siguiente router en la jerarquía de red, disponemos de diversas tecnologías WAN (Wide Area Network) que han evolucionado significativamente. Las tecnologías más tradicionales como Dial-up (56 kb/s) están obsoletas, mientras que DSL/VDSL (50/15 Mb/s típicas) se encuentran en declive debido a sus limitaciones de distancia (&lt;3 km de la central telefónica) y asimetría inherente del par trenzado. El Cable HFC (Hybrid Fiber-Coaxial) ofrece velocidades superiores (300/30 Mb/s) mediante una combinación de fibra óptica hasta el vecindario y cable coaxial hasta el hogar, aunque mantiene asimetría y medio compartido. Las tecnologías de fibra óptica representan el estado del arte: FTTH PON (Fiber-to-the-Home Passive Optical Network) proporciona 1000/1000 Mb/s simétricos con medio compartido y está en expansión activa, mientras que FTTH P2P (Point-to-Point) ofrece conexiones dedicadas de hasta 10000/10000 Mb/s para aplicaciones premium. Como alternativa para ubicaciones remotas, la conectividad satelital proporciona cobertura global con velocidades de 100/20 Mb/s, aunque con mayor latencia y asimetría, ocupando un nicho específico donde otras tecnologías no son viables.\nFinalmente, llegamos a la última capa, denominada el núcleo de la red. El núcleo de la red es una compleja jerarquía de redes interconectadas que trabajan conjuntamente para proporcionar conectividad global. Por contextualizar las tres partes de la red mencionadas hasta ahora vamos a ver un ejemplo. Supón que una persona A (host) envía un mensaje (carta) a otra persona B (otro host). La persona A deposita la carta en correos, que sería el router de frontera. Todo el proceso del envío de la carta desde correos (router de frontera de A) hasta llegar al buzón de B (router de frontera de B) sería el núcleo de la red.\nDespués de haber ejemplificado su estructura, vamos a indagar en cómo está estructurado el núcleo de la red. Primeramente hablaremos de su estructura, que comentamos en la introducción tiene una estructura descentralizada, lo que permite que el sistema sea mas robusto y escalable. Los componentes de esta red que nos proporcionan interconexión con otras redes se denominan ISP (proveedores de servicio de Internet, del inglés “Internet Service Providers”). Los ISPs se organizan en tres niveles, cada uno con características y roles específicos en el ecosistema global de conectividad.\nLos proveedores de Nivel 1 (Tier 1 en inglés) forman la élite de Internet, operando las redes troncales globales de más alta capacidad. Estas organizaciones incluyen empresas como Cogent, AT&T, Verizon, TeliaSonera y Telefónica. Los proveedores Tier 1 mantienen infraestructuras que abarcan continentes enteros con enlaces de 10-100 Gb/s y routers de rendimiento extremo capaces de procesar millones de paquetes por segundo. Entre los proveedores ISP Tier 1 se pueden mandar mensajes sin costo alguno mediante acuerdos de “peering” gratuito. Esto mantiene la exclusividad del estatus Tier 1, ya que se deben alcanzar acuerdos con todos los Tier 1 existentes antes de ser considerado Tier 1.\nLos ISP de Nivel 2 (Tier 2 en inglés) operan redes regionales o nacionales más pequeñas que se conectan a Internet a través de uno o más proveedores Tier 1. Pagan a los Tier 1 por “tránsito” - el servicio de llevar su tráfico a destinos que no pueden alcanzar directamente. Sin embargo, los Tier 2 también establecen conexiones directas entre sí cuando es mutuamente beneficioso, reduciendo los costos de tránsito y mejorando el rendimiento para rutas comunes. Estos proveedores sirven como el tejido conectivo esencial de Internet, agregando tráfico de numerosos proveedores más pequeños y proporcionando redundancia y rutas alternativas. Su posición intermedia les permite ofrecer servicios especializados y soporte más personalizado que los grandes Tier 1, mientras mantienen conexiones globales a través de sus relaciones de tránsito.\nLos ISP de Nivel 3 son los proveedores de acceso que conectan directamente a usuarios finales - hogares, pequeñas empresas, y organizaciones locales. Estos proveedores compran conectividad a Internet de ISP de niveles superiores y generalmente no mantienen conexiones directas entre sí. Su valor radica en el conocimiento local, servicio personalizado, y la infraestructura de “última milla” que lleva Internet directamente a los usuarios finales.\n\n\n\n\n\n\nFigura 2.6: Jerarquía de ISPs",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#intro-network-stacks",
    "href": "ch/part_networks/network_intro/network_intro.html#intro-network-stacks",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "2.4 Modelos de Referencia de Redes",
    "text": "2.4 Modelos de Referencia de Redes\nUna vez visto la parte más hardware de Internet, vamos a pasar a introducir la parte software. En concreto, vamos a hablar de cómo se estructura la parte software de la comunicación en red. Primero, vamos a introducir dos conceptos software muy importantes: Las arquitecturas por capas (“Layered architectures”) y la encapsulación.\nLas arquitecturas por capas es una forma de estructurar una aplicación software en capas (componentes) donde cada capa tiene una responsabilidad específica y bien definida. Cada capa proporciona servicios a la capa superior y utiliza los servicios de la capa inferior, creando una jerarquía organizada. Esta organización permite que cada capa se pueda desarrollar, modificar y mantener de forma independiente, siempre que mantenga la misma interfaz con las capas adyacentes.\nEn el contexto de las redes de comunicación, esta aproximación arquitectónica es fundamental porque permite dividir la complejidad de la comunicación en red en problemas más pequeños y manejables. Por ejemplo, una capa puede encargarse únicamente del enrutamiento de datos, mientras que otra se ocupa exclusivamente de la detección y corrección de errores. Esta separación de responsabilidades hace que el sistema sea más modular, escalable y fácil de debuggear.\n\n\n\n\n\n\nTipEncapsulación\n\n\n\nLa encapsulación, por su parte, es el proceso mediante el cual cada capa añade su propia información de control (headers) a los datos que recibe de la capa superior, creando una nueva unidad de datos que pasa a la capa inferior. De esta manera, cada capa trata los datos de las capas superiores como una carga útil (payload) a la que simplemente añade su propia información de control, sin necesidad de entender o modificar el contenido interno de esos datos.\n\n\nBajo estos dos conceptos se definen los dos modelos más importantes: el modelo OSI y el modelo TCP/IP. En la Figura 2.7 podemos ver los modelos OSI y TCP/IP divididos en sus diferentes capas y cuál es la equivalencia entre ambos.\n\n\n\n\n\n\nFigura 2.7: Modelos OSI y TCP/IP.\n\n\n\nEl modelo OSI, desarrollado por la Organización Internacional de Normalización (ISO) en 1984, es un modelo conceptual de siete capas que describe cómo diferentes sistemas de red pueden comunicarse entre sí. El modelo TCP/IP, también conocido como modelo de Internet, es el modelo práctico utilizado en Internet, desarrollado por DARPA con cuatro capas que corresponden aproximadamente a las capas OSI, pero con una estructura más simple y práctica. Aunque en la práctica se usa más el modelo TCP/IP, OSI sigue siendo fundamental para entender los principios de las comunicaciones de red. A continuación, explicamos cada nivel de funcionalidad, mostrando cómo se mapean entre ambos modelos:\nNivel de Aplicación OSI: Capas 7, 6 y 5 (Aplicación, Presentación y Sesión) TCP/IP: Capa de Aplicación\nEn el modelo OSI, este nivel se divide en tres capas separadas, mientras que TCP/IP las agrupa en una sola capa más práctica:\n\nFuncionalidad de Aplicación (OSI Capa 7): Es la capa más cercana al usuario final. Aquí residen las aplicaciones de red como navegadores web (HTTP/HTTPS), clientes de correo electrónico (SMTP, POP3, IMAP), transferencia de archivos (FTP) y servicios de nombres de dominio (DNS). Esta capa proporciona servicios directamente a las aplicaciones del usuario.\nFuncionalidad de Presentación (OSI Capa 6): Se encarga de la traducción, cifrado y compresión de datos. Convierte los datos del formato de aplicación al formato de red y viceversa. Maneja diferentes representaciones de datos (ASCII, EBCDIC), cifrado/descifrado y compresión/descompresión.\nFuncionalidad de Sesión (OSI Capa 5): Establece, mantiene y termina las sesiones de comunicación entre aplicaciones. Controla los diálogos/conexiones entre ordenadores, implementa checkpoints para recuperación en caso de fallo y gestiona el control de acceso.\n\nEn TCP/IP, todas estas funcionalidades están integradas en la Capa de Aplicación, que incluye protocolos como HTTP/HTTPS para web, SMTP para correo electrónico, FTP para transferencia de archivos, DNS para resolución de nombres, y muchos otros que proporcionan servicios directos a los usuarios. Esta aproximación más práctica evita la complejidad de separar artificialmente funciones que a menudo están estrechamente relacionadas.\nNivel de Transporte OSI: Capa 4 (Transporte) TCP/IP: Capa de Transporte Este nivel es prácticamente idéntico en ambos modelos. Proporciona transferencia de datos confiable entre sistemas finales, maneja el control de flujo, la corrección de errores y la segmentación/reensamblado de datos.\nLos protocolos principales son:\n\nTCP (Transmission Control Protocol): Ofrece comunicación confiable con control de flujo, corrección de errores y garantía de entrega ordenada.\nUDP (User Datagram Protocol): Ofrece comunicación rápida pero sin garantías de entrega, ideal para aplicaciones en tiempo real.\n\nNivel de Red/Internet OSI: Capa 3 (Red) TCP/IP: Capa de Internet\nAmbos modelos manejan esta funcionalidad de manera muy similar. Se encarga del enrutamiento de paquetes a través de múltiples redes, determinando la mejor ruta para enviar datos desde el origen hasta el destino. El protocolo principal es IP (Internet Protocol), junto con protocolos auxiliares como:\n\nICMP: Para mensajes de control y error.\nARP: Para resolución de direcciones (en TCP/IP).\nProtocolos de enrutamiento: Como OSPF y BGP.\n\nNivel de Acceso Físico OSI: Capas 2 y 1 (Enlace de Datos y Física) TCP/IP: Capa de Acceso a la Red\nEl modelo OSI separa estas funciones en dos capas distintas, mientras que TCP/IP las combina por practicidad:\n\nFuncionalidad de Enlace de Datos (OSI Capa 2): Proporciona transferencia de datos libre de errores entre nodos adyacentes. Se divide en dos subcapas: LLC (Logical Link Control) y MAC (Media Access Control). Maneja la detección y corrección de errores a nivel de enlace y controla el acceso al medio físico.\nFuncionalidad Física (OSI Capa 1): Define las características eléctricas, mecánicas y funcionales para activar, mantener y desactivar el enlace físico. Especifica voltajes, velocidades de datos, conectores y otros aspectos del medio de transmisión (cable, fibra óptica, radio).\n\nEn TCP/IP, la Capa de Acceso a la Red combina ambas funcionalidades, encargándose de la transmisión de datos en la red local específica, incluyendo tecnologias como Ethernet, WiFi, y otros protocolos de acceso al medio.\nDiferencias Clave Entre los Modelos\n\nComplejidad: OSI tiene 7 capas vs 4 en TCP/IP, siendo OSI más detallado teóricamente pero TCP/IP más práctico.\nUso real: TCP/IP es el modelo usado en Internet, mientras que OSI es principalmente un modelo de referencia educativo.\nFlexibilidad: TCP/IP agrupa funcionalidades relacionadas, evitando separaciones artificiales que raramente se implementan por separado en la práctica.\nEvolución: TCP/IP evolucionó con Internet, mientras que OSI fue diseñado como estándar teórico antes de su implementación masiva.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#rendimiento",
    "href": "ch/part_networks/network_intro/network_intro.html#rendimiento",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "2.5 Rendimiento",
    "text": "2.5 Rendimiento\nPor último, vamos a cerrar esta introducción a las redes de telecomunicaciones describiendo brevemente los factores presentes en su rendimiento. Primero, vamos a conceptualizarlo con un ejemplo simplificado. Supongamos que la red de telecomunicación es una carretera entre dos puntos y los paquetes son los vehículos. ¿Cómo podríamos medir el rendimiento de este sistema? Las dos métricas más sencillas serían el tiempo en recorrer la carretera y la cantidad de vehículos que pueden circular a la vez. La primera métrica se conoce como latencia, y está influenciada en nuestro ejemplo por la velocidad del medio, y la segunda se conoce como la tasa de transferencia efectiva (throughput), que sería el número de carriles de las carreteras. El objetivo, bajo estas dos métricas, sería que los vehículos fueran lo más rápido posible aprovechando todos los carriles, consiguiendo que el número de vehículos que llega sea lo más alto posible.\nEl ejemplo es muy simple, pero nos ha ayudado a introducir dos conceptos clave, la latencia y el throughput. En este capítulo veremos cuáles son los principales factores que influyen en estos dos conceptos cuando en lugar de tener una carretera, tenemos varias carreteras con conexiones entre ellas y no todos los vehículos van al mismo sitio. Las conexiones entre las carreteras, es decir, las redes, se realiza a través de routers como hemos comentado en los capítulos anteriores.\nPrimero, nos vamos a centrar en el throughput, que es la cantidad de datos real que podemos transmitir por unidad de tiempo. Generalmente se mide en Mb/s o Gb/s. El throughput a veces se mide de manera instantánea pero también se puede considerar como media de un periodo de tiempo. El throughput está limitado por el componente más “lento” en el camino entre dos puntos. Por ejemplo, si estamos descargando información y el medio tiene un throughput de 1Gb/s pero el servidor solo es capaz de proporcionar 100Mb/s, el throughput resultante será 100Mb/s.\nUn término asociado al throughput es el ancho de banda (bandwidth). El bandwidth es la capacidad máxima teórica del canal de comunicación, es decir, la cantidad máxima de datos que puede transmitir por unidad de tiempo en condiciones ideales. Es decir, es el límite físico. Por otra parte, el throughput como dijimos es la cantidad real que obtenemos condiciones reales.\n\n\n\n\n\n\nNota\n\n\n\nEs importante no confundir MB/s con Mb/s (u otros pares como GB/s con Gb/s). En informática se suele hablar en MB/s, es decir, MegaBytes por segundo, mientras que en telecomunicaciones se suele hablar en Mb/s. Es una diferencia importante ya que un MB/s es 8 veces más velocidad que un Mb/s.\n\n\nAhora pasaremos a la latencia de red, y los factores que la definen. La latencia es el tiempo total que tarda un paquete en viajar desde el origen hasta el destino. Esta latencia no se mide únicamente con el tiempo teórico de propagación por el medio, sino que es la suma de varios factores. Primero nos enfocaremos en los factores que afectan a un único paquete:\n\nRetardo de procesamiento (\\(d_{proc}\\)): El retardo de procesamiento es el tiempo que tarda un router en procesar el paquete. Esto incluye, comprobar la integridad del paquete (checksum), determinar cuál es el siguiente salto y otros procesos adicionales del protocolo. En los routers modernos este proceso normalmente es de microsegundos en condiciones normales, pero puede incrementarse en caso de congestión o políticas adicionales. Este procesamiento se lleva a cabo en hardware especializado (ASICs), pero en determinadas circunstancias es posible que sea necesario inspeccionar el paquete mediante software, como por ejemplo en Deep Packet Inspection, que se suele utilizar para monitorizar la red por seguridad o para forzar políticas Kurose y Ross (2017).\nRetardo de cola (\\(d_{queue}\\)): El retardo de cola ocurre una vez se ha procesado el paquete con su correspondiente retardo de procesamiento. En este momento, el paquete es colocado en un buffer con la información necesaria para determinar el siguiente salto. El retardo de cola es el tiempo que tarda el paquete en ser enviado al siguiente salto. Si hay poco tráfico, el retardo de cola será casi nulo, en cambio, si hay mucho tráfico este retardo crecerá considerablemente.\nRetardo de propagación (\\(d_{prop}\\)): El retardo de propagación es el tiempo que tarda en viajar un paquete por el medio, como puede ser la fibra óptica o 5G, o generalmente, una combinación de varias, ya que de un punto a otro puede haber diferentes medios. El retardo, por lo tanto, es la suma de los retardos de cada uno de los medios. El retardo de un medio, se calcula como \\(d/s\\), donde d es la longitud del medio y s es la velocidad del medio. Por contextualizar con datos las velocidades de los medios, la fibra óptica y el cable coaxial tienen una velocidad (en promedio) de aproximadamente el 67% de la velocidad de la luz y en el 5G la velocidad de la luz Kurose y Ross (2017). Este retardo está limitado por las leyes de la física.\n\nEstos factores afectan a un único paquete, pero generalmente cuando enviamos algo es demasiado grande como para entrar en un paquete y se divide en varios paquetes, que posteriormente se recomponen en el destino. Por lo tanto, tenemos otro tipo de retardo, que tiene en cuenta la cantidad de información que queremos enviar:\n\nRetardo de transmisión (\\(d_{trans}\\)): Este retardo está determinado por el tamaño de la información que queremos enviar (L) y la velocidad del enlace (R), es decir, \\(L/R\\). Generalmente este retardo es predecible y constante, pero puede variar significativamente entre tecnologías de red. La velocidad del enlace es el throughput.\n\nUna vez definidos todos los factores, podemos expresar el retardo total como:\n\\(d_{total} = d_{proc} + d_{queue} + d_{prop} + d_{trans}\\)\nVamos a ver un ejemplo “real” de retardo comparando dos enlaces, uno con fibra y otro con 5G. Haremos la comparación hasta el primer router (router de borde) incluido:\n\nRetardo de propagación: Como comentamos previamente, el 5G se propaga a la velocidad de la luz y la fibra aproximadamente al 67% de la velocidad de la luz. Por lo tanto, el 5G es más rápido.\nRetardo de procesamiento: En 5G tenemos retardo debido a la estación de radio, la decodificación y la gestión de los recursos de radio (aproximadamente unos 4ms). En cambio, en la fibra este proceso es mucho más rápido, necesitando aproximadamente unos 0.1ms por salto. La fibra suele ser mucho más rápida.\nRetardo de cola: A una estación suele haber conectados cientos de dispositivos, puede haber interferencias y además también suelen ser dependientes del clima. Un ejemplo de esto lo podréis haber vivido cuando estáis en un concierto con miles de personas y no funciona bien la conexión debido a la congestión. En el caso de la fibra óptica suele haber menos congestión, el número de usuarios es predecible y los sistemas cuentan con buffers más grandes y eficientes.\nRetardo de transmisión: El throughput en 5G es inferior a 1Gb/s, mientras que en fibra pueden llegar actualmente a 10 Gb/s.\n\n\n\n\n\n\n\nNotaLatencia vs Throughput\n\n\n\nLa latencia mide cuánto tiempo tarda en llegar la información y el throughput mide cuánta información puede viajar simultáneamente por el canal de comunicación. Volviendo al ejemplo de la carretera: la latencia sería el tiempo que tarda un vehículo en recorrer toda la carretera de extremo a extremo, mientras que el throughput sería la cantidad total de vehículos que pueden pasar por la carretera en un periodo determinado (relacionado con el número de carriles y la densidad de tráfico).\n\n\nUn concepto asociado a la latencia de suma importancia en las aplicaciones en red, especialmente los juegos interactivos es el jitter. Cuando enviamos varios paquetes podemos calcular una latencia promedio, ya que no todos los paquetes tardarán lo mismo debido a las condiciones de red y diferentes rutas. En aplicaciones altamente interactivas tener una latencia promedio baja es indispensable. Sin embargo, considera este pequeño ejemplo donde se envían 4 paquetes.\n\nEscenario 1: Los paquetes tardan 50ms, 52ms, 48ms, 51ms\nEscenario 2: Los paquetes tardan 28ms, 68ms, 43ms, 62ms.\n\nEn ambos escenarios los paquetes tienen una latencia promedio de 50.25ms. Sin embargo, la variación entre los paquetes es elevada. En el primer caso, la variación es de 1.48ms mientras que en el segundo es de 15.82ms. Esta variabilidad se conoce como jitter. Un jitter alto puede ocasionar voz entrecortada o saltos en videoconferencias o degradación de la calidad en videojuegos. En el caso de los videojuegos, se suelen utilizar buffers para realizar interpolaciones de los elementos de red y así tener un juego más fluido.\nFinalmente, vamos a ver un último factor que no se ajusta a los anteriores. Hasta ahora hemos asumido que todos los paquetes que enviamos llegan correctamente a su destinatario. Pero esto no es siempre cierto. Por ejemplo, si un router está congestionado y tiene su buffer lleno, descartará los paquetes. Si un paquete se corrompe debido a alteraciones (e.g., campos electromagnéticos, radiación solar7) un router de tránsito lo podrá descartar. Esto forma parte del protocolo de Internet. Otros protocolos, en capas superiores como por ejemplo TCP, tienen en cuenta estas situaciones y reenvían el paquete cuando determinan que no ha llegado a su destino.\nAplicaciones Prácticas: Videojuegos Cuando estamos diseñando aplicaciones en red tenemos que tener en cuenta estos retardos, pues pueden hacer nuestra aplicación inutilizable. En el caso de los videojuegos, los requisitos de retardo máximo vendrán dados dependiendo del tipo de juego, por ejemplo Claypool y Claypool (2006):\n\nReal-Time Strategy (RTS): Tolerancia media (100-200ms) debido a su naturaleza estratégica.\nTurn-Based Games: Tolerancia alta (500ms+) debido a que los turnos son discretos.\nFirst-Person Shooters (FPS): Baja tolerancia (20-50ms) para juegos competitivos.\nFighting Games: Tolerancia muy baja (1-3 frames, ~16-50ms).\nRacing Games: Tolerancia baja o moderada (50-100ms) dependiendo del realismo.\nMMORPGs: Tolerancia variable dependiendo de la actividad, por ejemplo combates vs social.\n\nEstos tiempos se miden en RTT (Round Trip Time), que involucra el tiempo entre que se manda el mensaje, se procesa en el servidor, y obtenemos la respuesta de vuelta en el cliente.\n\n\n\n\nAnalytics, IoT. 2020. «Internet of Things (IoT) and non-IoT active device connections worldwide from 2010 to 2025 (in billions)». Statista. https://www.statista.com/statistics/1101442/iot-number-of-connected-devices-worldwide/.\n\n\nBBC Brasil. 2019. «[Image from: Article Title]». https://www.bbc.com/portuguese/geral-50162526.\n\n\nClaypool, Mark, y Kajal Claypool. 2006. «Latency and player actions in online games». Commun. ACM 49 (11): 40-45. https://doi.org/10.1145/1167838.1167860.\n\n\nKurose, James F., y Keith W. Ross. 2017. Computer Networks: A Top-Down Approach. 7.ª ed. Boston, MA: Pearson.\n\n\nRitchie, Hannah, Edouard Mathieu, Max Roser, y Esteban Ortiz-Ospina. 2023. «Internet». Our World in Data. https://ourworldindata.org/internet.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_intro/network_intro.html#footnotes",
    "href": "ch/part_networks/network_intro/network_intro.html#footnotes",
    "title": "2  Introducción a las Redes de Ordenadores",
    "section": "",
    "text": "Enrutamiento es una adaptación al español del término inglés routing. Aunque no está reconocida oficialmente por la RAE (2025) y el término normativo sería encaminamiento, en estos apuntes se utilizará enrutamiento por ser la forma más habitual en el ámbito de las redes y telecomunicaciones.↩︎\nAlgunos componentes de Internet tienen una arquitectura híbrida, como los ISPs grandes y DNS.↩︎\nLos routers comparten y propagan información de congestión y destinos disponibles con los routers adyacentes.↩︎\nTécnicamente sí pueden afectar ciertos factores, por ejemplo, campos magnéticos intensos o interferencias electromagnéticas sobre el cable Ethernet.↩︎\nLa resistencia del cable se incrementa linealmente con la distancia, aumenta la probabilidad de interferencias electromagnéticas, y se degrada la relación señal-ruido, entre otros factores.↩︎\nEl rendimiento de ambas tecnologías puede degradarse significativamente en áreas de alta densidad poblacional o durante horas pico debido a la congestión del medio compartido.↩︎\nLa radiación cósmica produce cambios de bits en dispositivos electrónicos, que se denominan SEU (Single Event Upset). Estos cambios suelen afectar a las DRAM, SRAM y ASICs. Contrario a la intuición, es algo relativamente frecuente, y ocurre con una tasa aproximada de 1 error por cada 256MB por día a nivel del mar. Cuanto más altitud (o dicho de otra forma, más cerca del espacio), esta tasa se incrementa considerablemente. A nivel de red esto suele ocurrir en los routers.↩︎",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a las Redes de Ordenadores</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/access_layer/access_layer.html",
    "href": "ch/part_networks/access_layer/access_layer.html",
    "title": "3  Capa de Acceso a la Red",
    "section": "",
    "text": "3.1 Funciones principales de la Capa de Acceso a la Red\nLa Capa de Acceso a la Red se encarga de la transmisión física de datos entre dispositivos directamente conectados en una red local, manejando tanto los aspectos físicos de la transmisión como el control de acceso al medio compartido. Esta capa combina las funciones de las capas física y de enlace de datos del modelo OSI, proporcionando una interfaz entre los protocolos de red de nivel superior y el hardware de red específico. Su principal responsabilidad es garantizar que los datos puedan transmitirse de manera confiable entre nodos adyacentes en la red.\nEl capítulo se divide en un apartado donde veremos las principales funciones de la red y después veremos los protocolos definidos en esta capa. Para guiar el aprendizaje, antes veremos un ejemplo del funcionamiento de la Capa de Acceso a Red. No os preocupéis si no entendéis por ahora todos los conceptos, los iremos viendo a lo largo de este capítulo.\nConsideremos una red Ethernet típica con un switch central conectando cuatro computadoras (A, B, C, D) con las siguientes direcciones MAC:\nComo ejemplo, vamos a ver los pasos para el envío de un mensaje desde A a C. Podéis ver la representación en un diagrama de secuencia en la Figura 3.1. Los pasos serían los siguientes:\nLa Capa de Acceso a la Red desempeña múltiples funciones críticas que trabajan en conjunto para garantizar una comunicación eficiente y confiable entre dispositivos en la red local.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Capa de Acceso a la Red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/access_layer/access_layer.html#funciones-principales-de-la-capa-de-acceso-a-la-red",
    "href": "ch/part_networks/access_layer/access_layer.html#funciones-principales-de-la-capa-de-acceso-a-la-red",
    "title": "3  Capa de Acceso a la Red",
    "section": "",
    "text": "Control de Acceso al Medio (MAC)\nLa función de control de acceso al medio (MAC) es fundamental para coordinar cómo múltiples dispositivos comparten un medio de transmisión común. Esta función implementa diversos algoritmos y protocolos según la tecnología de red utilizada. Su eficiencia determina directamente el rendimiento y la escalabilidad de toda la red local. En redes Ethernet tradicionales de half-duplex (sólo pueden transmitir en una dirección a la vez), los dispositivos emplean el método CSMA/CD (Carrier Sense Multiple Access with Collision Detection), donde primero escuchan el medio antes de transmitir para verificar que esté libre, permiten que múltiples dispositivos accedan al mismo medio compartido, y detectan colisiones durante la transmisión implementando algoritmos de backoff exponencial para programar retransmisiones inteligentes.\nLas redes inalámbricas, por el contrario, utilizan CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) debido a que la detección de colisiones es impráctica en el medio radioeléctrico. En este esquema, los dispositivos esperan un tiempo aleatorio antes de transmitir para reducir la probabilidad de colisiones, utilizan mecanismos de acknowledgment para confirmar que la transmisión fue recibida correctamente, e implementan el protocolo RTS/CTS (Request to Send/Clear to Send) para resolver el problema del nodo oculto donde algunos dispositivos no pueden detectar las transmisiones de otros.\nComplementariamente, los mecanismos de control de flujo evitan que transmisores rápidos saturen receptores más lentos mediante técnicas como Pause Frames en Ethernet full-duplex (se puede transmitir en ambas direcciones a la vez) que permiten al receptor solicitar pausas temporales, buffer management en switches para absorber ráfagas de tráfico sin pérdida de datos, y rate limiting para controlar dinámicamente la velocidad de transmisión según las condiciones de la red.\n\n\nDireccionamiento Físico\nEl direccionamiento físico opera a nivel de hardware y es independiente de los protocolos de capa superior. Utiliza direcciones MAC únicas para identificar cada interfaz de red en el segmento local. Este sistema de direccionamiento es esencial para la entrega precisa de tramas entre dispositivos directamente conectados. Las direcciones MAC son como el DNI del dispositivo, son únicas, estáticas y cada dispositivo tiene una. Están formadas por 48 bits siguen una estructura específica donde los primeros 24 bits constituyen el OUI (Organizationally Unique Identifier) asignado por IEEE a cada fabricante, los últimos 24 bits forman el identificador único del dispositivo asignado por el fabricante, y bits especiales indican si la dirección es individual o grupal y si está administrada universalmente o localmente. Las MAC se representan mediante octetos 6 octetos separados por dos “:”, como por ejemplo “00:1A:2B:3C:4D:5E”.\n\n\n\n\n\n\nTipDirección MAC\n\n\n\nUna dirección MAC es un identificador único asignado a cada tarjeta de red. Están formados por 48 bits donde la primera parte identifica al fabricante, después el dispositivo dentro del fabricante, y por último tiene unos bits especiales.\n\n\nEl sistema soporta tres tipos principales de direccionamiento: unicast para comunicación dirigida a un único dispositivo específico, broadcast utilizando la dirección especial FF:FF:FF:FF:FF:FF para alcanzar todos los dispositivos del segmento simultáneamente, y multicast para dirigir tráfico a grupos específicos de dispositivos identificados por el primer bit configurado en 1.\n\n\nDetección y Corrección de Errores\nEsta función garantiza la integridad de los datos transmitidos a través del medio físico. Implementa algoritmos como Códigos de Redundancia Cíclica (CRC) para detectar errores de transmisión y mecanismos de retransmisión cuando es necesario. Sin esta función, los datos corruptos podrían propagarse por la red causando problemas de comunicación. Los códigos de CRC son ampliamente utilizados y generan un polinomio matemático basado en los datos originales, agregan el resultado como Frame Check Sequence (FCS) al final de cada trama, y permiten al receptor recalcular el CRC para compararlo con el recibido, detectando efectivamente errores de un solo bit y muchos errores de múltiples bits. Para aplicaciones menos críticas existen checksums simples que realizan una suma aritmética de todos los bytes de datos, son menos robustos que CRC pero requieren menos procesamiento computacional.\nLas técnicas más avanzadas incluyen Forward Error Correction (FEC) que no solo detecta sino que corrige errores automáticamente, utiliza códigos como Hamming para corrección de errores de un solo bit y Reed-Solomon para errores en ráfagas, y es especialmente importante en medios inalámbricos donde la interferencia y las condiciones ambientales pueden causar errores frecuentes.\n\n\nControl de tamaño\nEsta función maneja las limitaciones de tamaño impuestas por diferentes tecnologías de red. Cada tecnología de red define un Maximum Transmission Unit (MTU) específico que determina el tamaño máximo de datos que puede transportar una sola trama, donde Ethernet maneja 1500 bytes de datos, Token Ring típicamente 4464 bytes, FDDI 4352 bytes, y PPP sobre enlaces seriales utiliza valores variables aunque comúnmente 1500 bytes para mantener compatibilidad. Cuando los datos de capas superiores exceden el MTU disponible, la Capa de Acceso a la Red descarta automáticamente el paquete.\n\n\nSincronización y Temporización\nEsta función coordina el timing entre dispositivos para asegurar la correcta interpretación de las señales digitales. Establece marcos de tiempo comunes para la transmisión y recepción de datos. Es especialmente crítica en redes de alta velocidad donde pequeñas diferencias de timing pueden causar errores de comunicación. La sincronización de reloj es esencial para el funcionamiento correcto de cualquier comunicación digital, abarcando la sincronización de bit para determinar precisamente los límites temporales de cada bit transmitido, la sincronización de trama para identificar inequívocamente el inicio y fin de cada trama de datos, y la sincronización de símbolo necesaria en modulaciones complejas como QAM donde múltiples bits se codifican en un solo símbolo.\n\n\nGestión de Topología\nEsta función se encarga de descubrir y mantener información sobre la estructura física de la red. Implementa protocolos para detectar enlaces, prevenir bucles y optimizar rutas de comunicación. Permite que la red se adapte automáticamente a cambios en la topología como fallos de enlaces o adición de nuevos dispositivos. El mantenimiento continuo de enlaces se logra mediante mensajes de tipo keepalive que detectan proactivamente fallos de enlace antes de que afecten el tráfico de usuarios. Los protocolos de detección de topología como CDP (Cisco Discovery Protocol) y LLDP (Link Layer Discovery Protocol) permiten que los dispositivos se identifiquen mutuamente y compartan información sobre sus capacidades, mientras que Spanning Tree Protocol previene bucles peligrosos en topologías redundantes que podrían causar tormentas de broadcast.\n\n\nControl de Calidad de Servicio (QoS)\nEsta función prioriza diferentes tipos de tráfico según su importancia y requisitos de rendimiento. Es fundamental para el funcionamiento adecuado de aplicaciones en tiempo real como voz y vídeo. Esto se logra implementando mecanismos de gestión de buffers y scheduling para garantizar que aplicaciones críticas reciban el ancho de banda necesario, y se realiza bajo estándares de clasificación. Los mecanismos de gestión de buffers aseguran que diferentes tipos de tráfico reciban el tratamiento apropiado mediante Weighted Fair Queuing que asigna recursos proporcionalmente según la importancia de cada clase de tráfico, priority queuing que garantiza que el tráfico más crítico siempre tenga precedencia sobre tráfico menos importante, y Random Early Detection que previene congestión descartando proactivamente paquetes menos críticos antes de que los buffers se saturen completamente.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Capa de Acceso a la Red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/access_layer/access_layer.html#dispositivos-de-la-capa-de-acceso-a-la-red",
    "href": "ch/part_networks/access_layer/access_layer.html#dispositivos-de-la-capa-de-acceso-a-la-red",
    "title": "3  Capa de Acceso a la Red",
    "section": "3.2 Dispositivos de la Capa de Acceso a la Red",
    "text": "3.2 Dispositivos de la Capa de Acceso a la Red\nLos switches son dispositivos de red que operan en la Capa de Acceso a la Red, específicamente en la subcapa de enlace de datos. Funcionan como elementos centrales que conectan múltiples dispositivos en una red local, creando dominios de colisión separados para cada puerto. Es decir, que la información de dispositivos conectados por diferentes puertos no colisiona entre sí, ya que no están en el mismo medio. Estos dispositivos evolucionaron desde los bridges tradicionales (que conectaban solo 2-4 segmentos) hasta reemplazar los hubs tradicionales, donde todos los puertos operaban igual con colisiones frecuentes a un sistema donde cada puerto opera independientemente con capacidades full-duplex que permiten transmisión y recepción simultánea, duplicando efectivamente el ancho de banda disponible. Su importancia radica en funcionalidades clave como el aprendizaje automático de direcciones MAC donde construyen dinámicamente tablas que asocian cada dirección con su puerto específico, el reenvío selectivo que envía tramas únicamente al puerto de destino reduciendo tráfico innecesario.\nLos switches se categorizan principalmente en dos tipos según sus capacidades de gestión:\n\nno gestionados: son plug-and-play y se utilizan generalmente en redes pequeñas y domésticas.\ngestionados: ofrecen un control más granular y más capacidades, como seguridad, monitorización y medidas QoS.\n\nLos puntos de acceso son dispositivos fundamentales para la conectividad inalámbrica en la Capa de Acceso a la Red que actúan como traductores entre medios cableados e inalámbricos, manejan la asociación y autenticación de dispositivos inalámbricos, e implementan CSMA/CA para coordinar el acceso al medio y evitar colisiones en el espectro radioeléctrico compartido.\nLos repetidores extienden el alcance de las redes regenerando señales digitales sin filtrar tráfico ni reducir colisiones, simplemente reciben, amplifican y retransmiten las señales para superar las limitaciones de distancia de los medios físicos. Los amplificadores incluyen RF amplifiers que aumentan la potencia de señales inalámbricas y optical amplifiers que amplifican señales en fibra óptica sin conversión eléctrica, todos debiendo cumplir estrictas regulaciones de potencia de transmisión para evitar interferencia con otros sistemas.\nLos conversores de medio facilitan la interoperabilidad convirtiendo entre diferentes medios físicos como fibra óptica y cobre, adaptando automáticamente velocidades, y permitiendo extensión de redes existentes o migración gradual a tecnologías más avanzadas.\nTabla de resumen:\n\n\n\n\n\n\n\n\n\nDispositivo\nFunción Principal\nCaracterísticas Clave\nAplicación Típica\n\n\n\n\nSwitches No Gestionados\nConectividad básica LAN\nPlug-and-play, aprendizaje MAC automático, full-duplex\nRedes pequeñas y domésticas\n\n\nSwitches Gestionados\nConectividad LAN avanzada\nVLANs, QoS, SNMP, seguridad 802.1X, port mirroring\nRedes empresariales\n\n\nPuntos de acceso\nConectividad inalámbrica\nCSMA/CA, traducción cableado-wireless, beamforming\nRedes Wi-Fi empresariales\n\n\nRepetidores\nExtensión de alcance\nRegeneración de señal, sin filtrado\nSuperación de límites de distancia\n\n\nAmplificadores\nAmplificación de señal\nAumento de potencia RF/óptica\nEnlaces de larga distancia\n\n\nConversores de medio\nConversión de medios\nFibra ↔︎ cobre, adaptación de velocidades\nMigración gradual, extensión\n\n\nModulador\nConectividad modular\nSFP/SFP+/QSFP, intercambiables\nFlexibilidad en tipos de conexión",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Capa de Acceso a la Red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/access_layer/access_layer.html#protocolos",
    "href": "ch/part_networks/access_layer/access_layer.html#protocolos",
    "title": "3  Capa de Acceso a la Red",
    "section": "3.3 Protocolos",
    "text": "3.3 Protocolos\n\nEthernet (IEEE 802.3)\nEthernet es el protocolo dominante en redes cableadas locales. Define tanto el formato de las tramas como los métodos de acceso al medio. Su éxito radica en la simplicidad de implementación, la robustez del diseño, y la capacidad de evolucionar continuamente para satisfacer las demandas crecientes de ancho de banda en entornos empresariales y domésticos. Al principio en Ethernet se tenía una arquitectura de medio compartida, y por ello, se tenían que utilizar técnicas como CSMA/CD para minimizar colisiones. Esto hacía que eficiencia de la red disminuyese. Con la llegada de los bridges y switches, se introdujo una topología de estrella, donde todos están conectados al switch y este crea dominios de colisión independientes, volviendo innecesario el CSMA/CD y mejorando considerablemente la eficiencia de la red.\nLa estructura de las tramas Ethernet sigue un formato estandarizado que garantiza la interoperabilidad entre dispositivos de diferentes fabricantes. Cada trama comienza con un preámbulo de 8 bytes que proporciona sincronización entre el transmisor y receptor, estableciendo el timing necesario para la correcta interpretación de los bits que siguen. Las direcciones MAC de destino y origen, de 6 bytes cada una, identifican inequívocamente los dispositivos involucrados en la comunicación, mientras que el campo Tipo/Longitud de 2 bytes especifica qué protocolo de capa superior procesa los datos o la longitud de la carga útil cuando es menor a 1536 bytes. El contenido útil reside en el campo de data/payload que puede contener entre 46 y 1500 bytes de información útil, con padding automático cuando los datos son menores al mínimo requerido, y finalmente el Frame Check Sequence de 4 bytes implementa detección de errores CRC permitiendo al receptor verificar la integridad de toda la trama recibida.\n\n\n\n\n\n\nFigura 3.2: Cabeceras de un paquete de Ethernet.\n\n\n\nLa evolución de Ethernet ha sido extraordinaria, comenzando con 10Base-T que maneja 10 Mbps sobre cable trenzado CAT3/5, evolucionando hasta 10GBase-T con 10 Gbps sobre CAT6A/7. En contextos intensivas, o en nodos centrales, se cuenta con implementaciones de mayor velocidad. Todo esto se ha conseguido a través de diferentes estandares de modelos físicos y la mejora de rendimiento en el hardware. También se ha vuelto posible combinar la transmisión de datos y energía eléctrica por un mismo cable, simplificando los dispositivos de red.\n\n\n\n\n\n\nNotaLimite de longitud\n\n\n\nEn los cables de pares trenzados hechos de cobre el límite máximo de trasmisión es de 100 metros. Es decir, que cada 100 metros hay que añadir un dispositivo de red que regenere la señal, como switches o repetidores, para evitar la degradación y pérdida de datos. Esta limitación se debe a la atenuación de la señal y la interferencia electromagnética que se acumulan con la distancia. Para superar esta restricción se utilizan alternativas como fibra óptica (alcanza kilómetros sin regeneración), extensores Ethernet (hasta 300m), o tecnologías inalámbricas. En entornos empresariales, esto determina la ubicación estratégica de closets de telecomunicaciones en la arquitectura de red.\n\n\n\n\nWi-Fi (IEEE 802.11)\nEl protocolo Wi-Fi maneja la comunicación inalámbrica y debe lidiar con desafíos únicos como la interferencia y la movilidad de dispositivos. A diferencia de las redes cableadas donde el medio físico está claramente definido y controlado, las redes inalámbricas operan en un espectro electromagnético compartido donde múltiples factores pueden afectar la calidad de la transmisión. Esta complejidad ha llevado al desarrollo de sofisticados mecanismos de control y técnicas avanzadas de modulación que permiten comunicaciones confiables incluso en entornos con alta densidad de dispositivos. Uno de los métodos principales es la utilización de CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance).\nLa trama Wi-Fi (802.11) es considerablemente más compleja que Ethernet debido a los desafíos únicos del medio inalámbrico. El Frame Control contiene información crítica sobre el tipo de trama, versión del protocolo, y flags especiales para funciones como gestión de energía y fragmentación. El campo Duration/ID implementa el mecanismo de reserva virtual del medio, permitiendo que otros dispositivos sepan cuánto tiempo estará ocupado el canal. La característica más distintiva son las múltiples direcciones MAC (hasta 4) que manejan la complejidad de las redes inalámbricas. Address 1 identifica al receptor inmediato, Address 2 al transmisor inmediato, Address 3 proporciona filtrado adicional (a menudo el BSSID del punto de acceso), y Address 4 se utiliza únicamente en sistemas de distribución inalámbrica cuando los access points se comunican entre sí. Los campos opcionales reflejan la evolución del estándar: QoS Control permite priorización de tráfico para aplicaciones sensibles al tiempo, HT Control habilita características de alto rendimiento como MIMO y beamforming, y el Sequence Control maneja la ordenación de tramas y detección de duplicados, crítico en un medio donde las transmisiones pueden perderse o duplicarse debido a interferencia.\n\n\n\n\n\n\nFigura 3.3: Cabeceras de un paquete Wi-Fi\n\n\n\nAl igual que en Ethernet, la evolución de Wi-Fi ha sido enorme. Los primeros estándares, 802.11n (Wi-Fi 4), contaban con velocidades de hasta 600 Mbps, mientras que Wi-Fi 7 (802.11be) promete hasta 46 Gbps. Las mejoras se han enfocado en técnicas para reducir interferencias entre redes y colisiones entre dispositivos, y la inclusión de más bandas:\n\n2.4 GHz: mayor alcance y penetración, pero menor velocidad.\n5 GHz: mayor velocidad pero menor alcance.\n6 GHz: mejor rendimiento, aunque requiere de hardware específico y tiene el mejor alcance.\n\n\n\nPoint-to-Point Protocol (PPP)\nPPP se utiliza para conexiones directas entre dos dispositivos, comúnmente en enlaces seriales y conexiones de acceso telefónico. Este protocolo fue diseñado específicamente para superar las limitaciones de protocolos más antiguos como SLIP (Serial Line Internet Protocol), proporcionando un marco robusto y flexible para comunicaciones punto a punto. Aunque su uso ha disminuido con la proliferación de tecnologías de banda ancha, PPP sigue siendo relevante en conexiones de respaldo, enlaces satelitales, y ciertas implementaciones de VPN donde se requiere control granular sobre la conexión. PPP utiliza un formato de trama mucho más simple que Ethernet o Wi-Fi, reflejando su naturaleza punto a punto donde no hay necesidad de direccionamiento complejo, permitiendo un procesamiento eficiente en enlaces de baja velocidad y dispositivos con recursos limitados.\nLas características avanzadas de PPP lo distinguen de protocolos más simples al integrar detección y corrección de errores que garantizan la integridad de los datos transmitidos incluso en enlaces propensos a interferencia, capacidades de autenticación mediante PAP (Password Authentication Protocol) o el más seguro CHAP (Challenge Handshake Authentication Protocol), y configuración automática de direcciones IP que negocia dinámicamente parámetros de red eliminando la necesidad de configuración manual en ambos extremos.\n\n\nFrame Relay\nFrame Relay es un protocolo de capa de enlace utilizado en redes WAN que proporciona conexiones virtuales entre sitios remotos. Frame Relay fue desarrollado como una evolución más eficiente de X.25, eliminando muchas de las verificaciones y controles redundantes que hacían lento al protocolo anterior. Aunque ha sido en gran medida reemplazado por tecnologías más modernas como MPLS y VPN sobre Internet, Frame Relay estableció conceptos fundamentales de redes WAN que siguen siendo relevantes en tecnologías contemporáneas.\nLa arquitectura de Frame Relay se basa en conmutación de tramas utilizando identificadores de circuito virtual que permiten múltiples conexiones lógicas sobre una sola interfaz física, simplificando la gestión de conectividad entre múltiples sitios remotos. El protocolo implementa un control de congestión sofisticado.\n\n\nAddress Resolution Protocol (ARP)\nARP es fundamental para la operación de redes IP sobre Ethernet, proporcionando la traducción entre direcciones IP (Capa de Red) y direcciones MAC (Capa de Acceso a la Red). Este protocolo resuelve uno de los problemas más básicos pero críticos en redes: cómo traducir direcciones lógicas que los humanos y aplicaciones entienden fácilmente a direcciones físicas que el hardware de red requiere para la transmisión real.\nEl proceso ARP opera mediante un mecanismo de solicitud y respuesta que minimiza el tráfico de red mientras proporciona la información necesaria. Cuando un dispositivo necesita comunicarse con otro pero solo conoce su dirección IP, envía un ARP Request como broadcast preguntando “¿Quién tiene la IP X.X.X.X?” a todos los dispositivos del segmento local. El dispositivo que posee esa dirección IP específica responde con un ARP Reply unicast que incluye su dirección MAC, permitiendo al solicitante establecer la asociación necesaria. Para optimizar el rendimiento, estas asociaciones IP-MAC se almacenan en una caché ARP local con temporizadores que eliminan automáticamente entradas obsoletas, evitando repetir el proceso de resolución para comunicaciones frecuentes.\nARP soporta múltiples modalidades de operación que se adaptan a diferentes necesidades de red y escenarios operativos. ARP Estático permite crear entradas manuales permanentes que nunca expiran, útil para dispositivos críticos como gateways y servidores donde se requiere máxima predictibilidad. ARP Dinámico constituye el modo normal de operación donde las entradas se aprenden automáticamente con tiempo de vida configurable, balanceando eficiencia con actualización automática cuando los dispositivos cambian.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Capa de Acceso a la Red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_layer/network_layer.html",
    "href": "ch/part_networks/network_layer/network_layer.html",
    "title": "4  Capa de red",
    "section": "",
    "text": "4.1 Funciones Fundamentales de la Capa de Red\nLa capa de red es el segundo nivel del modelo de capas TCP/IP y forma el núcleo del sistema de comunicaciones de Internet. Su principal función es proporcionar una comunicación end-to-end entre dispositivos, potencialmente separados por múltiples redes intermedias, independientemente de la tecnología de subyacente. Es decir, la comunicación funciona de igual forma si estamos conectados a través de WiFi, Ethernet o 5G, a pesar de que sean diferentes medios. Esta clara delimitación de capas permite combinar de forma más sencilla diferentes tecnologías y dispositivo hardware.\nComo es habitual, vamos a ver un ejemplo simplificado donde un dispositivo quiere mandarle un mensaje a otro dispositivo que no está en la misma red. Este ejemplo simula una situación real como acceder desde casa a un servidor web de Google. Habrá conceptos que no os suenen pero los veremos a lo largo del capítulo. El dispositivo A (tu ordenador en casa), con IP (192.168.1.10) quiere enviarle un mensaje al dispositivo B (servidor web de Google), con IP (142.250.184.3). Durante el ejemplo vamos a realizar una simplificación y utilizaremos siempre la IP del emisor como 192.168.1.10, pero esto no es válido como veremos posteriormente ya que se trata de una IP privada y el Router-A utilizaría NAT. La estructura de la red es la siguiente:\nLos pasos de los que constaría este ejemplo simplificado están recogidos en la Figura 4.2 y serían los siguientes:\nAunque este ejemplo sea una simplificación, nos ayuda a introducir la funcionalidad de la capa de red, en concreto, de los routers y del protocolo IP. Generalmente, entre el Router-A y Router-B habría múltiples routers intermedios, pero proceso seguiría siendo el mismo. En los siguientes apartados profundizaremos en las funcionalidades de la capa de red a través de los routers y el protocolo IP.\nLa Capa de Red tiene dos funciones clave: el enrutamiento y el reenvío. El enrutamiento representa el proceso global mediante el cual la red determina las rutas óptimas que seguirán los paquetes de datos desde su origen hasta su destino final. Este proceso considera toda la topología de la red y puede tomar desde segundos hasta minutos para converger completamente. Los algoritmos de enrutamiento más comunes son RIP, OSPF y BGP.\nEn contraste, el reenvío constituye un proceso local y extremadamente rápido que se encarga de mover los paquetes desde el puerto de entrada hasta el puerto de salida específico dentro del mismo router. Esta operación debe completarse en microsegundos para mantener el rendimiento de la red, por lo que se implementa directamente en hardware. El proceso se basa exclusivamente en la dirección IP de destino y utiliza únicamente la tabla de reenvío local del router para tomar decisiones inmediatas.\nLa interacción entre ambos procesos forma un sistema integrado donde los algoritmos de enrutamiento como RIP, OSPF y BGP generan la tabla de enrutamiento con rutas completas, la cual se traduce en una tabla de reenvío optimizada que contiene únicamente la información del siguiente salto (next-hop). Esta tabla de reenvío es la que finalmente permite tomar las decisiones de reenvío paquete por paquete de manera eficiente, creando un flujo continuo desde la planificación estratégica de rutas hasta la ejecución táctica del movimiento de datos.\nLas responsabilidades de la capa de red varían según el tipo de dispositivo y su posición en el flujo de comunicación. En el host emisor, la capa de red recibe segmentos de TCP o UDP y los encapsula en datagramas IP añadiendo las cabeceras correspondientes. Durante este proceso, debe fragmentar los datagramas si exceden el MTU del enlace de salida y determinar si el destino es local (dentro de la misma red) o remoto para enviarlo. En el extremo opuesto, el host receptor debe reensamblar los fragmentos cuando sea necesario, verificar la integridad de los datos mediante el checksum de cabecera, extraer los segmentos y entregarlos a la capa de transporte apropiada, además de procesar las opciones de cabecera IP cuando estén presentes.\nLos routers intermedios desempeñan un papel diferente pero crucial en este ecosistema. Su función principal consiste en examinar los campos de la cabecera IP, especialmente la dirección de destino, consultar sus tablas de enrutamiento para determinar el siguiente salto apropiado, y reenviar los paquetes por la interfaz de salida correspondiente.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Capa de red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_layer/network_layer.html#modelos-de-servicio",
    "href": "ch/part_networks/network_layer/network_layer.html#modelos-de-servicio",
    "title": "4  Capa de red",
    "section": "4.2 Modelos de servicio",
    "text": "4.2 Modelos de servicio\nExisten dos paradigmas fundamentales para implementar servicios de capa de red, cada uno con filosofías y mecanismos completamente diferentes. La elección entre estos modelos determina aspectos cruciales como performance, confiabilidad, complejidad y escalabilidad de la red.\nLas redes de circuitos virtuales (VC) emulan el comportamiento de los circuitos telefónicos tradicionales estableciendo “caminos virtuales” dedicados entre origen y destino. Su funcionamiento se desarrolla en tres fases claramente definidas: primero, el establecimiento de conexión mediante el envío de un mensaje SETUP desde el host origen, donde cada router intermedio reserva recursos como ancho de banda y buffers, crea una entrada en su tabla VC con un identificador único local, y reenvía la solicitud hasta que el host destino confirma con un mensaje ACK. Durante la fase de transferencia de datos, los paquetes solo necesitan llevar el VC ID asignado en lugar de la dirección de destino completa, permitiendo un reenvío rápido mediante consulta a la tabla VC, garantizando calidad de servicio (QoS) y manteniendo una ruta fija para todos los paquetes del flujo. Finalmente, la terminación se realiza mediante un mensaje TEARDOWN que libera los recursos previamente reservados y elimina las entradas de las tablas VC.\nEsta arquitectura ofrece ventajas significativas como QoS predecible con garantías de rendimiento, overhead reducido en las cabeceras al usar solo el VC ID, control de flujo extremo a extremo y orden garantizado de los paquetes. Sin embargo, presenta desventajas importantes incluyendo la complejidad en el establecimiento y mantenimiento de conexiones, la necesidad de mantener estado por cada conexión en todos los routers, rigidez ante cambios en la topología de red y overhead adicional por la señalización requerida. Tecnologías como ATM, Frame Relay, X.25 y MPLS implementan este modelo de circuitos virtuales para aplicaciones que requieren garantías específicas de rendimiento.\nLas redes de datagramas adoptan un enfoque completamente diferente al tratar cada paquete de manera independiente sin establecer conexiones previas entre origen y destino. Este modelo se caracteriza por la ausencia de estado de conexión en los routers, eliminando la necesidad de un proceso de setup inicial, y basa el reenvío en la dirección de destino completa contenida en cada paquete. Cada router procesa los paquetes independientemente. Como resultado, diferentes paquetes del mismo flujo puedan seguir rutas distintas a través de la red.\nEl modelo de datagramas presenta ventajas sustanciales en términos de simplicidad de diseño e implementación, robustez excepcional ante fallos de red ya que no depende de estados de conexión preestablecidos, flexibilidad para implementar balanceo dinámico de carga, escalabilidad superior al no requerir mantener estado por cada flujo, y adaptabilidad inmediata a cambios en la topología de red. Estas características hacen que las redes de datagramas sean especialmente adecuadas para entornos dinámicos y de gran escala como Internet.\nNo obstante, el modelo de datagramas también presenta limitaciones significativas que incluyen la ausencia de garantías de calidad de servicio (QoS), la posibilidad de que los paquetes lleguen fuera de orden al destino debido a las diferentes rutas que pueden tomar, el overhead adicional generado por incluir la dirección de destino completa en cada paquete, y la prestación únicamente de un servicio de mejor esfuerzo (best-effort) sin compromisos específicos de rendimiento. A pesar de estas limitaciones, el modelo de datagramas se ha convertido en el fundamento de Internet debido a su simplicidad, robustez y capacidad de adaptación a las condiciones cambiantes de la red.\nResumen comparativo:\n\n\n\nAspecto\nCircuitos Virtuales\nDatagramas\n\n\n\n\nEstablecimiento\nRequerido\nNo requerido\n\n\nEstado en routers\nSí, por conexión\nNo\n\n\nDireccionamiento\nVC ID\nDirección IP completa\n\n\nEnrutamiento\nRuta fija\nRuta por paquete\n\n\nQoS\nGarantías posibles\nBest effort\n\n\nRecuperación fallos\nDifícil\nAutomática\n\n\nEscalabilidad\nLimitada\nAlta\n\n\nOverhead\nSetup/teardown\nPor paquete",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Capa de red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_layer/network_layer.html#dispositivos-físicos-de-la-capa-de-red",
    "href": "ch/part_networks/network_layer/network_layer.html#dispositivos-físicos-de-la-capa-de-red",
    "title": "4  Capa de red",
    "section": "4.3 Dispositivos físicos de la Capa de Red",
    "text": "4.3 Dispositivos físicos de la Capa de Red\nLos dispositivos de capa de red son los componentes hardware que hacen posible la interconexión de redes y la implementación de las funciones de enrutamiento y reenvío. Estos dispositivos varían considerablemente en complejidad, desde simples switches Layer 3 hasta routers core de alta capacidad.\n\nRouters (Enrutadores)\nLos routers constituyen la columna vertebral de Internet y las redes empresariales modernas. Su función principal es interconectar diferentes redes y determinar la ruta óptima para el reenvío de paquetes de datos. A diferencia de los switches que operan en la Capa de Acceso a la Red, los routers trabajan en la Capa de Red, tomando decisiones basadas en direcciones IP y manteniendo una visión global de la topología de red.\nLa arquitectura básica consta de cuatro componentes principales:\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│                 │    │                 │    │                 │\n│  Puertos de     │    │   Procesador    │    │  Puertos de     │\n│   Entrada       │◄──►│      de         │◄──►│   Salida        │\n│                 │    │  Enrutamiento   │    │                 │\n└─────────────────┘    └─────────────────┘    └─────────────────┘\n         ▲                        │                        ▲\n         │              ┌─────────▼─────────┐              │\n         │              │                   │              │\n         └──────────────│ Fabric de         │──────────────┘\n                        │ Conmutación       │\n                        │                   │\n                        └───────────────────┘\nEn los routers diferenciamos dos planos claramente separados:\n\nplano de control: ejecuta el proceso de enrutamiento mediante software especializado y generan tablas de enrutamiento que contienen rutas completas hacia todos los destinos conocidos.\nplano de datos: ejecuta el proceso de reenvio mediante hardware especializado para máxima eficiencia. Utiliza la tabla de enrutamiento generado en el plano de control.\n\nLos puertos de entrada constituyen las puertas de recepción del router y realizan tres funciones críticas organizadas en secuencia. La terminación física proporciona la interfaz con medios de transmisión como cables de cobre o fibra óptica, convirtiendo las señales eléctricas u ópticas en datos digitales. El procesamiento de la capa de enlace maneja protocolos específicos como Ethernet, PPP o Frame Relay, extrayendo el datagrama IP de la trama correspondiente. La función de búsqueda IP consulta la tabla de reenvío usando el algoritmo de coincidencia de prefijo más largo para determinar hacia dónde dirigir cada paquete. Esta función debe ejecutarse a la velocidad del enlace para evitar crear cuellos de botella en el sistema.\nLos puertos de salida gestionan el tráfico que abandona el router mediante un proceso inverso al de entrada. La bufferización y scheduling implementa sistemas de colas sofisticados que aplican políticas de calidad de servicio, decidiendo qué paquetes enviar primero según sus prioridades. El procesamiento de la capa de enlace encapsula el datagrama IP en la trama apropiada para el protocolo del enlace de salida. Finalmente, la terminación física convierte los datos digitales en señales eléctricas u ópticas para su transmisión.\nEl procesador de enrutamiento funciona como el cerebro del sistema, ejecutando los protocolos de enrutamiento que intercambian información con otros routers para mantener actualizado el conocimiento de la topología de red. También gestiona funciones administrativas como SNMP para monitoreo remoto, procesamiento ICMP para herramientas de diagnóstico como ping y traceroute, y la computación de las tablas de reenvío optimizadas a partir de las tablas de enrutamiento.\nPor último, NAT es un protocolo que opera entre ambas capas (lo veremos después). Al principio operaba sólo en el plano de control, tomando un tiempo significativo. En la actualidad, opera en el plano de control para manejar las sesiones y el resto en hardware especializado en el plano de datos.\n\nProceso de Reenvío de Paquetes\nEl proceso de reenvío sigue una secuencia precisa y optimizada que se ejecuta para cada paquete:\n\nRecepción y procesamiento inicial: El paquete llega al puerto de entrada desde el enlace físico, se procesa la cabecera de la capa de enlace correspondiente y se extrae el datagrama IP.\nVerificación de integridad: Se verifica el checksum de la cabecera IP para detectar posibles errores de transmisión y se comprueba que el valor TTL sea mayor que cero.\nExtracción de información de destino: Se extrae la dirección IP de destino de la cabecera del datagrama para utilizarla en la decisión de reenvío.\nConsulta de tabla de reenvío: Se aplica el algoritmo de coincidencia de prefijo más largo en la tabla de reenvío para determinar la interfaz de salida apropiada y obtener la dirección del siguiente salto.\nModificación del paquete: Se decrementa el campo TTL en una unidad y se recalcula el checksum de la cabecera IP para mantener la integridad de los datos. Si el TTL llega a cero después del decremento, el router descarta el paquete y envía un mensaje ICMP “Time Exceeded” al host origen, evitando así loops infinitos en la red.\nResolución de direcciones: Si es necesario, se resuelve la dirección MAC del dispositivo del siguiente salto mediante el protocolo ARP.\nEncapsulación y envío: Se encapsula el datagrama IP en una nueva trama según el protocolo de la capa de enlace del puerto de salida y se transmite por la interfaz física correspondiente.\n\n\n\n\nSwitches de Capa 3\nA medida que las redes locales crecieron en complejidad, surgió la necesidad de dispositivos que combinaran la velocidad del switching con las capacidades del routing. Los switches Layer 3 llenan este nicho específico. La principal diferencia es la implementación a nivel de hardware del procesamiento, haciéndolo mucho más rápido. A modo de comparativa tenéis la siguiente tabla:\n\n\n\nAspecto\nRouter Tradicional\nSwitch L3\n\n\n\n\nReenvío\nSoftware/ASIC\nHardware puro\n\n\nLatencia\nMicrosegundos\nNanosegundos\n\n\nThroughput\nLimitado por CPU\nWire-speed\n\n\nCosto\nMayor\nMenor\n\n\nFlexibilidad\nAlta\nLimitada",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Capa de red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_layer/network_layer.html#protocolos",
    "href": "ch/part_networks/network_layer/network_layer.html#protocolos",
    "title": "4  Capa de red",
    "section": "4.4 Protocolos",
    "text": "4.4 Protocolos\n\nProtocolo IP\nIP es el protocolo principal de la capa de red en la arquitectura TCP/IP. Define la estructura de datagramas, direccionamiento y mecanismos básicos de entrega. Las características principales de IP son:\n\nSin conexión: No requiere establecimiento previo.\nNo confiable: No garantiza entrega, orden, o integridad.\nBest effort: Hace el “mejor esfuerzo” por entregar paquetes.\nIndependiente del medio: Funciona sobre cualquier tecnología de enlace.\n\nDentro de IP hay dos versiones. IPv4 diseñado en los años 70 y IPv6, como evolución de IPv4 enfocado a solventar las limitaciones de IPv4, en especial el número de IPs disponibles. Empezaremos por IPv4.\n\n\n\n\n\n\nFigura 4.3: Formato de cabeceras de IPv4.\n\n\n\nEl datagrama IPv4 es la unidad básica de información que viaja por Internet (Ver estructura en Figura 4.3). Utiliza una cabecera de longitud variable (mínimo 20 bytes) que contiene la información esencial para el enrutamiento y entrega de paquetes a través de Internet. Los campos más críticos incluyen las direcciones IP de origen y destino que determinan los puntos de comunicación, el campo TTL que previene loops infinitos al decrementarse en cada router, el campo Protocol que identifica el protocolo de capa superior (TCP, UDP, ICMP), y los campos de fragmentación (Identification, Flags, Fragment Offset) que permiten dividir y reensamblar datagramas que exceden el MTU del enlace. El checksum protege únicamente la cabecera, delegando la protección de los datos a las capas superiores, mientras que el campo Total Length especifica el tamaño completo del datagrama para su procesamiento correcto.\nEl sistema de direccionamiento IPv4, llamadas IP, es un identificador único de un dispositivo dentro de una red. En IPv4 tienen un formato de 32 bits que se organiza en 4 octetos separados por puntos. Por ejemplo, 192.168.1.1 o 10.0.1.50. Debido a la longitud de 32 bits, el número de direcciones IP posibles son \\(2^{32}\\), aproximadamente 4.3 miles de millones. Estas direcciones se organizan en dos partes, la parte de red y la parte de host, además tenemos la máscara de red que nos ayuda a distinguir ambas partes. Por ejemplo, 192.168.1.1 con máscara de red 255.255.255.0 o 10.0.1.50 con máscara de red 255.255.0.0, siendo la parte azul la parte de red y la roja la parte del host. Para obtener la dirección de red utilizamos el operador binario AND: 192.168.1.1 & 255.255.255.0 = 192.168.1.0. En CIDR, que veremos más adelante, esta máscara 255.255.255.0 se representa como /24.\nEsta división entre parte de red y parte de host permite representar jerárquicamente la estructura de direccionamiento, como se muestra en la Figura 4.4. Los routers pueden tomar decisiones de reenvío basándose únicamente en la parte de red de la dirección destino, consultando sus tablas locales para determinar la interfaz de salida. Gracias a esta organización, es posible la agregación de rutas, donde varias redes pequeñas se resumen en una sola entrada de mayor alcance. Por ejemplo, dos subredes /28 contiguas (192.168.1.0/28 y 192.168.1.16/28) pueden representarse como un único bloque /27 (192.168.1.0/27), reduciendo de dos entradas a una. Este mecanismo permite que los routers mantengan información consolidada sobre redes remotas sin necesidad de conocer cada host o subred en detalle, lo que disminuye drásticamente el tamaño de las tablas de reenvío y hace escalable la infraestructura global de Internet.\n\n\n\n\n\n\nFigura 4.4: Ejemplo de estructuras de subredes.\n\n\n\nLa estructura de direccionamiento IPv4, que permite distinguir entre red y host para generar una arquitectura jerárquica de redes, inicialmente utilizaba un sistema de clases. En este sistema de clases, las direcciones IPv4 se categorizaban en tres grupos principales según los bits iniciales del primer octeto, determinando la división entre bits de red y host. La Clase A comenzaba con bit 0, la Clase B con bits “10”, y la Clase C con bits “110”, creando saltos enormes entre las capacidades de cada categoría que generaban ineficiencias significativas en la asignación. La estructura de direccionamiento IPv4, que permite distinguir entre red y host para generar una arquitectura jerárquica de redes, inicialmente utilizaba un sistema de clases. En este sistema de clases, las direcciones IPv4 se categorizaban en tres grupos principales según los bits iniciales del primer octeto, determinando la división entre bits de red y host. La Clase A comenzaba con bit 0, la Clase B con bits “10”, y la Clase C con bits “110”, creando saltos enormes entre las capacidades de cada categoría que generaban ineficiencias significativas en la asignación.\n\n\n\n\n\n\n\n\n\n\n\n\n\nClase\nRango de Direcciones\nPrimer Bit(s)\nBits de Red\nBits de Host\nRedes Disponibles\nHosts por Red\nUso Típico\n\n\n\n\nA\n0.0.0.0 - 127.255.255.255\n0\n7\n24\n1261\n16,777,214\nISPs, gobiernos, organizaciones masivas\n\n\nB\n128.0.0.0 - 191.255.255.255\n10\n14\n16\n16,384\n65,534\nUniversidades, empresas medianas\n\n\nC\n192.0.0.0 - 223.255.255.255\n110\n21\n8\n2,097,152\n254\nEmpresas pequeñas, oficinas locales\n\n\n\nSin embargo, la rigidez del sistema de clases generaba problemas críticos. Una organización con 1,000 hosts enfrentaba un dilema: elegir una red Clase B desperdiciando 64,534 direcciones (99.5% de ineficiencia) o gestionar múltiples redes Clase C con mayor complejidad administrativa. Esta inflexibilidad aceleró el agotamiento del espacio IPv4 y motivó el desarrollo de alternativas más eficientes.\nPara solventar este problema se introdujo CIDR. La innovación fundamental consistió en la notación /x que indica exactamente cuántos bits destinan a la parte de red. Por ejemplo, 192.168.1.0/24 significa que los primeros 24 bits identifican la red, dejando 8 bits para hosts (254 hosts utilizables). CIDR permite asignar direcciones en bloques de cualquier tamaño potencia de 2, eliminando el desperdicio masivo del sistema anterior. Una organización que necesite 500 hosts puede recibir un /23 (510 hosts) en lugar de desperdiciar una Clase B completa. Esta flexibilidad aumentó la utilización del espacio IPv4 del 20-30% tradicional al 95-98% actual y la simplificación de las tablas de enrutamiento globales mediante la agregación de rutas.\nPara funcionar, CIDR requiere el algoritmo de longest prefix matching para búsquedas en tablas de enrutamiento. Cuando un router recibe un paquete, evalúa todas las rutas que coinciden con la dirección destino y selecciona aquella con el prefijo más específico. En una tabla con rutas 192.168.0.0/16, 192.168.1.0/24 y 192.168.1.128/25, el destino 192.168.1.200 coincide con las dos primeras pero selecciona 192.168.1.0/24 por tener el prefijo más largo (24 bits vs 16 bits). Este mecanismo garantiza que el tráfico tome siempre la ruta más específica disponible.\nIndependientemente del sistema de direccionamiento utilizado (clases o CIDR), IPv4 mantiene direcciones especiales con propósitos específicos:\n\n0.0.0.0/32: This host on this network. Referencia un host sin IP configurada. Se utiliza en el proceso de configuración (DHCP).\n127.0.0.0/8: Loopback. Los paquetes no salen del host local y se utiliza para servicios y pruebas. Un ejemplo común es localhost, con IP 127.0.0.1.\n255.255.255.255/32: Limited broadcast. Broadcast a todos los hosts en red local. No atraviesa routers.\nx.x.x.0: Dirección de red. Todos los bits del host a 0 (con la máscara de red). Identifica a la red misma.\nx.x.x.255: Directed broadcast. Todos los bits de host a 1. Broadcast dirigido a una red específica.\n\nEn el sistema de clases, las direcciones de red y broadcast seguían patrones fijos según la clase, pero con CIDR se adaptan dinámicamente a la máscara de subred específica utilizada.\nAmbos sistemas establecen una serie de rangos, determinadas privadas, que son exclusivas para redes internas. Estas direcciones no son enrutables en Internet público, ya que los routers globales están configurados para descartarlas, evitando conflictos de direccionamiento. La principal ventaja radica en que múltiples organizaciones pueden reutilizar los mismos rangos internamente sin interferir entre sí, conservando el escaso espacio IPv4 público. Para acceder a Internet, estas redes requieren NAT, que traduce direcciones privadas a públicas. Los rangos delimitados son: 10.0.0.0/8 (16.7 millones de hosts, para grandes organizaciones), 172.16.0.0/12 (1 millón de hosts, para empresas medianas) y 192.168.0.0/16 (65,000 hosts, para hogares y oficinas pequeñas).\nPor último, en el protocolo IP hay una tamaño máximo para el datagrama. Este tamaño se conoce como MTU (del inglés, Maximum Transmission Unit), y puede variar dependiendo de la tecnología subyacente, por ejemplo, en Ethernet es 1500 bytes y en Token Ring es 4464 bytes. Cuando el tamaño del datagrama es superior al MTU, el datagrama se fragmenta en trozos más pequeños y se desfragmentará posteriormente en el destino. Una consideración importante es que el protocolo IP sí mantiene el orden de la información del datagrama. Es decir, si yo envío un datagrama que se tiene que fragmentar, IP garantiza que al desfragmentarlo la integridad de los datos estará preservada. Cuando decimos que no garantiza el orden es que si primero envío el datagrama A y después otro datagrama B (independientes), puede que la aplicación reciba primero el datagrama B y después el A, y no tendré forma de saber si uno va antes que el otro.\n\nIPv6\nIPv6 surge como respuesta a las limitaciones críticas de IPv4, principalmente el agotamiento de su espacio de direcciones de 32 bits que solo proporciona 4.3 × 10^{9} direcciones únicas. Además, IPv4 presenta problemas de fragmentación ineficiente que requiere procesamiento en routers intermedios, configuración manual compleja sin capacidades de autoconfiguración, implementación de seguridad como complemento opcional (IPSec), y limitaciones en calidad de servicio con campos TOS poco efectivos. Estos desafíos hacen insostenible IPv4 para el crecimiento exponencial de dispositivos conectados a Internet.\nIPv6 revoluciona el protocolo con un espacio de direcciones masivo de 128 bits que proporciona 2^{128} = 3.4 × 10^{38} direcciones, utilizando notación hexadecimal con reglas de compresión para simplificar su representación. La cabecera, ver Figura 4.5, se simplifica a un formato fijo de 40 bytes eliminando el checksum para reducir el procesamiento en routers, e integra características avanzadas como autoconfiguración SLAAC, seguridad IPSec obligatoria, y mejor calidad de servicio mediante campos Traffic Class y Flow Label. Debido a la cantidad de dispositivos en la red, la migración de IPv4 a IPv6 se realiza de forma gradual mediante estrategias que permiten la interoperabilidad entre ambos protocolos.\n\n\n\n\n\n\nFigura 4.5: Formato de cabeceras de IPv6.\n\n\n\n\n\n\nProtocolo ICMP (Internet Control Message Protocol)\nICMP es un protocolo complementario a IP que proporciona mecanismos de control, diagnóstico y reporte de errores en redes. Utiliza IP para su transporte (protocolo número 1) pero opera como herramienta de gestión de red. Es no orientado a conexión, no garantiza entrega, y está implementado obligatoriamente en todos los dispositivos IP. Su formato básico incluye campos Type, Code, Checksum y datos adicionales según el tipo de mensaje.\nLos mensajes ICMP se clasifican en dos categorías principales: mensajes de error y mensajes de consulta. Los mensajes de error incluyen “Destination Unreachable” (Type 3) que indica problemas de alcance como red, host o puerto inaccesible; “Time Exceeded” (Type 11) usado cuando el TTL expira en tránsito; “Parameter Problem” (Type 12) para errores de configuración; o “Packet Too Big” en el mecanismo de MTU Discovery de IPv6. Los mensajes de consulta incluyen “Echo Request/Reply” (Type 8/0) utilizados por ping para verificar conectividad y medir latencia, y “Timestamp Request/Reply” (Type 13/14) para sincronización temporal.\nPing - Verificación de conectividad:\n$ ping 8.8.8.8\nPING 8.8.8.8 (8.8.8.8): 56 data bytes\n64 bytes from 8.8.8.8: icmp_seq=0 ttl=55 time=15.1 ms\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=55 time=14.9 ms\nEste ejemplo muestra ping enviando Echo Request (Type 8) al servidor DNS de Google y recibiendo Echo Reply (Type 0) exitosamente. Las respuestas muestran latencias de ~15ms, TTL=55, y confirman conectividad funcional.\nTraceroute - Descubrimiento de ruta:\n$ traceroute google.com\n 1  192.168.1.1 (192.168.1.1)  3.414 ms  3.863 ms  1.752 ms\n 2  100.70.0.1 (100.70.0.1)  5.245 ms  4.996 ms  4.405 ms\n 3  10.14.0.53 (10.14.0.53)  7.091 ms  4.812 ms  4.892 ms\n 4  10.14.246.6 (10.14.246.6)  4.209 ms  4.406 ms  4.230 ms\n 5  * * *\n 6  72.14.195.182 (72.14.195.182)  4.665 ms\n    72.14.194.132 (72.14.194.132)  3.950 ms\n    72.14.195.182 (72.14.195.182)  4.968 ms\n 7  74.125.245.171 (74.125.245.171)  5.109 ms  5.751 ms  5.791 ms\n 8  142.251.49.55 (142.251.49.55)  4.185 ms\n    142.251.49.53 (142.251.49.53)  5.317 ms\n    142.251.49.55 (142.251.49.55)  3.791 ms\n 9  mad41s11-in-f14.1e100.net (142.250.185.14)  4.722 ms  6.253 ms  4.893 ms\nEste ejemplo revela la ruta completa hacia google.com incrementando TTL progresivamente. Cada router responde “Time Exceeded” (Type 11, Code 0) mostrando su IP. El salto 5 muestra timeouts (*), el salto 6 y 8 muestra balanceadores de carga, y finalmente alcanza el servidor de Google en el salto 9.\n\n\nNAT (Network Address Translation)\nNAT surgió como una solución al problema del agotamiento de direcciones IPv4, permitiendo que múltiples dispositivos en una red privada compartan una sola dirección IP pública. Esta técnica se basa en el uso de direcciones privadas que pueden reutilizarse sin conflictos. El dispositivo NAT, típicamente integrado en routers de acceso doméstico o empresarial, actúa como intermediario entre la red interna y externa, traduciendo direcciones y puertos en tiempo real.\nEl funcionamiento de NAT se basa en mantener una tabla de traducción que mapea combinaciones de dirección IP privada y puerto interno con la dirección IP pública y un puerto externo único. Cuando un dispositivo interno inicia una conexión hacia Internet, el router NAT reemplaza la dirección IP de origen privada y el puerto por su dirección IP pública y un puerto disponible de su pool, registrando esta asociación en su tabla. Cuando llega la respuesta desde Internet, el router consulta su tabla de traducción para determinar a qué dispositivo interno debe entregar el paquete, revirtiendo la traducción antes de reenviarlo a la red local.\nEn la Figura 4.6 podemos ver dos ejemplos de NAT. El Host A envía un paquete desde 192.168.1.10:12345 hacia 8.8.8.8:80. El router NAT lo intercepta, reemplaza el origen por 203.0.113.100:5001 y crea una entrada en su tabla: 192.168.1.10:12345 ↔︎ 5001. Cuando el servidor responde a 203.0.113.100:5001, el router consulta su tabla NAT, encuentra la correspondencia y reenvía el paquete a 192.168.1.10:12345. El proceso en el Host B sería idéntico, y gracias a NAT habríamos podido comunicarnos con dos dispositivos a través de una única IP.\n\n\n\nRed Interna (192.168.1.0/24)          NAT Router          Internet\n                                    (203.0.113.100)\n                                                           \n┌─────────────┐                    ┌─────────────┐     ┌─────────────┐\n│Host A       │ ────────────────── │             │ ─── │Servidor Web │\n│192.168.1.10 │ Src: 192.168.1.10  │             │     │8.8.8.8:80   │\n│Port: 12345  │ Dst: 8.8.8.8:80    │   Tabla     │     └─────────────┘\n└─────────────┘                    │     NAT     │            ▲\n                                   │             │            │\n┌─────────────┐                    │192.168.1.10:│ Src: 203.0.113.100\n│Host B       │ ────────────────── │12345 → 5001 │ Dst: 8.8.8.8:80\n│192.168.1.20 │ Src: 192.168.1.20  │             │            │\n│Port: 54321  │ Dst: 8.8.8.8:80    │192.168.1.20:│            │\n└─────────────┘                    │54321 → 5002 │◄───────────┘\n                                   └─────────────┘\n\n                Traducción Salida              Traducción Entrada\n    192.168.1.10:12345 → 203.0.113.100:5001    203.0.113.100:5001 → 192.168.1.10:12345\n    192.168.1.20:54321 → 203.0.113.100:5002    203.0.113.100:5002 → 192.168.1.20:54321\n\n\nFigura 4.6: Ejemplo de NAT con dos Host que se comunican con un servidor web utilizándo una única IP pública.\n\n\n\nSin embargo, NAT presenta limitaciones significativas como la imposibilidad de establecer conexiones entrantes sin configuración manual de port forwarding, complicaciones con aplicaciones que embeben direcciones IP en sus datos (como algunos protocolos VoIP), y la pérdida del principio end-to-end de Internet. A pesar de estas limitaciones, NAT se ha convertido en ubicuo en redes domésticas y empresariales, siendo una pieza fundamental que ha permitido que Internet continúe funcionando mientras se desarrolla la transición hacia IPv6.\nLa limitación de conexiones entrantes impide que otros dispositivos sean capaces de conectarse a nosotros directamente. Esto impide, por ejemplo, que dos personas puedan conectarse entre sí desde sus casas. Por otra parte, también hace más seguro estar conectado a la red. En determinados casos, conectarse entre sí puede mejorar la experiencia, mejorar la privacidad, o reducir la necesidad de servidores intermedios y sus consecuentes recursos. Para ello, se pueden utilizar diferentes técnicas que permiten saltarse las limitaciones del NAT:\n\nHole punching: Técnica donde ambos dispositivos intentan conectarse simultáneamente al otro a través de sus respectivos NATs. El NAT crea temporalmente “agujeros” en su tabla de traducción cuando detecta tráfico saliente, permitiendo que la respuesta del otro extremo pase. Funciona peor (es más difícil) con NAT simétrico y requiere coordinación temporal precisa.\nSTUN (Session Traversal Utilities for NAT): Protocolo que permite a un dispositivo descubrir su dirección IP pública y el tipo de NAT que tiene. Un servidor STUN externo ayuda al cliente a determinar cómo el NAT modifica sus paquetes, información crucial para establecer conexiones directas. Es especialmente útil para aplicaciones de tiempo real como VoIP.\nTURN (Traversal Using Relays around NAT): Cuando el hole punching falla, TURN proporciona un servidor relay que actúa como intermediario. Aunque no elimina completamente la necesidad de servidores, centraliza el tráfico en un punto controlado. Es más confiable pero consume más ancho de banda y recursos del servidor.\nUPnP (Universal Plug and Play): Permite que las aplicaciones configuren automáticamente el router para abrir puertos específicos. El dispositivo solicita al router que cree reglas de port forwarding temporales o permanentes. Es conveniente pero requiere que el router soporte UPnP y puede presentar riesgos de seguridad si no se gestiona adecuadamente.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Capa de red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/network_layer/network_layer.html#footnotes",
    "href": "ch/part_networks/network_layer/network_layer.html#footnotes",
    "title": "4  Capa de red",
    "section": "",
    "text": "Las direcciones 0.0.0.0/8 y 127.0.0.0/8 están reservadas para funciones especiales.↩︎",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Capa de red</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/transport_layer/transport_layer.html",
    "href": "ch/part_networks/transport_layer/transport_layer.html",
    "title": "5  Capa de transporte",
    "section": "",
    "text": "5.1 Funciones principales\nLa capa de transporte proporciona comunicación lógica entre procesos de aplicación que se ejecutan en diferentes hosts. Los protocolos de transporte se ejecutan en los hosts finales, no en el núcleo de la red. Los protocolos más comunes son UDP y TCP, que representan los dos lados del espectro en cuanto a funcionalidades. UDP contiene lo mínimo para ser un protocolo de comunicación en la capa de transporte y TCP es un protocolo mucho más complejo pero con más garantías. La elección entre uno y otro dependerá del dominio y la aplicación.\nPrimero, vamos a ver un ejemplo simplificado donde un Cliente A le manda 5 paquetes a un Servidor B. Entre medias, asumimos que hay una red, Internet, donde no profundizaremos por simplicidad, pero sería como en el Capítulo 4. Podéis ver un ejemplo del escenario en Figura 5.1. En este escenario, un proceso Cliente A le envía 5 paquetes a un proceso del Servidor B. El Servicio B está referenciado a través de la IP (8.8.8.8), y dentro de B podemos identificar el proceso a través del puerto, en este caso, 80. El Cliente A envía un total de 5 paquetes, llegando al servidor, en el siguiente orden: 1, 2, 4, 3. Aquí pasan varias cosas. Lo primero, en paquete 5 no ha llegado, se “perdió” en Internet. Aproximadamente el 1% de los paquetes se pierden en condiciones normales. En UDP el paquete se perdería, y no nos enteraríamos. En TCP, el proceso se reintentaría. La segunda cosa que os puede llamar la atención es que el paquete 4 llega antes que el 3. Esto puede ocurrir también, ya que los paquetes pueden tomar diferentes caminos. En UDP no tenemos información para corregir el orden, así que se entregaría primero el 4 y después el 3. En cambio, TCP cuenta con mecanismos para corregir el orden.\nEn los siguientes apartados veremos las funcionalidades de la Capa de Transporte, y profundizaremos en los protocolos TCP y UDP, también veremos una pequeña comparativa de juegos utilizando TCP y UDP.\nLas funciones principales de la capa de transporte son dividir los mensajes en el emisor en segmentos y pasarlos a la capa de red, y posteriormente en el receptor recomponer los segmentos en mensajes y pasarlos a la capa de aplicación. La interfaz entre la capa de transporte y la capa de aplicación se llama sockets y la veremos en detalle en el capítulo de la Capa de Aplicación. Por ahora, sólo es necesario tener en cuenta que a través de los sockets podemos enviar y recibir información. Es la forma que tenemos que utilizar la Capa de Transporte desde la Capa de Aplicación.\nLos protocolos más comunes en la capa de transporte son TCP y UDP, que veremos a lo largo de este capítulo. Los dispositivos tienen generalmente en su kernel implementados estos protocolos y es un proceso del sistema. A través de los sockets nos podemos conectar a TCP o UDP. Este socket corre en un proceso, ya que en la Capa de Aplicación lo que se comunican son procesos entre sí. Para distinguir entre los diferentes sockets, se les otorga una identificación:\nLos puertos son identificadores numéricos desde 1 a 65535. Esta asignación puede ser manual o automática. Cuando creamos un socket en un servidor, la asignación generalmente es manual y siempre la misma, de tal forma que los procesos que se comunican lo pueden saber “de memoria”. Cuando abrimos un socket desde un cliente para conectarnos con un servidor, la asignación del puerto del cliente es aleatoria, ya que el puerto específico del cliente no es relevante.\nAhora que lo hemos visto de forma intuitiva vamos a definirlo un poco más formalmente. En la capa de transporte los protocolos tienen dos tareas comunes, la multiplexación y la demultiplexación. La multiplexación es el proceso por el cual recogemos información de diferentes sockets y lo enviamos por un único medio. Por el contrario, la demultiplexación es el proceso por el cual recibimos los segmentos por el medio único y lo enviamos a los sockets correspondientes. A modo de analogía se puede ver como un proceso de envío de cartas. La multiplexación sería el buzón de correos donde dejamos las cartas. La demultiplexación sería el personal de correos cogiendo las cartas y llevándolas a sus destinatarios. Posteriormente veremos alguna particularidad respecto a la multiplexación y demultiplexación entre TCP y UDP.\nOtro concepto interesante es la tranferencia fiable, que es básicamente aquella en la que la información llega tal cual se envió. Es decir, no se corrompe ningún bit, no se pierde información (paquetes) y la información se entrega en un orden correcto. Cuando queremos una transferencia fiable tenemos dos opciones, o bien utilizamos protocolos fiables que ya lo implementen nosotros, o implementamos nosotros esas características de tal forma que podamos tener una comunicación fiable sobre un medio no fiable.\nEn las siguientes secciones veremos los protocolos UDP y TCP con más detalle.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Capa de transporte</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/transport_layer/transport_layer.html#funciones-principales",
    "href": "ch/part_networks/transport_layer/transport_layer.html#funciones-principales",
    "title": "5  Capa de transporte",
    "section": "",
    "text": "En TCP los sockets se identifican por (IP origen, puerto origen, IP destino, puerto destino).\nEn UDP los sockets se identifican por (IP origen, puerto origen).",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Capa de transporte</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/transport_layer/transport_layer.html#protocolos",
    "href": "ch/part_networks/transport_layer/transport_layer.html#protocolos",
    "title": "5  Capa de transporte",
    "section": "5.2 Protocolos",
    "text": "5.2 Protocolos\n\nUDP (User Datagram protocol)\nUDP (User Datagram protocol) es un protocolo minimalista dentro de la familia de protocolos de la capa de transporte. Implementa el mínimo que debe hacer un protocolo de transporte [RFC 768]. UDP sacrifica las garantías de entrega por algo más valioso en ciertos escenarios: velocidad pura y simplicidad. Esto es especialmente útil en videojuegos interactivos, DNS o transmisión de vídeos. Las características principales de UDP son las siguientes:\n\nProtocolo ligero y simple: Es un protocolo basado en el principio best-effort. Esta aproximación significa que hace todo lo posible por entregar los datos al destinatario, pero no ofrece ninguna garantía sobre la entrega de los mismos, ni nos enteraremos sino se entregan debido a que se pierden o tienen errores.\nNo orientado a conexión: Cuando vamos a enviar información no es necesario establecer una conexión previa entre receptor y emisor. Podríamos decir que cada paquete que se envía es autosuficiente, tiene toda la información necesaria para representar el “estado” de la conexión. Si se pierde, no hay mecanismo para recuperarlo. Esta independencia tiene grandes consecuencias. Primero, simplifica la implementación. Segundo, se elimina la necesidad del proceso de handshake típico de los protocolos orientados a conexión, reduciendo tanto la latencia inicial como la complejidad del protocolo. Tercero, reduce considerablemente los recursos necesarios en el servidor, ya que este no tiene que mantener ningún estado.\nEntrega no fiable y sin orden: UDP no ofrece ninguna garantía de entrega sobre la información que se envía. Esta información puede perderse, puede duplicarse, o pueden llegar desordenados. A veces se denomina UDP como protocolo “fire-and-forget”, es decir, que envías el paquete y te olvidas de que ha existido, independientemente de que llegue o no.\nIntegridad básica: UDP tiene una comprobación de integridad a través de un checksum. Cuando el paquete llega a su receptor, UDP comprueba que el checksum es correcto, y en caso negativo, el paquete se descarta de forma silenciosa.\nMultiplexación y demultiplexación: La multiplexación y demultiplexación se realiza mediante el uso de números de puerto, que identifican de manera única los puntos finales de comunicación dentro de un host.\n\nRespecto a las características no proporcionadas, tenemos el control de flujo, control de congestión, temporización, tasa de transferencias mínima y seguridad. Para implementar control de flujo, control de congestión y temporización necesitaríamos tener un estado en cliente y servidor, así como enviar mensajes de control, lo cual entra en conflicto con el principio de best-effort y no ser orientado a conexión. La tasa de transferencia mínima no es posible siendo agnósticos del medio de transporte y requeriría de estado en los routers, lo cual va en contra de la estructura actual de Internet y dificultaría su escalabilidad. Por último, la seguridad, dependiendo del tipo de algoritmo, probablemente requiriría compartir información previamente de forma segura (claves de cifrado) o autoridades centrales como en el caso de HTTPS. En ambos casos, se complicaría el protocolo.\nLa simplicidad de UDP nos ofrece sin embargo, otra opción. Implementar nosotros mismos a nivel de capa de aplicación las garantías que consideremos necesarias y no pagar el “precio” por las que no vamos a utilizar. Por ejemplo, supongamos que vamos a desarrollar un juego y enviamos las actualizaciones del jugador con estos requisitos:\n\nSe ignorarán los paquetes fuera de orden. Si enviamos (A B C), y UDP recibe (A C B), a nivel de aplicación descataríamos B, resultando en (A C).\nSe ignorarán los duplicados. Si enviamos (A B C), UDP recibe (A A B), a nivel de aplicación descartamos la segunda A, resultando en (A B).\n\nPara esta implementación nuestro protocolo podría añadir un número de paquete en los primeros bytes de UDP (antes de la actualización del juego), y el servidor tener un estado del último paquete que recibió. Cada vez que recibimos un paquete lo aceptamos si el número de paquete del servidor &lt; número del paquete recibido, y lo rechazamos de otra forma. Con este pequeño y sencillo protocolo hemos conseguido ignorar paquetes fuera de orden y duplicado con una sobrecarga mínima en el protocolo, y sin la sobrecarga del resto de funcionalidades que no son necesarias.\nLa estructura de paquete de UDP es la siguiente:\n\n\n\n\n\n\nFigura 5.2: Estructura del paquete UDP\n\n\n\nComo podéis ver la estructura del paquete es realmente simple en comparación con el resto de protocolos. El puerto de destino le permite a UDP demultiplexar correctamente el paquete, mientras el de origen le permite al servidor contestar. La longitud indica el tamaño de los datos, que es un número de 16 bits, es decir, que podría ser hasta 65535 (no incluido), pero en la práctica está limitado por el MTU. Por último, el checksum que es una forma de verificar la integridad del paquete. Esta verificación es contra cambios accidentales, pero puede ser manipulada.\nEl cálculo del checksum UDP sigue un procedimiento sistemático que garantiza la verificación de integridad de todo el datagrama:\n\nPreparación de datos: Se concatena la pseudo-cabecera IP, la cabecera UDP (con checksum inicializado a cero) y los datos de aplicación, añadiendo un byte de padding si la longitud total es impar.\nCálculo aritmético: Los datos se dividen en palabras de 16 bits que se suman usando aritmética de complemento a uno, incorporando cualquier carry al resultado final.\nComplemento final: Se calcula el complemento a uno del resultado y se inserta en el campo checksum de la cabecera UDP.\n\nEl proceso de verificación en el receptor utiliza el mismo algoritmo pero incluye el checksum recibido en el cálculo, esperando obtener 0xFFFF si no hay errores. Si el resultado difiere de 0xFFFF, el datagrama se descarta silenciosamente sin notificación al emisor. La pseudo-cabecera proporciona verificación adicional del direccionamiento correcto, validación del protocolo UDP, y consistencia entre las longitudes reportadas por IP y UDP. Es importante tener en cuenta, que el mecanismo solo detecta errores pero no los corrige, y UDP no implementa retransmisión automática de datagramas corruptos.\n// Cálculo de checksum en UDP\nfunction calculateUDPChecksum(srcIP, dstIP, srcPort, dstPort, data) {\n    // Convert string data to Uint8Array if needed\n    if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n    }\n    \n    const udpLength = 8 + data.length;\n    \n    // Build complete packet: pseudo-header + UDP header + data\n    const packet = [\n        // Pseudo-header (12 bytes)\n        ...srcIP.split('.').map(x =&gt; parseInt(x)),           // Source IP (4 bytes)\n        ...dstIP.split('.').map(x =&gt; parseInt(x)),           // Dest IP (4 bytes)\n        0, 17,                                               // Zero + Protocol UDP (2 bytes)\n        (udpLength &gt;&gt; 8) & 0xFF, udpLength & 0xFF,          // UDP length (2 bytes)\n        \n        // UDP header (8 bytes)\n        (srcPort &gt;&gt; 8) & 0xFF, srcPort & 0xFF,              // Source port (2 bytes)\n        (dstPort &gt;&gt; 8) & 0xFF, dstPort & 0xFF,              // Dest port (2 bytes)\n        (udpLength &gt;&gt; 8) & 0xFF, udpLength & 0xFF,          // UDP length (2 bytes)\n        0, 0,                                                // Checksum placeholder (2 bytes)\n        \n        // Data payload\n        ...Array.from(data)\n    ];\n    \n    // Calculate 16-bit one's complement checksum\n    let sum = 0;\n    for (let i = 0; i &lt; packet.length - 1; i += 2) {\n        sum += (packet[i] &lt;&lt; 8) + packet[i + 1];\n    }\n    \n    // Handle odd length\n    if (packet.length % 2 === 1) {\n        sum += packet[packet.length - 1] &lt;&lt; 8;\n    }\n    \n    // Add carry bits and return one's complement\n    while (sum &gt;&gt; 16) sum = (sum & 0xFFFF) + (sum &gt;&gt; 16);\n    return (~sum) & 0xFFFF;\n}\nUDP es especialmente adecuado para aplicaciones donde la velocidad prima sobre la garantía de entrega, incluyendo multimedia streaming (tolerante a pérdidas menores pero sensible a interrupciones por control de congestión), consultas DNS que requieren respuestas rápidas, protocolos de administración de red como SNMP, sistemas de enrutamiento como RIP, gaming online donde la latencia baja es crítica, y como base para protocolos modernos de transporte como QUIC/HTTP3 que implementan sus propios mecanismos de confiabilidad optimizados.\n\n\nTCP (Transmission Control Protocol)\nTCP (Transmission Control Protocol) es el protocolo de transporte más utilizado en Internet y representa el extremo opuesto a UDP en términos de garantías y complejidad [RFC 793]. TCP prioriza la confiabilidad y el orden de los datos sobre la velocidad pura, siendo fundamental para aplicaciones como navegadores web, correo electrónico, transferencia de archivos y cualquier servicio que requiera integridad absoluta de los datos. Las características principales de TCP son las siguientes:\n\nProtocolo confiable y complejo: TCP implementa múltiples mecanismos para garantizar que todos los datos enviados lleguen al destinatario en el orden correcto y sin errores. Esta confiabilidad viene al costo de mayor complejidad, latencia y overhead del protocolo.\nOrientado a conexión: Antes de enviar cualquier dato, TCP requiere establecer una conexión formal entre cliente y servidor mediante un proceso de handshaking de tres fases. Esta conexión mantiene estado en ambos extremos, permitiendo el seguimiento de cada byte enviado y recibido.\nEntrega fiable y ordenada: TCP garantiza que todos los datos enviados lleguen al destinatario exactamente una vez y en el mismo orden en que fueron enviados. Implementa mecanismos de detección de pérdidas, duplicados y reordenamiento automático.\nControl de flujo: TCP implementa mecanismos para evitar que el emisor sature al receptor, ajustando automáticamente la velocidad de envío según la capacidad de procesamiento del destinatario a través del campo “Window”.\nControl de congestión: TCP detecta y responde a la congestión de la red, reduciendo automáticamente su tasa de transmisión cuando detecta pérdidas o aumentos en la latencia, contribuyendo así a la estabilidad general de Internet.\nMultiplexación y demultiplexación: Al igual que UDP, TCP utiliza números de puerto para identificar los diferentes servicios y aplicaciones en un mismo host.\n\nRespecto a las características que TCP no proporciona, tenemos la temporización específica, tasa mínima garantizada de transferencia y seguridad nativa. TCP no puede garantizar una tasa mínima de transferencia porque debe adaptarse dinámicamente a las condiciones cambiantes de la red. La temporización específica no es posible debido a la naturaleza variable de Internet y los mecanismos de retransmisión que pueden introducir retrasos impredecibles. La seguridad debe implementarse en capas superiores (como TLS/SSL) ya que TCP se centra únicamente en la confiabilidad del transporte.\nLa robustez de TCP permite que las aplicaciones se enfoquen en su lógica de negocio sin preocuparse por los detalles de la transmisión de datos. Por ejemplo, cuando un navegador web solicita una página:\n\nTCP garantiza que todos los bytes del HTML, CSS, JavaScript e imágenes lleguen completos y en orden.\nSi algún paquete se pierde en la red, TCP lo detecta y retransmite automáticamente.\nSi la red se congestiona, TCP reduce su velocidad para no empeorar la situación.\nEl navegador recibe los datos como si fuera un flujo continuo y confiable de bytes.\n\nLa estructura de paquete de TCP es considerablemente más compleja que UDP:\n\n\n\n\n\n\nFigura 5.3: Estructura del paquete TCP\n\n\n\nComo se puede observar, la cabecera TCP es mucho más rica en información que UDP. Los puertos de origen y destino funcionan igual que en UDP para la multiplexación. El número de secuencia identifica la posición del primer byte de datos en el flujo, mientras que el número de acknowledgment indica el siguiente byte que el receptor espera recibir, implementando así el mecanismo de confirmación acumulativa.\nLos flags de control son cruciales para el funcionamiento de TCP:\n\nSYN: Utilizado para sincronizar números de secuencia durante el establecimiento de conexión.\nACK: Indica que el campo de acknowledgment es válido.\nFIN: Señala el fin de los datos del emisor.\nRST: Fuerza el reinicio de la conexión.\nPSH: Solicita entrega inmediata al proceso aplicación.\nURG: Indica datos urgentes.\n\nEl campo Window implementa el control de flujo, indicando cuántos bytes está dispuesto a recibir el destinatario. El checksum funciona de manera similar a UDP pero cubriendo todo el segmento TCP.\n\nEstablecimiento de Conexión: Handshake de Tres Fases\nEl proceso de establecimiento de conexión TCP es un ejemplo de sincronización distribuida:\n\n\n\n\n\n\nFigura 5.4: Handshake de tres fases TCP\n\n\n\nFase 1 - SYN: El cliente envía un segmento con SYN=1 y un número de secuencia inicial aleatorio (x). Este número aleatorio es crucial para la seguridad, evitando ataques de predicción de secuencia.\nFase 2 - SYN+ACK: El servidor responde con SYN=1, ACK=1, su propio número de secuencia inicial (y) y confirma el número del cliente incrementado en uno (ack=x+1).\nFase 3 - ACK: El cliente confirma el número de secuencia del servidor (ack=y+1), estableciendo oficialmente la conexión bidireccional.\nDurante este proceso se negocian parámetros importantes como el MSS (Maximum Segment Size), opciones de ventana deslizante y otras extensiones TCP.\n\n\nMecanismos de Confiabilidad\nTCP implementa varios mecanismos para garantizar la entrega confiable. Números de Secuencia y ACKs: Cada byte en el flujo TCP tiene un número de secuencia único. Los ACKs son acumulativos, lo que significa que un ACK para el byte N confirma la recepción correcta de todos los bytes desde el inicio hasta N-1. Detección de Pérdidas: TCP utiliza dos métodos principales:\n\nTimeout: Si no recibe ACK en un tiempo determinado, asume pérdida y retransmite.\nACKs duplicados: Si recibe tres ACKs duplicados para el mismo número de secuencia, asume pérdida del siguiente segmento y retransmite inmediatamente (Fast Retransmit).\n\n\n\n\n\n\n\n\n\nFigura 5.5: Detección de pérdidas por timeout\n\n\n\n\n\n\n\n\n\n\nFigura 5.6: Detección de pérdidas por ACKs duplicados\n\n\n\n\n\n\n\nControl de Flujo\nTCP mantiene buffers tanto en emisión como en recepción, permitiendo el manejo de segmentos fuera de orden y la optimización del flujo de datos. El control de flujo TCP es un mecanismo sofisticado que previene el desbordamiento del receptor:\n\n\n\n\n\n\nFigura 5.7: Control de flujo TCP\n\n\n\nLa VentanaRecepcion se calcula como:\nVentanaRecepcion = BufferRecepcion - (UltimoByteRecibido - UltimoByteLeido)\nEl emisor debe asegurar que:\nUltimoByteEnviado - UltimoByteReconocido ≤ VentanaRecepcion\nCuando la ventana de recepción se reduce a cero, el emisor detiene el envío pero continúa sondeando periódicamente con segmentos de un byte para detectar cuándo hay espacio disponible nuevamente.\n\n\nControl de Congestión\nEl control de congestión TCP es uno de los algoritmos más importantes de Internet. Utiliza la ventana de congestion para regular la velocidad de envío. La ventana de congestión es una variable del emisor que representa el número máximo de bytes que pueden estar en el “aire” en la red, es decir, el número máximo de bytes que pueden ser enviados sin que sean reconocidos (ack). Se combina con la ventana de recepción para determinar la tasa de envío actual, siendo la tasa efectiva el mínimo de ambas. La ventana de congestión se regula en base a dos mecanismos:\n\nSlow start (arranque lento): Se inicia con una ventana de congestión igual a 1 MSS. Duplica la ventana cada RTT (ver ejemplo en Figura 5.8) hasta detectar pérdida o alcanzar un umbral. Es decir, el tamaño crece exponencialmente y es ideal para descubrir el ancho de banda.\nCongestion avoidance (evitación de congestión): Tiene un comportamiento más conservador. Incrementa 1 MSS por cada RTT (ver el ejemplo en Figura 5.9).\n\ny dos eventos que regulan el paso entre los dos mecanismos:\n\nSalta un temporizador: Pérdida severa. Se reduce la ventana de congestión a 1 MSS y pasamos a modo slow start.\nTres ACK duplicados: Pérdida no tan severa, se reduce la ventana de congestión a la mitad.\n\n\n\n\n\n\n\n\n\nFigura 5.8: A) Mecanismo de congestión slow start.\n\n\n\n\n\n\n\n\n\n\nFigura 5.9: B) Mecanismo de congestión congestion avoidance.\n\n\n\n\n\nEste mecanismo crea el característico patrón de “diente de sierra” en el throughput de TCP, donde la ventana crece gradualmente hasta detectar congestión, se reduce drásticamente, y vuelve a crecer.\n\n\n&lt;Figure size 1344x768 with 0 Axes&gt;\n\n\n\n\n\n\n\n\nFigura 5.10: Patrón de diente de sierra en el control de congestión TCP\n\n\n\n\n\nTerminación de Conexión\nLa terminación de conexión TCP requiere un proceso de cuatro fases debido a su naturaleza full-duplex:\n\n\n\n\n\n\nFigura 5.11: Terminación de conexión TCP\n\n\n\n\nFIN del Cliente: El cliente envía FIN indicando que terminó de enviar datos\nACK del Servidor: El servidor confirma la recepción del FIN\nFIN del Servidor: El servidor envía su propio FIN cuando termina de enviar\nACK del Cliente: El cliente confirma y entra en estado TIME_WAIT\n\nEl estado TIME_WAIT es crucial para manejar ACKs retrasados y asegurar que la conexión se cierre completamente.\n\n\nEquidad y Coexistencia\nTCP está diseñado para ser “fair” cuando múltiples conexiones comparten el mismo enlace. El algoritmo de control de congestión asegura que N conexiones TCP compartan equitativamente un enlace de capacidad R, obteniendo aproximadamente R/N cada una.\nSin embargo, esta equidad tiene limitaciones:\n\nAplicaciones UDP: No implementan control de congestión, pueden monopolizar ancho de banda.\nConexiones paralelas: Una aplicación puede abrir múltiples conexiones TCP para obtener mayor throughput.\nRTT diferentes: Conexiones con menor RTT pueden obtener ventaja.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Capa de transporte</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/transport_layer/transport_layer.html#comparativa-de-tcp-vs-udp-para-videojuegos",
    "href": "ch/part_networks/transport_layer/transport_layer.html#comparativa-de-tcp-vs-udp-para-videojuegos",
    "title": "5  Capa de transporte",
    "section": "5.3 Comparativa de TCP vs UDP para videojuegos",
    "text": "5.3 Comparativa de TCP vs UDP para videojuegos\nLa decisión de elegir entre TCP y UDP depende de la interactividad y la tolerancia a pérdidas de información del juego. Por ejemplo, si se requiere de latencias de menos de 50ms, con actualizaciones frecuentes y la información nueva es más valiosa que la vieja, UDP es el claro ganador. Esto se consigue gracias a unas cabeceras mucho más pequeñas y la ausencia de tráfico de control. Otro aspecto positivo es que el servidor necesita menos recursos, al no tener que gestionar la lógica de gestión ni mantener el estado. Algunos videojuegos donde UDP es mejor opción es en shooters o juegos de lucha debido a su alta interactividad.\nPor contra, si la latencia es de 100ms a 200ms, se necesita una entrega ordenada garantizada y detección y corrección de errores, TCP es la mejor opción. Con tolerancias de latencia mayores, no tenemos que preocuparnos por bloqueo de cabeza de línea, es decir, que un paquete perdido impida el procesamiento de los posteriores que ya llegaron. También tendríamos que tener en cuenta las latencias variables, debido a retransmisiones, lo cual podría generar saltos de estado, incluso con tolerancias de 100ms. Por último, habría que considerar también que incurriremos en un mayor tráfico de red, tanto por el tráfico de control como por el mayor tamaño de los paquetes TCP. Los juegos de rol y por turnos son ejemplos de juegos que se adaptan muy bien a TCP.\nPasando a ejemplos concretos, World of Warcraft es un ejemplo de juego implementado sobre TCP. Los hechizos y ataques necesitan entrega garantizada para mantener la consistencia, así como la actualizaciones del inventario y estado de las misiones. Generalmente los MMORPGs pueden soportar latencias de 100s a 200ms.\nEn el caso de Counter Strike se utiliza UDP debido a que la retroalimentación inmediata es más importante que la entrega garantizada. Por ejemplo, las actualizaciones de posición y disparos necesitan una latencia muy baja. Es tan importante, que aún con UDP, es necesario utilizar técnicas de interpolación de estados en los clientes para conseguir transiciones suaves. Esta interpolación limita el efecto de paquetes perdidos.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Capa de transporte</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html",
    "href": "ch/part_networks/application_layer/application_layer.html",
    "title": "6  Capa de aplicación",
    "section": "",
    "text": "6.1 Socket\nLa capa de aplicación define los protocolos que utilizarán las aplicaciones para intercambiar datos. Las aplicaciones generalmente se representan con procesos, y por lo tanto, la capa de aplicación se centra en la comunicación entre procesos. Este nivel de ejecución nos va a quedar más claro si tenemos en cuenta que podemos crear nuestros propios protocolos que se ejecuten a nivel de capa de aplicación.\nA continuación veremos un ejemplo de protocolo definido en la capa de aplicación, que realiza una función de “echo”, es decir, repite la información que recibe. Además, este pequeño ejemplo nos servirá para introducir los tipos de arquitecturas que pueden tener una aplicación de red. En concreto, este ejemplo utilizará una arquitectura cliente - servidor. En este tipo de arquitectura, tenemos un host (servidor) que está siempre activo con una dirección IP conocida y que ofrece servicio a otros hosts (clientes). Estos clientes podrán estar activos o no, y no se comunican entre ellos, sólo con el servidor. En este ejemplo tendremos un servidor, cuya funcionalidad será devolver la información recibida, con el formato “Echo: {message}”, donde {message} es el contenido recibido. El servidor continuará contestando la petición de los clientes hasta que reciba el mensaje “quit”, mediante el cual se cerrará la conexión entre ambos.\nA continuación se muestra el servidor. Está programado en JavaScript, que veremos en la siguiente parte del libro. No os preocupéis si no entendéis todo, es simplemente a modo de ilustración.\nEste servidor está formado por dos funciones, la función “handleClient” y la función “echoServer”. Empezando por “echoServer”, en las primeras líneas se crea un servidor TCP usando el módulo ‘net’ de Node.js. El servidor utiliza el modelo basado en eventos de JavaScript - cuando se conecta un cliente, se dispara automáticamente el evento ‘connection’, que delega el procesamiento del cliente a “handleClient”. La función “handleClient” define el “protocolo” mediante eventos: escucha el evento ‘data’ de forma indefinida hasta que se reciba un mensaje con la palabra “quit”, procesa los datos recibidos y los devuelve al cliente con el formato “Echo: {message}”. Esta ejecución también puede terminar cuando se disparan los eventos ‘close’ (cliente desconecta) o ‘error’ (error en la conexión), que son manejados automáticamente por el sistema de eventos de Node.js. Si os fijáis en esta función trabajamos con la variable “socket”, que es la interfaz entre la capa de aplicación y la capa de transporte. Dicho de otra forma, es la interfaz que tenemos de interactuar con la capa inferior, y la capa inferior con nosotros. El servidor queda escuchando en localhost:8888 y puede manejar múltiples clientes simultáneamente gracias al bucle de eventos asíncrono de Node.js.\nAhora pasaremos a la parte del cliente:\nEn este caso el código está hecho con Python, no es un requisito necesario y podría estar en JavaScript, pero quería remarcar que la definición de protocolos en red permite la comunicación entre dos procesos que están en la misma u otra máquina, independientemente de su lenguage de programación 1. En este cliente de Python tenemos una única función que representa al cliente, “echo_client”, donde en las primeras líneas establecemos una conexión con el servidor de JavaScript. Fijaros en el ('localhost', 8888), con esta combinación de identificador de máquina, “localhost”, podemos identificar el host donde está el servidor, y con el puerto, 8888, podemos identificar el proceso que corresponde al servidor. Como en el anterior ejemplo, tenemos un “socket” que permite una interacción bidireccional con la capa de transporte. No os preocupéis por estos detalles, los veremos en el siguiente capítulo.\nCon este ejemplo hemos ilustrado los tres conceptos clave de este capítulo, los protocolos de la capa de aplicación, la arquitectura de las aplicaciones de red 2, y los sockets que permiten la interacción entre la capa de aplicación y la capa de transporte. En los siguientes apartados profundizaremos en estos temas. Primero, veremos en detalle los sockets. Después, indagaremos en las arquitecturas de aplicaciones en red. Posteriormente veremos protocolos utilizados en la actualidad como HTTP que utilizamos cuando navegamos por la web, SMTP, IMAP y POP que utilizamos en las aplicaciones de correo, entre otros.\nLos sockets son la interfaz de programación que permite a las aplicaciones comunicarse con la capa de transporte. Actúan como un punto de conexión bidireccional entre la capa de aplicación y la capa de transporte, proporcionando una abstracción que oculta los detalles de bajo nivel de la comunicación en red. En esencia, un socket es un endpoint de comunicación que permite que los procesos intercambien datos, ya sea en la misma máquina o a través de una red. La API de sockets fue introducida en BSD4.1 UNIX en 1981. Fue explícitamente creada, usada y lanzada por las aplicaciones de red. Está basada en el paradigma cliente/servidor.\nCuando una aplicación necesita comunicarse a través de la red, crea un socket que especifica el protocolo de transporte a utilizar (TCP o UDP), la dirección IP del host de destino, y el número de puerto del proceso receptor. El socket encapsula toda la información necesaria para establecer y mantener una conexión de red, proporcionando una interfaz uniforme independientemente del protocolo de transporte subyacente. Los sockets se pueden clasificar según el protocolo de transporte que utilizan, siendo los más comunes los sockets TCP y UDP, cada uno con características y casos de uso específicos. Los detalles del funcionamiento interno de TCP y UDP los veremos en el capítulo de la capa de transporte.\nPara identificar un proceso se necesita:",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html#socket",
    "href": "ch/part_networks/application_layer/application_layer.html#socket",
    "title": "6  Capa de aplicación",
    "section": "",
    "text": "IP del host: Dirección única de 32 bits (IPv4)\nNúmero de puerto: Asociado con el proceso en el host\nEjemplos: HTTP (puerto 80), HTTPS (puerto 443), DNS (puerto 53)\n\n\nSockets TCP\nLos sockets TCP (Transmission Control Protocol) proporcionan una comunicación confiable y orientada a conexión entre procesos. Antes de que los datos puedan ser intercambiados, se debe establecer una conexión explícita entre el cliente y el servidor, lo que garantiza que ambos extremos estén listos para la comunicación. Las características principales del socket TCP son las siguientes:\n\nOrientado a conexión: Requiere establecer una conexión antes del intercambio de datos.\nConfiabilidad: Garantiza que todos los datos enviados lleguen al destino sin errores y en orden.\nControl de flujo: Evita que el emisor sature al receptor.\nControl de congestión: Adapta la velocidad de envío según las condiciones de la red.\nFull-duplex: Permite comunicación bidireccional simultánea.\n\nPara crear un socket TCP de tipo servidor, es decir, que siempre está activo y está esperando las conexiones de los clientes (arquitectura cliente-servidor), utilizaremos el módulo net de Javascript. Dentro de este módulo, utilizaremos la función “createServer” para crear un socket de tipo servidor de TCP. Posteriormente, utilizaremos el método “listen” para escuchar en un puerto en concreto. En este caso, el 8888. El segundo parámetro, que en este caso es “localhost”, es opcional, y quiere decir que los clientes tienen que estar en esa red. Si obviamos el parámetro, los clientes podrán conectarse desde cualquier otra máquina. Finalmente, el último parámetro es un “callback” que se ejecutará una vez el servidor socket esté escuchando en el puerto correctamente.\nconst net = require('net');\n\n// Crear servidor TCP\nconst server = net.createServer();\n\n// Configurar el servidor para escuchar en puerto 8888\nserver.listen(8888, 'localhost', () =&gt; {\n    console.log('Servidor TCP escuchando en localhost:8888');\n});\nPor ahora hemos bloqueado un puerto dentro de nuestra máquina y estamos esperando a que se conecten los clientes. Ahora, tenemos que gestionar los eventos de conexión. Para ello, utilizaremos el método “server.on”, especificándole que el evento que queremos escuchar es la conexión “connection” (primer parámetro). El segundo parámetro es un manejador de conexión (una función), que recibe un “socket”, y que será invocada por el servidor socket por cada cliente que se conecte. Recordemos que TCP está orientado a conexión. En nuestro código esa conexión con el cliente se realizará a través del “socket” que recibe el manejador.\n// Manejar nuevas conexiones\nserver.on('connection', (socket) =&gt; {\n    console.log('Cliente conectado:', socket.remoteAddress);\n    // El socket está listo para intercambiar datos\n});\nSobre este socket que hemos recibido en el manejador podemos escuchar diferentes eventos. El primer evento que veremos es “data”. Este evento se invocará cada vez que el socket reciba información desde el otro socket. Estos datos se procesan a través de un manejador que le pasaremos cuando escuchamos el evento “data”. El manejador recibirá un parámetro, que en el siguiente código se denomina “data”, y contendrá los datos enviados por el otro integrante de la conexión.\nsocket.on('data', (data) =&gt; {\n\n})\nPor contextualizar, supongamos que tenemos un juego con dos jugadores que están en diferentes máquinas y estos se comunican con un servidor central. En este método recibiríamos por ejemplo las actualizaciones de estado de cada uno de los jugadores, y tendríamos que actualizar el estado del servidor y notificar al otro jugador.\nEl siguiente evento es “close”. Este evento se invocará cuando la conexión se haya cerrado. En el manejador que le pasamos como parámetro tendremos que realizar las operaciones oportunas en base al protocolo que estemos definiendo.\nsocket.on('close', () =&gt; {\n    console.log(`[${socket.remoteAddress}] Disconnected`);\n});\nSiguiendo con el ejemplo, este evento podría invocarse si uno de los jugadores se desconecta. En ese caso, se invocaría ese método, el servidor debería actualizar a finalizado el estado del juego, y notificar al otro jugador de que la partida ha terminado.\nPor último, tenemos el evento “error”. Este puede ocurrir cuando se cierra la conexión de forma inesperada, por ejemplo, te desconectas de la red. En este caso también se ejecutará el manejador de “close”, así que es recomendable poner la lógica de limpieza allí, ya que el “close” se ejecutará si la conexión se cierra tanto de forma natural como inesperada, mientras que el “error” solo cuando es de forma inesperada. Otro posible caso en el que se ejecuta el “error” es si estamos tratando de escribir en un socket que está cerrado. También puede ocurrir si salta un evento de “timeout” durante el envío de datos.\nsocket.on('error', (err) =&gt; {\n    console.log(`[${socket.remoteAddress}] Error: ${err.message}`);\n});\nAhora que sabemos como manejar los eventos, sólo nos falta ver como enviar información a través de un socket. Para ello, utilizaremos el método “write”. El segundo parámetro es un manejador que utilizaremos para capturar los errores durante el envió de información.\nsocket.write('Hello', (err) =&gt; {\n\n});\nEste método lo utilizaríamos para enviar por ejemplo las actualizaciones de estado.\nUna vez vista la parte del servidor veremos la del cliente. Para ello necesitaremos también el módulo “net” y crearemos un socket con “new net.Socket()”. Una vez creado el socket, lo conectaremos mediante la instrucción “socket.connect”. El primer parámetro es el puerto donde está escuchando el servidor socket en la máquina identificada por el segundo parámetro. En este caso, la conexión es a “localhost” y el puerto 8888. El tercer parámetro es un callback que se ejecutará una vez la conexión se haya establecido.\nconst net = require('net');\n\n// Crear socket TCP\nconst socket = new net.Socket();\n\n// Conectar al servidor (establece la conexión TCP)\nsocket.connect(8888, 'localhost', () =&gt; {\n    console.log('Conectado al servidor TCP');\n    // El socket está listo para intercambiar datos\n});\nRespecto a los métodos por la parte del cliente, son los mismos que explicamos con el socket del servidor (es decir, una vez establecida la conexión). Una vez se establece la conexión, no hay diferencia entre ambos. Como matiz, en el manejador de error del cliente tenemos algunos errores a mayores, como por ejemplo si no se puede establecer la conexión.\nAmbos socket tienen que ser cerrados para liberar recursos una vez hayamos terminado. Para ello utilizaremos el método “close”:\nsocket.close()\nEn el caso del servidor también:\nserver.close()\nSi no lo hacemos el bucle de eventos seguirá activo y la aplicación no terminará.\n\n\nSockets UDP\nLos sockets UDP (User Datagram Protocol) proporcionan una comunicación sin conexión y de mejor esfuerzo. El mejor esfuerzo se refiere a que va a intentar lo mejor que pueda enviar la información al destinatario, pero en caso de que falle, no va a volver a intentarlo ni te notificará. Esto contrasta con TCP que si lo reintenta y en caso de no poder te notifica. Sus características principales son las siguientes:\n\nSin conexión: No requiere establecer conexión previa\nMejor esfuerzo: No garantiza entrega, orden ni integridad de datos\nBaja latencia: Menor overhead que TCP\nSimplicidad: Protocolo más simple y directo\nBroadcast/Multicast: Soporte nativo para envío a múltiples destinatarios\n\nPara recibir paquetes de UDP, crearemos un servidor de UDP utilizando el paquete “dgram”. El socket se crea mediante la expresión “dgram.createSocket(‘udp4’)”. En este caso se utiliza “udp4” ya que utilizamos IPv4, pero si queremos utilizar IPv6 sería “udp6”. Veremos las diferencias en el capítulo de capa de red. Una vez creado el socket, nos mantenemos a la escucha con la instrucción “bind”. En este caso, el puerto 8888. El segundo parámetro, en este caso “localhost”, indica que solo aceptaremos peticiones de la red “localhost”. Como en TCP, si lo dejamos vacio será cualquier red. También podremos especificar otras redes. Finalmente tenemos un manejador que se invocará si el socket empieza a escuchar en el puerto 8888 correctamente.\nconst dgram = require('dgram');\n\n// Crear socket UDP\nconst server = dgram.createSocket('udp4');\n\n// Vincular el socket al puerto 8888\nserver.bind(8888, 'localhost', () =&gt; {\n    console.log('Servidor UDP escuchando en localhost:8888');\n});\nPara recibir mensajes, añadimos un manejador al evento “message”. Este manejador recibe dos parámetros. El mensaje, que es lo que nos han enviado desde el socket UDP cliente y el parámetro rinfo, que contiene la información necesaria para identificar el socket que nos envía información.\n// Escuchar mensajes entrantes\nserver.on('message', (msg, rinfo) =&gt; {\n    console.log(`Mensaje recibido de ${rinfo.address}:${rinfo.port}`);\n    // No hay conexión establecida, cada mensaje es independiente\n});\nTambién podremos añadir un manejador de errores con el evento “error”. Los errores podrían ser que no se puede hacer el bind al puerto. Esto puede ocurrir si el puerto ya está en uso o es un puerto reservado y no tenemos los permisos necesarios.\nsocket.on('error', (err) =&gt; {\n    console.error('Socket error:', err.message);\n\n});\nPara enviar los mensajes, tendremos que crear un socket con el módulo “dgram”. Posteriormente, utilizaremos “createSocket” para crear el socket cliente que nos permitirá enviar información.\nconst dgram = require('dgram');\n\n// Crear socket UDP\nconst client = dgram.createSocket('udp4');\nPara enviar la información utilizaremos el método send. Como no tenemos una conexión como en TCP, cada vez que enviemos información tenemos que indicarle cuál es el puerto de destino (8888) y la IP de destino (localhost). El manejador se invocará indicándonos si ha habido un error durante el envío o no. Algunos errores pueden ser que el destino no se pueda alcanzar, que el buffer de UDP esté lleno, entre otros. Como hemos comentado, que el mensaje se haya enviado no quiere decir que el destinatario lo reciba.\nclient.send('Hola servidor UDP', 8888, 'localhost', (err) =&gt; {\n    if (err) throw err;\n    console.log('Mensaje enviado al servidor UDP');\n});\nUna pregunta que os puede surgir con UDP es, ¿Cómo le escribe de vuelta el actual “servidor” al “cliente”? La respuesta es simple, invirtiendo los roles. Cuando creamos nuestro “socket cliente” sin decirle que haga un bind a un puerto determinado, cuando enviamos un mensaje se hace un bind a un puerto aleatorio que esté libre. A través del “rinfo” anterior tenemos tanto “rinfo.address” como “rinfo.port” que son la IP y el puerto. Por lo tanto, podemos escribir al cliente utilizando esa información.\nPara recepcionar ese mensaje, en el cliente tendríamos que escuchar el evento de “message”:\nclient.on('message', (msg, rinfo) =&gt; {\n    console.log(`Mensaje recibido de ${rinfo.address}:${rinfo.port}`);\n    // No hay conexión establecida, cada mensaje es independiente\n});\ny también podríamos como hicimos antes capturar el evento de errores. Con esto podemos llegar a una interesante conclusión. Tanto el socket del cliente como el del servidor son iguales. La única diferencia es que en el servidor, le indicamos especificamente en que puerto queremos escuchar. Esto lo hacemos para facilitar que los demás sepan donde está ubicado. En el caso del cliente no tenemos esa necesidad. Podemos escoger un puerto aleatorio. Cuando enviemos un mensaje al servidor el sabrá el puerto del cliente y podrá escribirle también.\nFinalmente, es necesario cerrar tanto el cliente:\nclient.close()\ncomo el servidor\nserver.close()\nSi no el bucle de eventos seguirá activo y la ejecución no terminará. También se liberarán los recursos.\n\n\nServicios Requeridos y elección de capa de transporte\nLas aplicaciones de red tienen diferentes requisitos en cuanto a los servicios que necesitan de la capa de transporte. Estos requisitos determinan qué protocolo de transporte es más apropiado para cada aplicación específica.\nTransferencia Confiable: Algunas aplicaciones requieren que todos los datos enviados lleguen al destino sin errores ni pérdidas. Esta característica es fundamental para aplicaciones donde la integridad de la información es crítica. Ejemplos de aplicaciones que requieren una confiabilidad total son la transferencia de archivos, correo electrónico, navegación web, banca online, comercio electrónico. En estos casos, la pérdida de datos podría resultar en archivos corruptos, mensajes incompletos o transacciones fallidas. Por otra parte, algunas aplicaciones son tolerantes a la pérdida de información, como el streaming de audio/vídeo, videoconferencias, juegos en tiempo real. Estas aplicaciones pueden funcionar adecuadamente incluso si se pierden algunos paquetes ocasionalmente, ya que el contenido perdido puede ser interpolado o simplemente ignorado sin afectar significativamente la experiencia del usuario.\nTemporización (Timing): El tiempo de respuesta es crucial para aplicaciones interactivas y en tiempo real. Algunas aplicaciones son sensibles a la latencia, como los juegos multijugador online, trading de alta frecuencia, aplicaciones de realidad virtual, control remoto de dispositivos. Estas aplicaciones requieren tiempos de respuesta muy bajos (típicamente menos de 50-100ms) para proporcionar una experiencia fluida. En otros casos no es tan importante, como en el correo electrónico, transferencia de archivos en segundo plano, respaldos automáticos. Estas aplicaciones pueden funcionar correctamente con latencias más altas sin afectar significativamente la experiencia del usuario.\nAncho de Banda: Las necesidades de ancho de banda varían enormemente entre aplicaciones. Ejemplos de aplicaciones sensibles al ancho de banda son el streaming de vídeo 4K/8K, videoconferencias de alta calidad, transferencia de archivos grandes, respaldos de bases de datos. Estas aplicaciones requieren una tasa mínima garantizada de transferencia para funcionar correctamente. Cuando una aplicación no es sensible, a veces se denominan elásticas, es decir, estas aplicaciones pueden adaptarse al ancho de banda disponible, funcionando más lento con conexiones limitadas pero manteniéndose operativas. Algunos ejemplos son: Navegación web, correo electrónico, mensajería instantánea.\nSeguridad: Los requisitos de seguridad incluyen varios aspectos:\n\nConfidencialidad: Garantizar que solo los destinatarios autorizados puedan leer los datos (mediante cifrado).\nIntegridad: Asegurar que los datos no han sido modificados durante la transmisión.\nAutenticación: Verificar la identidad de las partes que se comunican.\nNo repudio: Garantizar que el emisor no pueda negar haber enviado los datos.\n\nAplicaciones como banca online, comercio electrónico, mensajería privada y transferencia de documentos confidenciales requieren múltiples aspectos de seguridad, mientras que aplicaciones como streaming público o noticias pueden tener requisitos de seguridad más relajados.\nLa elección entre sockets TCP y UDP depende de los requisitos específicos de la aplicación:\nUsar TCP cuando:\n\nLa integridad de datos es crítica\nSe necesita garantizar el orden de los mensajes\nLa aplicación puede tolerar mayor latencia\nSe transfieren archivos o datos importantes\n\nUsar UDP cuando:\n\nLa velocidad y baja latencia son prioritarias\nLa aplicación puede manejar pérdida ocasional de datos\nSe implementan aplicaciones en tiempo real\nSe necesita comunicación multicast o broadcast\n\nAlgunos ejemplos de elección son los siguientes:\n\n\n\n\n\n\n\n\n\n\n\nAplicación\nConfiabilidad\nTemporización\nAncho de Banda\nSeguridad\nProtocolo Típico\n\n\n\n\nTransferencia de archivos\nSí\nNo crítica\nElástica\nSegún contenido\nTCP\n\n\nCorreo electrónico\nSí\nNo crítica\nElástica\nSí\nTCP\n\n\nNavegación web\nSí\nModerada\nElástica\nSí (HTTPS)\nUDP (HTTP/3) / TCP (HTTP/1.1-2)\n\n\nStreaming de vídeo\nTolerante\nCrítica\nMínima garantizada\nSegún contenido\nUDP/TCP\n\n\nJuegos en tiempo real\nTolerante\nMuy crítica\nModerada\nSí\nUDP\n\n\nVideoconferencia\nTolerante\nCrítica\nMínima garantizada\nSí\nUDP/TCP\n\n\nDNS\nTolerante\nCrítica\nElástica\nCreciente (DoH/DoT)\nUDP/TCP\n\n\n\nEn esta tabla igual hay un detalle que os llama la atención. Hemos dicho que UDP no es confiable. Se puede perder información o incluso llegar en distinto orden. Sin embargo, en la navegación web que requiere de confiabilidad, se indica que se utiliza UDP cuando el protocolo es HTTP/3. ¿Cómo es esto posible? La respuesta es QUIC, que veremos posteriormente en este capítulo. Lo interesante en este caso es darnos cuenta de que podemos tener una comunicación confiable (QUIC) a través de un medio no confiable (UDP). Para ello, el protocolo QUIC añade una nueva capa (encapsular) con la información y lógica necesaria para garantizar la confiabilidad en ambos extremos. Otra forma de verlo es que a veces podemos movernos entre TCP y UDP añadiendo los requisitos que necesitemos a UDP, que es el protocolo más básico, y evitar algunas de las desventajas de TCP.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html#arquitecturas-de-aplicaciones-distribuidas",
    "href": "ch/part_networks/application_layer/application_layer.html#arquitecturas-de-aplicaciones-distribuidas",
    "title": "6  Capa de aplicación",
    "section": "6.2 Arquitecturas de Aplicaciones Distribuidas",
    "text": "6.2 Arquitecturas de Aplicaciones Distribuidas\nLas arquitecturas en las aplicaciones distribuidas, es decir, con más de un nodo, indican cómo se conectan entre sí los nodos y cuál será el rol de cada uno de los nodos. A grandes rasgos, distinguimos tres tipos de arquitecturas: cliente - servidor, peer-to-peer e híbrida. La arquitectura cliente - servidor la mencionamos en el ejemplo anterior. En el caso de peer-to-peer, tenemos un conjunto de nodos que se conectan entre sí. La topología de las conexiones no tiene por qué ser un grafo completo, y puede variar a lo largo del tiempo. En este caso la funcionalidad está distribuida por los nodos. Un ejemplo de peer-to-peer es BitTorrent. Finalmente, las arquitecturas híbridas son una mezcla entre ambas, teniendo generalmente autoridades centrales que permiten mantener la red en funcionamiento, o determinadas funcionalidades. Las arquitecturas híbridas son más comunes que las puramente peer-to-peer.\nEn los siguientes apartados exploraremos estas tres arquitecturas, así como las aplicaciones populares y juegos para cada una de ellas.\n\nArquitectura Cliente/Servidor\nLa arquitectura cliente-servidor es un modelo fundamental de computación distribuida donde múltiples clientes solicitan servicios, recursos o datos de un servidor centralizado. En este paradigma, el servidor actúa como el punto central de control y coordinación, mientras que los clientes consumen los servicios proporcionados. Esta arquitectura se caracteriza por tener un host siempre activo (el servidor) que atiende las peticiones de numerosos hosts clientes, los cuales pueden conectarse y desconectarse dinámicamente sin afectar el funcionamiento del sistema. Los clientes poseen direcciones IP dinámicas y no se comunican directamente entre sí, sino que toda la comunicación se canaliza a través del servidor.\nEn el funcionamiento típico de esta arquitectura, el cliente inicia la comunicación enviando una solicitud al servidor, especificando qué servicio o recurso necesita. El servidor procesa esta petición, accede a los datos o recursos necesarios, y envía una respuesta de vuelta al cliente. Este modelo permite la centralización de recursos, datos y lógica de negocio, facilitando el mantenimiento, la seguridad y la consistencia del sistema. El servidor debe tener una dirección IP fija y conocida para que los clientes puedan localizarlo, y típicamente opera de forma continua para estar disponible cuando los clientes lo necesiten.\nLos requerimientos de infraestructura para sistemas cliente-servidor populares son considerables. Los servidores deben ser capaces de manejar múltiples conexiones simultáneas, procesar grandes volúmenes de datos y mantener alta disponibilidad. Esto frecuentemente requiere centros de datos con clusters de servidores, sistemas de balanceamiento de carga, redundancia y respaldo, así como conexiones de red de alto ancho de banda. Para aplicaciones con millones de usuarios, como las redes sociales o servicios de streaming, la infraestructura puede incluir múltiples centros de datos distribuidos geográficamente para optimizar la latencia y garantizar la disponibilidad del servicio.\nEjemplos cotidianos de arquitectura cliente-servidor incluyen aplicaciones web como Netflix, donde el cliente (navegador web o aplicación móvil) solicita contenido de vídeo al servidor, que almacena y transmite las películas y series. Spotify funciona de manera similar, donde los clientes solicitan canciones y playlists que están almacenadas en los servidores de la plataforma. Instagram representa otro caso típico donde los clientes suben fotos y vídeos a los servidores, y otros usuarios pueden solicitar y visualizar este contenido. Los servicios de correo electrónico como Gmail operan bajo este modelo, donde los servidores almacenan y gestionan los mensajes mientras los clientes acceden a ellos a través de aplicaciones web o móviles.\nEn el contexto de los videojuegos, la arquitectura cliente-servidor se ha convertido en el estándar para juegos multijugador masivos y competitivos. El servidor mantiene el estado autoritativo del juego, procesando todas las acciones de los jugadores y distribuyendo las actualizaciones correspondientes. Los clientes se encargan principalmente de la presentación visual, la captura de entrada del usuario y la comunicación con el servidor. Esta separación permite que el servidor tenga control total sobre la lógica del juego, previniendo trampas y garantizando la coherencia del estado del juego entre todos los participantes.\nEjemplos típicos de esta arquitectura incluyen juegos como World of Warcraft, donde miles de jugadores se conectan a servidores dedicados que mantienen mundos persistentes. Counter-Strike: Global Offensive utiliza servidores dedicados para partidas competitivas, asegurando que todas las acciones sean validadas centralmente. League of Legends emplea esta arquitectura para sus partidas clasificatorias, donde el servidor procesa todos los movimientos, ataques y habilidades de los campeones. Fortnite Battle Royale también implementa servidores dedicados para mantener la sincronización entre los 100 jugadores en cada partida.\nLos juegos de estrategia en tiempo real como StarCraft II y Age of Empires IV también adoptan esta arquitectura para sus modos multijugador competitivos. En estos casos, el servidor procesa todas las órdenes de construcción, movimiento de unidades y combates, garantizando que ambos jugadores vean exactamente el mismo estado del juego. Los MMORPGs como Final Fantasy XIV y Guild Wars 2 son ejemplos perfectos donde el servidor no solo mantiene el estado del juego sino también la persistencia de los personajes, inventarios y progreso de los jugadores.\nUno de los principales problemas en juegos cliente-servidor es la latencia o “lag”, que se refiere al tiempo que tarda una acción del jugador en ser procesada por el servidor y reflejada de vuelta al cliente. Esta latencia puede causar una experiencia de juego frustrante, especialmente en juegos de acción rápida como shooters en primera persona. Para mitigar este problema, muchos juegos implementan técnicas como la predicción del lado del cliente, donde el cliente asume temporalmente el resultado de una acción antes de recibir la confirmación del servidor.\nEl problema de la sincronización es otro desafío crítico en los juegos cliente-servidor. Cuando múltiples jugadores interactúan simultáneamente, el servidor debe procesar las acciones en un orden específico y comunicar los resultados a todos los clientes de manera coherente. Los juegos como Rocket League han tenido que implementar sistemas sofisticados de interpolación y extrapolación para mantener la fluidez del juego mientras se sincronizan las posiciones de la pelota y los vehículos entre todos los jugadores.\nLos servidores sobrecargados representan un problema significativo, especialmente durante los lanzamientos de juegos populares o eventos especiales. Diablo III experimentó problemas masivos en su lanzamiento debido a que sus servidores no podían manejar la cantidad de jugadores conectados simultáneamente. World of Warcraft ha enfrentado desafíos similares durante las expansiones, donde millones de jugadores intentan conectarse al mismo tiempo, causando colas de conexión y caídas del servidor.\nLa pérdida de conexión con el servidor es otro problema común que puede arruinar la experiencia de juego. En juegos competitivos como Dota 2 o Overwatch, una desconexión del servidor puede resultar en penalizaciones para el jugador, incluso si la falta no fue suya. Los desarrolladores han implementado sistemas de reconexión automática y buffers de tolerancia para minimizar el impacto de desconexiones temporales, pero el problema persiste como una limitación inherente del modelo cliente-servidor.\nLos costes de infraestructura representan un desafío económico significativo para los desarrolladores de juegos que adoptan esta arquitectura. Mantener granjas de servidores, centros de datos distribuidos globalmente y el ancho de banda necesario para soportar millones de jugadores concurrentes requiere inversiones masivas. Epic Games, por ejemplo, ha invertido cientos de millones de dólares en infraestructura para soportar Fortnite, incluyendo partnerships con proveedores de servicios en la nube como Amazon Web Services para escalar dinámicamente según la demanda.\nA pesar de estos desafíos, la arquitectura cliente-servidor sigue siendo la opción preferida para juegos multijugador serios debido a sus ventajas en términos de seguridad, control y escalabilidad. Los avances en tecnologías de red, computación en la nube y técnicas de optimización continúan mejorando la viabilidad de esta arquitectura. Los desarrolladores modernos implementan soluciones híbridas que combinan servidores dedicados con técnicas de peer-to-peer para diferentes aspectos del juego, optimizando tanto la experiencia del jugador como los costes operativos.\n\n\nArquitectura Peer-to-Peer (P2P)\nLa arquitectura peer-to-peer (P2P) es un modelo de computación distribuida donde los participantes (pares o peers) comparten recursos directamente entre sí sin depender de servidores centralizados. A diferencia del modelo cliente-servidor, en P2P no existe una entidad central que controle o coordine las comunicaciones; en su lugar, cada participante actúa simultáneamente como cliente y servidor, compartiendo y consumiendo recursos de manera equitativa. Esta arquitectura se caracteriza por la ausencia de dependencia de servidores siempre activos, permitiendo que los pares se conecten de forma intermitente y estableciendo comunicación directa entre ellos.\nEl funcionamiento de las redes P2P se basa en la colaboración voluntaria de los participantes, donde cada peer contribuye con recursos computacionales, de almacenamiento o ancho de banda al conjunto de la red. Los peers pueden unirse o abandonar la red libremente sin comprometer significativamente su funcionamiento, ya que la arquitectura es inherentemente autoescalable: cuantos más participantes se unen, más recursos totales están disponibles. Esta característica contrasta marcadamente con los sistemas centralizados, donde el servidor puede convertirse en un cuello de botella cuando aumenta el número de usuarios.\nExisten diferentes clasificaciones de arquitecturas P2P según su nivel de pureza y estructura:\n\nPor pureza, encontramos sistemas centralizados como Napster (que dependía de un servidor central para indexar archivos) y BitTorrent (que utiliza trackers centrales para coordinar descargas), versus sistemas completamente descentralizados como Freenet y Gnutella, que no dependen de ningún equipo específico para su funcionamiento.\nPor paridad, las redes pueden ser estructuradas, donde existen categorías específicas de nodos con control sobre la estructura de la red, o desestructuradas, donde las conexiones y la topología emergen de manera arbitraria según las decisiones individuales de cada peer.\n\nTambién existen diferentes tipos de topologías:\n\nLa topología Full Mesh es la más robusta pero también la más demandante en términos de recursos, ya que cada peer se conecta directamente con todos los demás participantes de la red. Esta configuración ofrece la máxima redundancia y la latencia más baja posible entre cualquier par de nodos, pero el número de conexiones crece exponencialmente con cada nuevo participante, haciendo que sea práctica solo para grupos muy pequeños de peers.\nLa topología Ring organiza los peers en una estructura circular donde cada nodo se conecta únicamente con sus vecinos inmediatos, formando un anillo cerrado. Los datos viajan alrededor del anillo hasta llegar a su destino, lo que puede introducir latencia variable dependiendo de la distancia entre peers en la estructura circular. Esta topología es más eficiente en términos de conexiones que el full mesh, pero presenta vulnerabilidades ya que la falla de un solo peer puede interrumpir la comunicación en todo el anillo, aunque existen implementaciones bidireccionales que mitigan este riesgo.\nLa topología Star representa un enfoque pseudo-P2P donde un peer central actúa como hub para todos los demás participantes. Aunque técnicamente sigue siendo P2P porque no requiere un servidor dedicado, esta configuración introduce un punto único de falla en el peer central. Sin embargo, es la más eficiente en términos de gestión de conexiones y sincronización, ya que reduce significativamente la complejidad de coordinación. Es común en juegos cooperativos donde el host del juego actúa como el nodo central, gestionando el estado del juego y redistribuyendo información a los otros jugadores.\nLas topologías Híbridas combinan elementos de diferentes enfoques según los requerimientos específicos del juego o aplicación. Por ejemplo, un juego podría usar una topología de star para la lógica principal del juego mientras implementa conexiones mesh directas para comunicación de voz entre jugadores. Estas implementaciones permiten optimizar diferentes aspectos del rendimiento, balanceando latencia, confiabilidad y eficiencia de recursos según las necesidades particulares de cada función dentro del sistema P2P.\n\n\n\n\n\n\n\n\n\nFigura 6.1: Full Mesh Topology\n\n\n\n\n\n\n\n\n\n\nFigura 6.2: Ring Topology\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 6.3: Hybrid Topology\n\n\n\n\n\n\n\n\n\n\nFigura 6.4: Star Topology (Pseudo-P2P)\n\n\n\n\n\nLas aplicaciones cotidianas de P2P incluyen sistemas de compartición de archivos como BitTorrent, donde los usuarios descargan fragmentos de archivos desde múltiples peers simultáneamente, distribuyendo la carga y mejorando la velocidad de descarga. Skype utilizó originalmente arquitectura P2P (similar a la arquitectura híbrida en Figura 6.3) para enrutar llamadas de voz a través de la red de usuarios, aprovechando el ancho de banda y poder computacional distribuido. Las criptomonedas como Bitcoin operan sobre redes P2P completamente descentralizadas, donde cada nodo mantiene una copia del blockchain y participa en la validación de transacciones. Los sistemas de mensajería como Tox y Briar implementan comunicación P2P directa para garantizar privacidad y resistencia a la censura.\nLas redes de distribución de contenido P2P como IPFS (InterPlanetary File System) permiten almacenar y distribuir información de manera descentralizada, donde cada participante contribuye espacio de almacenamiento y ancho de banda. Los juegos masivos como algunos servidores privados de World of Warcraft han experimentado con arquitecturas P2P para distribuir actualizaciones y contenido. Las aplicaciones de videoconferencia como Jitsi Meet pueden operar en modo P2P para llamadas pequeñas, estableciendo conexiones directas entre participantes para reducir latencia y eliminar la dependencia de servidores centrales.\nEn el contexto de los videojuegos, la arquitectura P2P ofrece ventajas únicas pero también presenta desafíos específicos. Los juegos P2P eliminan la necesidad de servidores dedicados, reduciendo costos operativos y permitiendo que los jugadores continúen partidas incluso si los servidores oficiales están fuera de línea. Esta arquitectura es especialmente efectiva en juegos con pocos participantes donde la latencia directa entre jugadores puede ser menor que la latencia a un servidor centralizado. Cada peer mantiene su propia copia del estado del juego y sincroniza cambios con otros participantes.\nLos juegos de lucha como Street Fighter 6, Tekken 8 y Guilty Gear Strive utilizan arquitecturas P2P sofisticadas con tecnología de rollback netcode. En estos juegos, ambos jugadores mantienen una simulación completa del combate y sincronizan entradas periódicamente. Cuando hay discrepancias debido a latencia, el sistema “retrocede” el estado del juego y lo recalcula con la información correcta, creando una experiencia fluida incluso con conexiones imperfectas. Esta implementación es ideal para juegos 1v1 donde la latencia directa entre jugadores suele ser menor que la latencia a un servidor dedicado.\nLos juegos cooperativos como Portal 2, It Takes Two y A Way Out aprovechan las ventajas de P2P para ofrecer experiencias de baja latencia entre un pequeño grupo de jugadores. En estos casos, uno de los peers actúa como “host” manteniendo el estado autoritativo del juego mientras otros se conectan directamente. Esta configuración elimina la necesidad de servidores dedicados para experiencias cooperativas, permitiendo que los desarrolladores ofrezcan funcionalidad multijugador sin costos adicionales de infraestructura. Los juegos de estrategia en tiempo real como Age of Empires II y StarCraft: Brood War originalmente utilizaban P2P, donde todos los jugadores ejecutaban la misma simulación y compartían comandos.\nSin embargo, los juegos P2P enfrentan desafíos significativos en términos de seguridad y prevención de trampas. Dado que cada peer tiene acceso completo al estado del juego, es relativamente fácil para usuarios malintencionados modificar datos o implementar cheats. Los juegos como Dark Souls han experimentado problemas con hackers que pueden modificar estadísticas de personajes o comportamientos del juego. La validación distribuida es compleja y requiere que múltiples peers acuerden sobre la validez de las acciones, lo que puede ser problemático cuando uno de los participantes está haciendo trampa.\nLa sincronización representa otro desafío mayor en juegos P2P, especialmente cuando el número de participantes aumenta. En juegos con muchos jugadores, cada peer debe comunicarse con todos los demás, creando un crecimiento cuadrático en el tráfico de red. Minecraft multijugador en modo LAN ejemplifica este problema: funciona bien para grupos pequeños pero se vuelve inmanejable con muchos jugadores. Los problemas de conectividad NAT también complican las conexiones P2P, ya que muchos jugadores están detrás de routers y firewalls que impiden conexiones directas, requiriendo técnicas como hole punching o servidores de relay para establecer comunicación entre peers.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html#protocolos",
    "href": "ch/part_networks/application_layer/application_layer.html#protocolos",
    "title": "6  Capa de aplicación",
    "section": "6.3 Protocolos",
    "text": "6.3 Protocolos\n\nHTTP\nHTTP (HyperText Transfer Protocol) es un protocolo público definido en un RFC que sirve para la transferencia de información en la World Wide Web. Es un protocolo de comunicación que permite la transferencia de recursos (como páginas web, imágenes, documentos, etc.) entre clientes (navegadores web) y servidores web a través de Internet. El protocolo utiliza texto legible tanto para los comandos como para las respuestas. El protocolo opera típicamente sobre TCP/IP, utilizando el puerto 80 para conexiones HTTP estándar y el puerto 443 para conexiones HTTPS seguras.\nHTTP opera bajo el modelo cliente-servidor, donde los navegadores web (u otros programas) actúan como clientes que solicitan recursos, y los servidores web responden proporcionando el contenido solicitado. Esta arquitectura descentralizada permite que la web sea escalable y resiliente, distribuyendo la carga de trabajo entre diferentes servidores. Además, al ser un protocolo sin estado, se facilita su escalabilidad. Que no tenga estado implica que cada vez que se realiza una petición es completamente independiente de las anteriores.\nCada recurso en el servidor se identifica a través de una URL (Uniform Resource Locator), que especifica no solo la ubicación del recurso sino también el protocolo necesario para acceder a él. Una URL típica como “https://www.ejemplo.com/pagina.html” contiene el protocolo (https), el nombre del host (www.ejemplo.com), y la ruta específica del recurso (/pagina.html). Esta estructura jerárquica permite organizar y localizar millones de recursos de manera eficiente. Las URL pueden referenciar archivos HTML, hojas de estilo CSS, código, binarios, etc.\nLas acciones en HTTP están asociadas a un verbo que indica el objeto de las mismas. Los principales son los siguientes:\n\nGET: Pedir el objeto de la URL al servidor. Es una operación idenpotente, si la repetimos varias veces el resultado debería de ser siempre el mismo. No cambia el estado del servidor. El cuerpo del mensaje está vacio. Cuando descargamos imágenes en Instagram o similares, los comentarios, etc lo hacemos a través de GET.\nPOST: Se utiliza para pedir/enviar un objeto asociado a una URL cuando este depende de los datos de un formulario. Puede cambiar el estado del servidor. Por ejemplo, cuando nos registamos en una página estaríamos haciendo un POST.\nHEAD: Es igual que el GET pero no devuelve nada. Se utiliza para debuguear.\nPUT: Nos permite cargar un objeto en la URL. Es una operación idempotente, si la repetimos varias veces el resultado será siempre el mismo.\nDELETE: Borra el recurso asociado a la URL.\n\nCabe destacar que este uso esperado de los verbos lo tenemos que implementar nosotros. Nada nos quita de hacer que un GET borre cosas, o se utilice para acciones para las que no estaba diseñado. Sin embargo, seguir la especificación nos va a permitir que otros usuarios de nuestra API la puedan utilizar correctamente de una forma más sencilla.\nTodas estas acciones, que en la jerga de HTML se llaman peticiones, tienen asociada una respuesta. Esta respuesta está formada por un código de respuesta, el cuerpo, y cookies. Los códigos de respuesta son un identificador numérico de 3 cifras que indica el resultado de la petición y están asociados a un identificador textual. Se dividen en 5 grupos:\n\n1XX: Respuesta informativa, señalan que la solicitud está siendo procesada.\n2XX: Respuesta satisfactoria, la solicitud se recibió, entendió y se completó con éxito. Por ejemplo, 200 OK.\n3XX: Redirecciones, informan que se necesita tomar una acción adicional para completar la solicitud. Por ejemplo, 301 Moved Permanently: Indica que el recurso se ha movido de forma permanente a una nueva URL.\n4XX: Error en los clientes, indican un error en la solicitud del cliente, como solicitar un recurso inexistente. Por ejemplo, 400 Bad Request, 403 Forbidden o 404 Not Found.\n5XX: Error en los servidores, señalan que el servidor no pudo completar una solicitud debido a un error interno. Por ejemplo, 500 Internal Server Error o 503 Service Unavailable.\n\nDependiendo de la versión de HTTP se utilizarán diferentes tipos de conexión para enviar las peticiones. En HTTP/1.0, se utilizaban conexiones no persistentes, y para cada recurso se creaba una nueva conexión, incurriendo en un retardo de 2 RTT por objeto y la sobrecarga de abrir y cerrar conexiones. A partir de HTTP/1.1, se utilizan conexiones persistentes, donde varios objetos pueden ser enviados en la misma conexión, y por lo tanto, teniendo un retardo de 1 RTT por objeto. La limitación que tenía HTTP/1.1, es que si uno de los recursos tardaba mucho, ralentizaba a los que iban detrás. Para solucionar este problema se utilizan múltiples streams independientes sobre una conexión, solucionando el problema de que un recurso bloquee a los posteriores.\n\n\n\n\n\nHTTP no persistente\n\n\n\n\n\n\nHTTP persistente\n\n\n\n\nPor último, tiene un mecanismo adicional, las cookies que permiten guardar información en forma de pares de clave valor en el cliente. Las cookies se pueden configurar utilizando el campo de respuesta de la petición. En general se utilizan para mantener sesiones, personalización, análisis o con fines publicitarios. Estas cookies pueden ser propias, cuando es de la web que estamos navegando, o de terceros, cuando es un servicio que utiliza la web. Además del par de clave valor, también incluyen una fecha de expiración y del dominio del servidor. Las cookies expiran cuando pasa la fecha de expiración, aunque también pueden ser permanentes. El dominio es por seguridad, ya que determinadas cookies sólo queremos que sean accedidas por su dominio, con el fin de evitar suplantaciones de identidad.\nExiste una variante de HTTP denominada HTTPS (Secure HyperText Transfer Protocol) en la cual las peticiones y sus respuestas no van en texto plano y se ha convertido en el estándar de la Web. De hecho algunos navegadores ya no dejan acceder a sitios a través de HTTP.\nEl protocolo opera generalmente sobre TCP, pero a partir de HTTP/3 opera sobre QUIC, que es un protocolo que implementa mecanismos de comunicación fiables sobre UDP. HTTP/3 está soportado por la gran mayoría de los navegadores actuales, y el soporte en los servidores está creciendo.\nEn determinadas situaciones para disminuir el tiempo de las peticiones se utilizan servidores proxy. Los servidores proxy son unos intermediarios, que analizan las peticiones, si pueden resolverlas ellos contestan directamente, y si no contestan a través de la petición al servidor. Las ventajas es que se obtiene una navegación más rápida, se reduce el tráfico, y además ganamos seguridad y anonimato. Suelen estar localizados en los navegadores (caché local), ISP o CDNs. En concreto, los servidores proxy cachean las peticiones GET, ya que es una operación idempotente, y utilizan la herramienta del GET condicional donde en caso de que no haya actualización no devuelve nada, ahorrando el tiempo de envío del recurso.\n\n\nDNS\nDNS (Domain Name System) es uno de los protocolos más importantes de Internet. El objetivo de DNS es simple, traducir identificadores textuales que sean fácil de recordar por humanos a direcciones IP. Por ejemplo, traducir “www.google.es” a 142.250.200.67. El sistema de DNS está diseñado como un sistema distribuido sin servidores centrales, lo que le permite distribuir la carga entre diferentes nodos y ser tolerante a fallos.\nEl sistema distribuido de DNS está formado por una estructura jerárquica de 4 tipos de nodos:\n\nServidores raíz: Son las raíces de la jerarquía DNS y representan el nivel más alto del sistema. Existen 13 servidores raíz lógicos identificados con letras de la A a la M (a.root-servers.net hasta m.root-servers.net), aunque físicamente hay cientos de servidores distribuidos. Estos servidores conocen la ubicación de todos los servidores TLD y responden a consultas sobre dónde encontrar información de dominios de nivel superior.\nServidores TLD (Top Domain Level): Son responsables de los dominios de nivel superior como .com, .org, .net, .edu, y los dominios de país como .es, .mx, .ar. Mantienen información sobre qué servidores autoritativos son responsables de cada dominio específico dentro de su TLD.\nServidores autoritativos: Contienen la información definitiva y oficial sobre un dominio específico. Son los que tienen la autoridad final sobre las zonas DNS que administran y proporcionan las respuestas definitivas sobre las direcciones IP de los hosts dentro de su dominio.\nServidores locales: También llamados servidores recursivos o resolvers, son los que reciben las consultas directamente de los clientes (como tu computadora). Se encargan de realizar todo el proceso de resolución consultando a los diferentes niveles de la jerarquía DNS hasta obtener la respuesta final, que luego envían de vuelta al cliente. Suelen mantener una caché para mejorar la eficiencia.\n\nPara entender el proceso vamos a realizar un ejemplo de cómo sería la consulta para resolver la URL www.google.es a una IP con DNS. El diagrama de secuencia lo podéis ver en la Figura 6.5. Los pasos para la resolución del DNS son los siguientes:\n\nVerificación de caché local del sistema operativo: Cuando escribes una URL en tu navegador, el sistema operativo primero verifica su caché local para ver si ya tiene almacenada la dirección IP correspondiente. Si la encuentra y no ha expirado, la utiliza inmediatamente sin necesidad de hacer consultas externas.\nConsulta al servidor DNS local: Si la información no está en caché o ha expirado, el cliente envía una consulta al servidor DNS configurado (generalmente proporcionado por tu ISP o servicios como 8.8.8.8 de Google). Esta consulta es recursiva, lo que significa que el cliente espera una respuesta completa.\nEl servidor DNS local consulta al servidor raíz: El servidor DNS local, al no tener la información solicitada, inicia el proceso de resolución consultando a uno de los 13 servidores raíz. Le pregunta: “¿Quién maneja el dominio de nivel superior de este nombre?”\nRespuesta del servidor raíz: El servidor raíz no conoce la dirección IP específica, pero sí sabe qué servidor TLD maneja ese tipo de dominio (.com, .org, .es, etc.). Responde con la dirección del servidor TLD apropiado.\nConsulta al servidor TLD: El servidor DNS local ahora consulta al servidor TLD correspondiente preguntando: “¿Qué servidor autoritativo maneja este dominio específico?”\nRespuesta del servidor TLD: El servidor TLD responde con la información del servidor autoritativo responsable del dominio consultado. Por ejemplo, si buscas www.ejemplo.com, te dirá cuál es el servidor autoritativo para ejemplo.com.\nConsulta al servidor autoritativo: Finalmente, el servidor DNS local consulta al servidor autoritativo del dominio, que tiene la información definitiva sobre todos los registros de ese dominio.\nRespuesta del servidor autoritativo: El servidor autoritativo responde con la dirección IP correspondiente al nombre solicitado (registro A) o la información solicitada según el tipo de consulta.\nRespuesta final al cliente: El servidor DNS local almacena la respuesta en su caché (con un tiempo de vida o TTL específico) y envía la dirección IP al cliente que originó la consulta.\n\n\n\n\n\n\n\nFigura 6.5: Proceso de resolución DNS\n\n\n\n\n\nSMTP, IMAP y POP\nLos protocolos SMTP, IMAP y POP son protocolos que definen el funcionamiento del correo electrónico tal y como lo conocemos hoy en día. Cada uno tiene un propósito específico en el proceso de envío, almacenamiento y recuperación de mensajes.\nSMTP es el protocolo estándar para el envío de correos electrónicos a través de Internet. Funciona como un servicio de entrega que transporta mensajes desde el cliente de correo del remitente hasta el servidor de correo del destinatario. Es un protocolo “push”, empuja los mensajes desde el origen hacia el destino, y no maneja la recepción de los correos.\nPOP, especialmente POP3 (la versión más actual), es un protocolo para descargar correos electrónicos desde el servidor al dispositivo local. POP descarga los mensajes completos al dispositivo local, y por defecto, los elimina los mensajes del servidor tras la descarga. Es ideal para usuarios que acceden al correo desde un único dispositivo, pero presenta limitaciones para sincronización entre múltiples dispositivos\nIMAP es un protocolo más moderno que permite acceder a los correos electrónicos manteniendo la sincronización entre el servidor y múltiples clientes. Los mensajes permanecen en el servidor y permite sincronización en tiempo real entre dispositivos. Soporta carpetas, etiquetas y búsquedas en el servidor. Es ideal para usuarios que acceden al correo desde múltiples dispositivos\n\n\nQUIC\nQUIC representa una evolución revolucionaria en los protocolos de transporte de Internet, desarrollado inicialmente por Google en 2012 y estandarizado por la IETF en 2021 como RFC 9000. Este protocolo moderno construido sobre UDP combina las mejores características de TCP con la seguridad integrada de TLS 1.3, eliminando muchas de las limitaciones históricas de los protocolos tradicionales. Sus principales ventajas incluyen el multiplexado nativo de streams sin el problema de head-of-line blocking que afecta a HTTP/2 sobre TCP, el establecimiento de conexiones con latencia cero (0-RTT) para reconexiones, y la capacidad única de migración de conexión que permite a los dispositivos cambiar transparentemente entre redes WiFi y móviles sin interrumpir las sesiones activas. Además, QUIC incorpora algoritmos de control de congestión más sofisticados y mecanismos de corrección de errores (Forward Error Correction) que mejoran significativamente el rendimiento en condiciones de red inestables o con alta pérdida de paquetes.\nLos casos de uso de QUIC son especialmente relevantes en aplicaciones que requieren baja latencia y alta confiabilidad, siendo adoptado masivamente por servicios de streaming, aplicaciones de videoconferencia, juegos en línea, y plataformas de contenido como YouTube, donde Google reporta reducciones de hasta 30% en tiempo de carga. Su adopción en 2025 ha alcanzado cifras impresionantes: el 8.2% de todos los sitios web globalmente utilizan QUIC, mientras que HTTP/3 (que funciona exclusivamente sobre QUIC) es empleado por el 31.1% de los sitios web.",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html#servicios",
    "href": "ch/part_networks/application_layer/application_layer.html#servicios",
    "title": "6  Capa de aplicación",
    "section": "6.4 Servicios",
    "text": "6.4 Servicios\n\nCDNs\nLas CDN funcionan mediante una red distribuida de servidores edge ubicados estratégicamente en diferentes regiones geográficas, que almacenan copias del contenido desde los servidores origen para reducir la distancia física que deben recorrer los datos hasta llegar al usuario final. El sistema utiliza enrutamiento inteligente que automáticamente dirige cada solicitud al servidor más cercano disponible, típicamente reduciendo la latencia de carga de 200-500ms a menos de 50ms. La estrategia de caché varía según el tipo de contenido: archivos estáticos como imágenes, vídeos y assets de aplicaciones se almacenan por períodos prolongados (días o semanas), mientras que contenido dinámico como respuestas de APIs se cachea por minutos u horas con validación frecuente. Para contenido personalizado, las CDN implementan técnicas de caché parcial donde elementos comunes se reutilizan entre usuarios, y para streaming en tiempo real dividen el contenido en pequeños segmentos que pueden cachearse individualmente.\nMás allá de la simple entrega de contenido, las CDN modernas actúan como una capa de protección y optimización que incluye compresión automática de archivos, conversión de formatos de imagen según el dispositivo del usuario, y balanceado de carga inteligente que redistribuye el tráfico cuando algún servidor se sobrecarga. En aplicaciones como videojuegos, las CDN aceleran la descarga de actualizaciones y assets mediante técnicas de pre-carga predictiva, mientras que para aplicaciones web ejecutan código simple directamente en los servidores edge para personalización básica sin necesidad de consultar el servidor origen. La arquitectura distribuida proporciona resistencia natural contra caídas de servicio y ataques DDoS, ya que el tráfico malicioso se dispersa automáticamente entre múltiples ubicaciones, y sistemas de monitoreo en tiempo real pueden redirigir usuarios desde servidores con problemas hacia alternativas saludables, manteniendo la disponibilidad del servicio incluso durante fallas regionales o ataques coordinados",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_networks/application_layer/application_layer.html#footnotes",
    "href": "ch/part_networks/application_layer/application_layer.html#footnotes",
    "title": "6  Capa de aplicación",
    "section": "",
    "text": "Dos máquinas pueden tener diferente endianness (orden de bytes): big-endian almacena el byte más significativo primero, mientras que little-endian lo guarda al final. Los protocolos de red usan network byte order (big-endian) para garantizar que ambas máquinas interpreten los datos correctamente, independientemente de su arquitectura interna.↩︎\nEn realidad son para sistemas distribuidos. Pero las aplicaciones de red son inherentemente sistemas distribuidos.↩︎",
    "crumbs": [
      "Introducción a redes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Capa de aplicación</span>"
    ]
  },
  {
    "objectID": "ch/part_client/part_intro_htmlcssjs.html",
    "href": "ch/part_client/part_intro_htmlcssjs.html",
    "title": "Desarrollo en el lado del cliente",
    "section": "",
    "text": "Una vez comprendidos los fundamentos de las redes de comunicación, es momento de adentrarnos en el desarrollo del lado del cliente, donde JavaScript emerge como el lenguaje fundamental para crear aplicaciones web interactivas. En esta parte del curso, comenzaremos dominando los conceptos esenciales de JavaScript, desde sus fundamentos básicos como variables, tipos de datos y estructuras de control, hasta aspectos más avanzados como la programación orientada a objetos, la manipulación del DOM y la gestión de eventos.\nUna vez establecidas las bases de JavaScript, exploraremos HTML y CSS, las tecnologías que definen la estructura y presentación de las páginas web. HTML nos permitirá crear los contenedores y elementos de interfaz necesarios para nuestros juegos, mientras que CSS controlará su apariencia visual. Este conocimiento combinado será crucial para desarrollar la interfaz de nuestros juegos en red y para comprender cómo el cliente interactúa con los servicios del servidor en un entorno multijugador.",
    "crumbs": [
      "Desarrollo en el cliente",
      "Desarrollo en el lado del cliente"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html",
    "href": "ch/part_client/js/js.html",
    "title": "7  JavaScript",
    "section": "",
    "text": "7.1 Introducción\nJavaScript es un lenguaje de programación que permite incorporar interactividad en las páginas web, lo que lo convierte en una herramienta fundamental para el desarrollo de videojuegos web. Con JavaScript se puede modificar la página y ejecutar código cuando se interactúa con ella a través del modelo de objetos del documento (DOM). También se pueden hacer peticiones al servidor web en segundo plano y actualizar el contenido de la web con los resultados (AJAX).",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#introducción",
    "href": "ch/part_client/js/js.html#introducción",
    "title": "7  JavaScript",
    "section": "",
    "text": "Características de JavaScript\nJavaScript es un lenguaje de programación basado en el estándar ECMAScript de ECMA (una organización diferente al W3C). Aunque en el pasado existían diferencias significativas en la implementación de JavaScript entre navegadores, actualmente todos son bastante compatibles entre sí.\n\n\nVersiones de ECMAScript\nES5 (2011): La versión del estándar que popularizó el lenguaje ECMAScript fue la 5.1 (2011), aunque generalmente se la conoce como ES5. Prácticamente todos los navegadores modernos soportan la mayoría de las características definidas en el estándar 5.1.\nES2015 (ES6): En junio 2015 finalizó el desarrollo de ES6 con una evolución importante del lenguaje. A última hora decidieron llamarle oficialmente ES2015. Está soportada casi al completo por casi todos los navegadores modernos. Introdujo características fundamentales como clases, módulos, arrow functions y promises.\nVersiones actuales: Desde ES2015, ECMAScript sigue un ciclo de actualizaciones anuales con compatibilidad hacia atrás:\n\nECMAScript 2016-2024 (versiones 7-15)\nCada versión añade nuevas características manteniendo compatibilidad\nLos navegadores modernos soportan características hasta ES2023\n\n\n\nJavaScript vs Java\nAunque algunos elementos de la sintaxis recuerden a Java, son lenguajes completamente diferentes. El nombre JavaScript se eligió al publicar el lenguaje en una época en la que Java estaba en auge y fue principalmente por marketing (inicialmente se llamó LiveScript).\n\n\nCaracterísticas principales de JavaScript\nScripting: No necesita compilador. Inicialmente era un lenguaje interpretado, pero actualmente se ejecuta en máquinas virtuales en los navegadores, proporcionando mayor velocidad de ejecución y eficiencia de memoria.\nTipado dinámico: Habitual en los lenguajes de script. Las variables no requieren declaración de tipo.\nFuncional: Las funciones son elementos de primer orden, pueden asignarse a variables y pasarse como parámetros.\nOrientado a objetos: Basado en prototipos, no en clases como Java, C++, Ruby, aunque ES2015 introdujo una sintaxis de clases más familiar.\n\n\nDOM y BOM\nEl navegador web proporciona al JavaScript dos APIs fundamentales para interactuar con la página y el entorno del navegador. Entender la diferencia entre estas dos es crucial para el desarrollo de videojuegos web.\nDOM (Document Object Model): Es una representación en forma de árbol del documento HTML cargado en el navegador. Cada elemento HTML (divs, canvas, botones, etc.) se convierte en un objeto que JavaScript puede manipular. Para videojuegos, el DOM es esencial para:\n\nAcceder al elemento &lt;canvas&gt; donde se renderiza el juego\nCrear y manipular elementos de la interfaz de usuario (menús, HUD, puntuaciones)\nGestionar eventos de entrada del usuario (clicks, teclas presionadas, movimientos del ratón)\nModificar estilos CSS dinámicamente (pantallas de carga, efectos visuales)\nInsertar y eliminar elementos HTML en tiempo real (mensajes, notificaciones)\n\nBOM (Browser Object Model): Proporciona acceso a funcionalidades del navegador más allá del documento HTML. El BOM incluye al DOM como uno de sus componentes, pero añade capacidades adicionales críticas para videojuegos:\n\nwindow: El objeto global que representa la ventana del navegador\n\nControl del tamaño de la ventana\nDetección de cambio de tamaño (responsive design)\nGestión del foco de la ventana (pausar el juego cuando se cambia de pestaña)\n\nnavigator: Información sobre el navegador y el dispositivo\n\nDetección de características soportadas (WebGL, audio, gamepad)\nInformación del sistema operativo y navegador\nAcceso a la geolocalización y otros sensores\n\nlocation: Control de la URL actual\n\nNavegación entre diferentes pantallas del juego\nGestión del historial del navegador\n\nlocalStorage/sessionStorage: Almacenamiento persistente de datos\n\nGuardar progreso del jugador\nAlmacenar configuraciones y preferencias\n\nfetch/XMLHttpRequest: Comunicación con servidores\n\nCargar recursos del juego dinámicamente\nEnviar y recibir datos de partidas multijugador\nComunicación con APIs REST\n\nconsole: Herramienta de debugging\n\nLogging de errores y mensajes de debug\nMedición de rendimiento del juego\n\n\nEn resumen: el DOM se centra en el contenido de la página HTML, mientras que el BOM proporciona acceso a todas las capacidades del navegador. Para videojuegos web, ambos son fundamentales y trabajan juntos para crear experiencias interactivas completas.\n\n\nLibrerías y Frameworks JavaScript\nExisten multitud de bibliotecas JavaScript para el desarrollo de aplicaciones de videojuegos:\nBibliotecas de propósito general:\n\nLodash: Biblioteca moderna que reemplaza a underscore.js para trabajar con estructuras de datos con un enfoque funcional\nAxios: Cliente HTTP moderno que reemplaza las peticiones AJAX tradicionales\n\nFrameworks para videojuegos:\n\nPhaser: Framework completo para desarrollo de juegos 2D\nThree.js: Biblioteca para gráficos 3D y WebGL\nBabylon.js: Motor 3D completo para juegos web\nPixiJS: Renderizador 2D de alta performance\n\nFrameworks de aplicación moderna:\n\nReact: Biblioteca para interfaces de usuario componentizadas\nVue.js: Framework progresivo para aplicaciones web\nAngular: Framework completo para aplicaciones de gran escala",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#configuración-del-entorno-de-desarrollo-con-node.js",
    "href": "ch/part_client/js/js.html#configuración-del-entorno-de-desarrollo-con-node.js",
    "title": "7  JavaScript",
    "section": "7.2 Configuración del Entorno de Desarrollo con Node.js",
    "text": "7.2 Configuración del Entorno de Desarrollo con Node.js\n\nIntroducción a Node.js\nNode.js es un entorno de ejecución para JavaScript construido sobre el motor V8 de Chrome. Permite ejecutar JavaScript fuera del navegador y se ha convertido en el estándar para el desarrollo de aplicaciones JavaScript modernas.\n\n\nInstalación de Node.js\n\nDescargar Node.js: Visita nodejs.org y descarga la versión LTS (Long Term Support)\nVerificar instalación: Abre una terminal y ejecuta:\nnode --version\nnpm --version\n\n\n\nGestión de Paquetes con npm\nnpm (Node Package Manager) es el gestor de paquetes oficial de Node.js que permite instalar y gestionar dependencias.\n# Verificar versión de npm\nnpm --version\n\n# Actualizar npm\nnpm install -g npm@latest\n\n# Obtener ayuda\nnpm help\n\n\nCreación de un Proyecto\n\nInicializar un proyecto\nTodo proyecto de JavaScript moderno comienza con la inicialización de npm, que crea el archivo de configuración principal del proyecto. Este archivo, llamado package.json, actúa como el “documento de identidad” del proyecto, describiendo sus características, dependencias y comandos de ejecución.\n# Crear directorio del proyecto\nmkdir mi-juego-web\ncd mi-juego-web\n\n# Inicializar proyecto npm\nnpm init -y\nEl comando npm init -y crea automáticamente el archivo package.json con valores por defecto. La opción -y (yes) acepta todas las opciones por defecto sin preguntar, acelerando el proceso. Si omitimos -y, npm nos hará preguntas interactivas sobre cada campo.\nEsto crea un archivo package.json que podemos personalizar para nuestro videojuego:\n{\n  \"name\": \"mi-juego-web\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Un videojuego web desarrollado en JavaScript\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"start\": \"node server.js\",\n    \"dev\": \"webpack serve --mode development\",\n    \"build\": \"webpack --mode production\"\n  },\n  \"keywords\": [\"juego\", \"javascript\", \"web\"],\n  \"author\": \"Tu Nombre\",\n  \"license\": \"MIT\"\n}\nExplicación de cada campo del package.json:\n\nname: Identificador único del proyecto. Debe ser en minúsculas, sin espacios (usar guiones). Este nombre se usa si publicamos el proyecto en npm. Para nuestro videojuego, elegimos un nombre descriptivo como “mi-juego-web”.\nversion: Número de versión siguiendo el formato semántico (semantic versioning): MAJOR.MINOR.PATCH. Comenzamos en “1.0.0” y actualizamos según los cambios: cambios mayores incrementan el primer número, nuevas características el segundo, y correcciones de bugs el tercero.\ndescription: Texto breve que explica qué es el proyecto. Útil cuando otros desarrolladores encuentren nuestro código o cuando busquemos proyectos en npm. Para videojuegos, describimos el género o concepto del juego.\nmain: Punto de entrada principal del proyecto. Indica qué archivo JavaScript se ejecuta cuando alguien importa nuestro proyecto. Para videojuegos web, típicamente apunta al archivo principal del juego en src/index.js o src/main.js.\nscripts: Objeto que define comandos personalizados que podemos ejecutar con npm run &lt;nombre&gt;. Estos scripts automatizan tareas comunes:\n\n\"start\": Comando para ejecutar el proyecto en producción\n\"dev\": Inicia el servidor de desarrollo con recarga automática\n\"build\": Genera los archivos optimizados para producción\n\nEjecutamos estos scripts con npm start, npm run dev, o npm run build.\nkeywords: Array de palabras clave que describen el proyecto. Útil para que otros encuentren el proyecto si lo publicamos en npm. Para videojuegos, incluimos términos como el género, tecnologías usadas, etc.\nauthor: Nombre del creador o equipo de desarrollo. Puede incluir email: \"Tu Nombre &lt;email@ejemplo.com&gt;\".\nlicense: Tipo de licencia del código. “MIT” es una licencia permisiva común para proyectos open source. Otras opciones populares son “GPL-3.0”, “Apache-2.0”, o “UNLICENSED” para proyectos privados.\n\n\n\nEstructura de carpetas recomendada\nmi-juego-web/\n├── package.json\n├── webpack.config.js\n├── src/\n├── dist/\n└── public/\n    └── index.html\n\n\n\nInstalación de Dependencias\nEl sistema de gestión de paquetes de npm nos permite instalar bibliotecas y herramientas desarrolladas por la comunidad, evitando tener que escribir todo el código desde cero. En el desarrollo de videojuegos, esto es especialmente valioso porque podemos aprovechar engines de juegos, bibliotecas de física, sistemas de audio y muchas otras funcionalidades ya probadas y optimizadas.\nLas dependencias se dividen en dos categorías principales: las de producción (que forman parte del juego final) y las de desarrollo (que solo usamos durante el proceso de creación).\n\nDependencias de producción\nEstas son las bibliotecas que formarán parte de nuestro juego final y que los jugadores descargarán:\n# Framework de juegos\nnpm install phaser\n\n# Utilidades\nnpm install lodash\n\n# Cliente HTTP\nnpm install axios\n\n\nDependencias de desarrollo\nLas herramientas de desarrollo nos ayudan durante el proceso de creación del juego, pero no se incluyen en la versión final que descargan los jugadores. Estas incluyen herramientas para optimizar código, servir archivos durante el desarrollo, y verificar la calidad del código:\n# Bundler y servidor de desarrollo\nnpm install --save-dev webpack webpack-cli webpack-dev-server\n\n# Loaders para recursos\nnpm install --save-dev html-webpack-plugin css-loader style-loader file-loader\n\n# Herramientas de desarrollo\nnpm install --save-dev eslint prettier\n\n\n\nConfiguración de Webpack\nWebpack es una herramienta fundamental en el desarrollo moderno de JavaScript que actúa como empaquetador de módulos (bundler). Su función principal es tomar todos los archivos JavaScript, CSS, imágenes y otros recursos de nuestro proyecto y crear uno o varios archivos optimizados para el navegador.\nEn el contexto del desarrollo de videojuegos, Webpack nos permite organizar nuestro código en múltiples archivos (clases para jugadores, enemigos, sistemas de audio, etc.) y luego combinarlos en un solo paquete eficiente. También puede optimizar imágenes, procesar archivos de audio y gestionar otros recursos del juego. Además, Webpack incluye un servidor de desarrollo con recarga automática que facilita enormemente el proceso de desarrollo.\nPara configurar Webpack en nuestro proyecto de videojuego, creamos un archivo webpack.config.js en la raíz del proyecto:\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n    clean: true\n  },\n  mode: 'development',\n  devtool: 'inline-source-map',\n  devServer: {\n    static: './dist',\n    hot: true,\n    port: 8080\n  },\n  externals: {\n    phaser: 'Phaser'\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n      inject: false\n    })\n  ],\n  resolve: {\n    extensions: ['.js']\n  }\n};\nExplicación detallada de cada sección del webpack.config.js:\nImportaciones iniciales:\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\npath: Módulo de Node.js para trabajar con rutas de archivos de forma independiente del sistema operativo. Garantiza que las rutas funcionen tanto en Windows como en Mac/Linux.\nHtmlWebpackPlugin: Plugin que genera automáticamente el archivo HTML final incluyendo las referencias a los archivos JavaScript generados.\n\nPunto de entrada (entry):\nentry: './src/main.js',\nEspecifica el archivo JavaScript principal desde donde Webpack comienza a construir el grafo de dependencias del proyecto. Webpack analiza este archivo, encuentra todos los imports/requires, y recursivamente incluye todos los módulos necesarios. Para videojuegos, este suele ser el archivo que inicializa el motor de juego y carga la primera escena.\nConfiguración de salida (output):\noutput: {\n  filename: 'bundle.js',              // Nombre del archivo JavaScript generado\n  path: path.resolve(__dirname, 'dist'),  // Directorio donde se guardan los archivos generados\n  clean: true                          // Limpia el directorio dist antes de cada build\n}\n\nfilename: Nombre del archivo JavaScript final que contendrá todo nuestro código empaquetado y optimizado.\npath: Directorio de salida. __dirname es el directorio actual, 'dist' es donde se guardarán los archivos de producción.\nclean: true: Elimina archivos antiguos antes de generar nuevos, evitando acumulación de builds anteriores.\n\nModo de desarrollo (mode):\nmode: 'development',\nDefine el entorno de ejecución. Puede ser:\n\n'development': Código sin minificar, con nombres de variables legibles, útil para debugging.\n'production': Código minificado y optimizado, menor tamaño, más rápido, pero difícil de debuggear.\n\nHerramientas de debugging (devtool):\ndevtool: 'inline-source-map',\nGenera source maps que permiten debuggear el código original (antes de empaquetarlo) en las DevTools del navegador. Cuando hay un error, el navegador muestra la línea del archivo fuente original en lugar del código empaquetado, facilitando enormemente el debugging.\nServidor de desarrollo (devServer):\ndevServer: {\n  static: './dist',    // Directorio desde donde servir archivos estáticos\n  hot: true,           // Hot Module Replacement - actualiza módulos sin recargar la página\n  port: 8080          // Puerto donde se ejecuta el servidor de desarrollo\n}\nConfigura el servidor web integrado de Webpack:\n\nstatic: Directorio con archivos estáticos (HTML, imágenes, etc.) que el servidor debe servir.\nhot: true: Habilita Hot Module Replacement (HMR), que permite actualizar módulos JavaScript en tiempo real sin recargar toda la página. Muy útil durante desarrollo para mantener el estado del juego.\nport: Puerto donde se ejecutará el servidor (http://localhost:8080).\n\nLibrerías externas (externals):\nexternals: {\n  phaser: 'Phaser'\n}\nIndica a Webpack que ciertas dependencias se cargarán desde fuera del bundle (típicamente desde un CDN). En este caso, Phaser se carga desde un &lt;script&gt; en el HTML en lugar de incluirse en el bundle, reduciendo el tamaño del archivo final. La clave es el nombre del módulo en el código (import Phaser from 'phaser') y el valor es la variable global que expone (window.Phaser).\nPlugins:\nplugins: [\n  new HtmlWebpackPlugin({\n    template: './public/index.html',  // Archivo HTML plantilla\n    inject: false                      // No inyecta automáticamente los scripts\n  })\n]\n\nHtmlWebpackPlugin: Genera el archivo HTML final a partir de una plantilla.\ntemplate: Ruta al archivo HTML base que usará como plantilla.\ninject: false: Desactiva la inyección automática de scripts. Útil cuando queremos control manual sobre dónde y cómo se cargan los scripts en el HTML (por ejemplo, cuando usamos librerías externas como Phaser desde CDN).\n\nResolución de módulos (resolve):\nresolve: {\n  extensions: ['.js']\n}\nDefine qué extensiones de archivo Webpack intentará resolver automáticamente cuando importamos módulos sin especificar extensión. Esto permite escribir import Player from './player' en lugar de import Player from './player.js'. Útil para proyectos grandes donde escribir las extensiones constantemente es tedioso.\n\n\nScripts de Desarrollo\nUna vez configurado Webpack, necesitamos definir comandos que automaticen las tareas más comunes del desarrollo. Los scripts de npm nos permiten crear atajos para ejecutar procesos complejos con comandos simples. Esto es especialmente útil cuando trabajamos en equipo, ya que todos los desarrolladores pueden usar los mismos comandos estándar.\nActualizamos el package.json con scripts útiles para el desarrollo de videojuegos:\n{\n  \"scripts\": {\n    \"dev\": \"webpack serve --mode development --open\",\n    \"build\": \"webpack --mode production\",\n    \"lint\": \"eslint src/\",\n    \"format\": \"prettier --write src/\"\n  }\n}",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#el-lenguaje-javascript",
    "href": "ch/part_client/js/js.html#el-lenguaje-javascript",
    "title": "7  JavaScript",
    "section": "7.3 El Lenguaje JavaScript",
    "text": "7.3 El Lenguaje JavaScript\n\nCaracterísticas del Lenguaje\nLa mayoría de las características que se van a repasar están disponibles desde JavaScript ES5, aunque las versiones más recientes ofrecen mejoras significativas. Las versiones más recientes pueden presentar problemas de compatibilidad con navegadores muy antiguos, pero esto no es una preocupación para el desarrollo moderno.\n\n\nImperativo y Estructurado\nJavaScript mantiene las características imperativas familiares para programadores de Java y C:\n\nSe declaran variables\nSe ejecutan las sentencias en orden\nDispone de sentencias de control de flujo (if, while, for…)\nLa sintaxis imperativa/estructurada es muy parecida a Java y C\n\n\n\nLenguaje de Script\n\nNo existe compilador (aunque se usan transpiladores como Babel para compatibilidad)\nEl navegador carga el código, lo analiza y lo ejecuta\nEl navegador indica tanto errores de sintaxis como errores de ejecución\nLos motores modernos (V8, SpiderMonkey) incluyen compilación JIT para optimización\n\n\n\nTipado Dinámico\n\nAl declarar una variable no se indica su tipo\nA lo largo de la ejecución del programa una misma variable puede tener valores de diferentes tipos\nEsto proporciona flexibilidad pero requiere más cuidado en el desarrollo\n\n\n\nOrientado a Objetos\n\nTodos los valores a excepción de los tipos primitivos son objetos,\nSin embargo, a diferencia de Java, el boxing es automático.\nExiste recolector de basura para liberar la memoria automáticamente\nLa orientación a objetos está basada en prototipos, aunque ES2015+ añadió sintaxis de clases\nEn tiempo de ejecución se pueden crear objetos, cambiar atributos e invocar métodos\nEn tiempo de ejecución se pueden añadir y borrar atributos y métodos dinámicamente\n\n\n\nFunciones como Ciudadanos de Primera Clase\n\nAunque sea orientado a objetos, también permite declarar funciones independientes\nLas funciones se pueden declarar en cualquier sitio, asignarse a variables y pasarse como parámetro\nExisten funciones anónimas y arrow functions\nEn JavaScript se puede implementar código siguiendo el paradigma funcional\n\n\n\nModo Estricto\nLas primeras versiones de JavaScript permitían escribir código que posteriormente se consideró propenso a errores. ES5 definió un modo estricto que genera errores para código problemático.\nPara activar el modo estricto (recomendable) basta poner al principio del código:\n\"use strict\";\nEn módulos ES2015+, el modo estricto está activado por defecto.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#integración-con-html",
    "href": "ch/part_client/js/js.html#integración-con-html",
    "title": "7  JavaScript",
    "section": "7.4 Integración con HTML",
    "text": "7.4 Integración con HTML\n\nInclusión de JavaScript\nEl código JavaScript se puede incluir directamente en el documento HTML en etiquetas &lt;script&gt;, pero es recomendable que el código esté en ficheros independientes:\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- Para código que debe ejecutarse antes que el DOM --&gt;\n    &lt;script src=\"js/config.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Contenido HTML --&gt;\n    \n    &lt;!-- Scripts al final para mejor rendimiento --&gt;\n    &lt;script src=\"js/game.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nOptimización de Carga\nUbicación de scripts: Cuando se carga el JavaScript, el navegador bloquea el procesamiento del HTML. Por ello, se recomienda poner los elementos &lt;script&gt; como último elemento de la página.\nAtributos modernos:\n&lt;!-- Carga asíncrona, no bloquea el HTML --&gt;\n&lt;script src=\"js/game.js\" async&gt;&lt;/script&gt;\n\n&lt;!-- Carga diferida, ejecuta después del HTML --&gt;\n&lt;script src=\"js/game.js\" defer&gt;&lt;/script&gt;",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#sintaxis-básica",
    "href": "ch/part_client/js/js.html#sintaxis-básica",
    "title": "7  JavaScript",
    "section": "7.5 Sintaxis Básica",
    "text": "7.5 Sintaxis Básica\n\nMostrar Información\n// Escribir en el documento HTML (poco usado en desarrollo moderno)\ndocument.write('Texto');\n\n// Escribir en la consola del navegador (debugging)\nconsole.log('Información de debug');\nconsole.error('Error crítico');\nconsole.warn('Advertencia');\n\n\nComentarios\n// Comentario de una línea\n\n/*\n * Comentario\n * multilínea\n */\n\n\nDelimitadores\n\nBloques: {}\nSentencias: ; (opcionales pero recomendados)\n\n\n\nVariables\nEn JavaScript moderno, tenemos tres formas de declarar variables, cada una con características específicas que las hacen adecuadas para diferentes situaciones. Esta evolución del lenguaje ha mejorado significativamente la robustez y mantenibilidad del código.\nDeclaraciones modernas (ES2015+):\n// const - valor inmutable, block scope\nconst MAX_LIVES = 3;\nconst GAME_CONFIG = {\n    width: 800,\n    height: 600\n};\n\n// let - valor mutable, block scope\nlet currentLives = MAX_LIVES;\nlet playerPosition = { x: 0, y: 0 };\n\n// var - evitar en código nuevo (function scope)\nvar oldStyle = \"no recomendado\";\nÁmbito de variables:\nEl concepto de ámbito (scope) es fundamental para entender cómo JavaScript maneja las variables. El ámbito determina desde qué partes del código podemos acceder a una variable:\n\nlet y const tienen ámbito de bloque - solo existen dentro del bloque {} donde se declaran\nvar tiene ámbito de función - existe en toda la función donde se declara (puede causar problemas)\nVariables no declaradas se convierten en globales - esto es un error en modo estricto\n\n\n\nTipos de Datos\nJavaScript maneja diferentes tipos de datos que nos permiten representar toda la información necesaria para un videojuego. A diferencia de lenguajes como Java o C++, JavaScript es de tipado dinámico, lo que significa que una variable puede cambiar de tipo durante la ejecución del programa.\nPrimitivos (todos son objetos en JavaScript):\n// Number - enteros y reales\nlet score = 1000;\nlet health = 75.5;\n\n// String - cadenas de caracteres\nlet playerName = \"Jugador1\";\nlet message = 'Game Over';\n\n// Boolean\nlet isGameRunning = true;\nlet isPaused = false;\n\n// Tipos especiales\nlet powerUp = null;           // Ausencia intencional de valor\nlet specialAbility;           // undefined - no inicializada\nTemplate literals (ES2015+):\nLos template literals son una característica moderna de JavaScript que nos permite crear strings de manera más expresiva y legible. Son especialmente útiles en videojuegos para construir mensajes dinámicos, interfaces de usuario y contenido HTML generado dinámicamente:\nlet level = 5;\nlet experience = 1250;\n\n// Interpolación de strings - insertar valores directamente\nlet status = `Nivel ${level} - EXP: ${experience}`;\n\n// Strings multilínea - útil para templates HTML\nlet gameInfo = `\nJugador: ${playerName}\nNivel: ${level}\nPuntuación: ${score}\n`;\n\n\nOperadores\nJavaScript incluye la mayoría de operadores familiares para programadores de otros lenguajes, pero también añade algunos específicos que son importantes conocer para evitar errores comunes.\nSimilares a Java:\nLos operadores aritméticos y lógicos funcionan de manera similar a otros lenguajes de programación:\n// Aritméticos\nlet damage = baseDamage + bonus;\nlet remaining = total - used;\nlet area = width * height;\nlet average = sum / count;\nlet remainder = value % modulo;\n\n// Comparación\nif (health &gt; 0 && mana &gt;= spellCost) {\n    castSpell();\n}\n\n// Lógicos\nlet canAct = isAlive && !isStunned;\nlet shouldRespawn = isDead || health &lt;= 0;\nEspecíficos de JavaScript:\nJavaScript tiene operadores de comparación únicos que es crucial entender para evitar errores sutiles pero problemáticos:\n// Igualdad estricta (recomendado)\nif (playerID === targetID) {\n    // Compara valor y tipo\n}\n\n// Desigualdad estricta\nif (level !== previousLevel) {\n    // Diferentes valor o tipo\n}\n\n// Igualdad débil (evitar)\nif (score == \"100\") {\n    // true - hace conversión de tipos\n}\nOperadores modernos (ES2020+):\nLas versiones recientes de JavaScript han introducido operadores que simplifican patrones comunes de programación y hacen el código más legible y menos propenso a errores:\n// Nullish coalescing - valor por defecto solo para null/undefined\nlet playerName = savedName ?? \"Jugador Anónimo\";\n\n// Optional chaining - acceso seguro a propiedades\nlet weapon = player.inventory?.equipment?.weapon;\n\n// Logical assignment\nplayerName ||= \"Jugador por defecto\";  // solo si falsy\nplayerName ??= \"Valor por defecto\";   // solo si null/undefined",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#arrays",
    "href": "ch/part_client/js/js.html#arrays",
    "title": "7  JavaScript",
    "section": "7.6 Arrays",
    "text": "7.6 Arrays\nLos arrays en JavaScript son estructuras de datos fundamentales para el desarrollo de videojuegos, donde frecuentemente necesitamos manejar listas de enemigos, items del inventario, puntuaciones, coordenadas y muchos otros elementos. Aunque comparten similitudes con los arrays de Java, tienen características únicas que los hacen más flexibles pero también requieren mayor cuidado en su uso.\nLos arrays de JavaScript son dinámicos por naturaleza, pueden contener elementos de diferentes tipos y crecen automáticamente cuando se necesita. Esta flexibilidad es especialmente útil en videojuegos donde las listas de elementos pueden cambiar constantemente durante el juego.\n// Creación de arrays\nlet empty = [];\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [\"texto\", 42, true, null];\nlet inventory = new Array(10); // Array de 10 elementos undefined\n\n// Acceso y modificación\nconsole.log(numbers[0]);        // 1\nnumbers[2] = 999;              // Modifica el elemento\nconsole.log(numbers.length);    // 5\n\n// Arrays pueden crecer dinámicamente\nnumbers[10] = 100;             // Crea huecos con undefined\nconsole.log(numbers.length);    // 11\n\nMétodos de Array Modernos\nLos métodos modernos de arrays en JavaScript son herramientas poderosas que permiten manipular datos de manera más expresiva y funcional. Estos métodos son especialmente útiles en videojuegos donde constantemente necesitamos filtrar enemigos, transformar datos, buscar elementos específicos o procesar listas de objetos del juego.\nEstos métodos siguen un paradigma funcional: no modifican el array original (excepto algunos como push y pop), sino que retornan nuevos arrays o valores. Esto hace el código más predecible y menos propenso a errores:\nlet enemies = [\n    { id: 1, health: 100, type: \"orc\" },\n    { id: 2, health: 50, type: \"goblin\" },\n    { id: 3, health: 0, type: \"orc\" }\n];\n\n// Filtrar elementos\nlet aliveEnemies = enemies.filter(enemy =&gt; enemy.health &gt; 0);\nlet orcs = enemies.filter(enemy =&gt; enemy.type === \"orc\");\n\n// Transformar elementos\nlet healthValues = enemies.map(enemy =&gt; enemy.health);\nlet enemyIds = enemies.map(enemy =&gt; enemy.id);\n\n// Encontrar elementos\nlet firstOrc = enemies.find(enemy =&gt; enemy.type === \"orc\");\nlet orcIndex = enemies.findIndex(enemy =&gt; enemy.type === \"orc\");\n\n// Verificar condiciones\nlet allDead = enemies.every(enemy =&gt; enemy.health === 0);\nlet someDead = enemies.some(enemy =&gt; enemy.health === 0);\n\n// Reducir a un valor\nlet totalHealth = enemies.reduce((sum, enemy) =&gt; sum + enemy.health, 0);\n\n// Modificar array\nenemies.push({ id: 4, health: 75, type: \"troll\" });    // Añadir al final\nlet firstEnemy = enemies.shift();                       // Quitar del inicio\nlet lastEnemy = enemies.pop();                          // Quitar del final\n\n// Eliminar/insertar elementos\nenemies.splice(1, 2);                 // Eliminar 2 elementos desde índice 1\nenemies.splice(1, 0, newEnemy);       // Insertar en índice 1\n\n\nDestructuring de Arrays (ES2015+)\nEl destructuring es una característica moderna que nos permite extraer valores de arrays de manera más concisa y legible. Es especialmente útil cuando trabajamos con coordenadas, vectores o cualquier conjunto de valores relacionados que se almacenan en arrays:\nlet coordinates = [100, 200];\nlet [x, y] = coordinates;  // x = 100, y = 200\n\nlet [first, second, ...rest] = inventory;  // Rest operator",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#sentencias-de-control-de-flujo",
    "href": "ch/part_client/js/js.html#sentencias-de-control-de-flujo",
    "title": "7  JavaScript",
    "section": "7.7 Sentencias de Control de Flujo",
    "text": "7.7 Sentencias de Control de Flujo\nLas sentencias de control de flujo en JavaScript son fundamentales para implementar la lógica de nuestros videojuegos. Nos permiten tomar decisiones, repetir acciones y controlar el comportamiento del juego basándose en diferentes condiciones como el estado del jugador, la fase del juego o las acciones del usuario.\n\nSentencias Básicas\nJavaScript utiliza una sintaxis muy similar a Java y C para las estructuras de control, lo que facilita la transición desde otros lenguajes de programación:\n// if - else\nif (health &gt; 50) {\n    statusColor = \"green\";\n} else if (health &gt; 20) {\n    statusColor = \"yellow\";\n} else {\n    statusColor = \"red\";\n}\n// switch\nswitch (gameState) {\n    case \"menu\":\n        showMenu();\n        break;\n    case \"playing\":\n        updateGame();\n        break;\n    case \"paused\":\n        showPauseScreen();\n        break;\n    default:\n        handleUnknownState();\n}\n// Loops\nfor (let i = 0; i &lt; enemies.length; i++) {\n    updateEnemy(enemies[i]);\n}\n\n// for...of - iterar valores (ES2015+)\nfor (let enemy of enemies) {\n    updateEnemy(enemy);\n}\n\n// for...in - iterar propiedades\nfor (let key in gameConfig) {\n    console.log(key, gameConfig[key]);\n}\n\n// while\nwhile (isGameRunning && playerLives &gt; 0) {\n    processGameFrame();\n}\n\n\nValores Falsy\nUn concepto importante en JavaScript es el de valores “falsy”. JavaScript es más permisivo que otros lenguajes al evaluar condiciones booleanas, y automáticamente convierte ciertos valores a false en contextos booleanos. Esto puede ser tanto útil como fuente de errores si no se comprende bien.\nJavaScript considera falso: false, null, undefined, \"\" (cadena vacía), 0, NaN\n// Verificación de existencia\nif (player.weapon) {\n    // weapon existe y no es falsy\n    player.attack();\n}\n\n// Valores por defecto\nlet playerName = inputName || \"Jugador Anónimo\";",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#funciones",
    "href": "ch/part_client/js/js.html#funciones",
    "title": "7  JavaScript",
    "section": "7.8 Funciones",
    "text": "7.8 Funciones\nLas funciones son uno de los conceptos más importantes en JavaScript, especialmente para el desarrollo de videojuegos donde necesitamos organizar el código en bloques reutilizables y manejables. JavaScript trata las funciones como “ciudadanos de primera clase”, lo que significa que pueden almacenarse en variables, pasarse como argumentos a otras funciones y retornarse como valores.\nEsta flexibilidad es especialmente valiosa en videojuegos, donde frecuentemente necesitamos sistemas de callbacks para eventos, funciones que generen comportamientos aleatorios, o sistemas de actualización que procesen diferentes tipos de objetos del juego.\n\nDeclaración de Funciones\nJavaScript ofrece varias formas de declarar funciones, cada una con sus propias características y casos de uso apropiados:\n// Declaración tradicional\nfunction calculateDamage(baseDamage, criticalHit) {\n    if (criticalHit) {\n        return baseDamage * 2;\n    }\n    return baseDamage;\n}\n\n// Expresión de función\nlet heal = function(amount) {\n    player.health += amount;\n    if (player.health &gt; player.maxHealth) {\n        player.health = player.maxHealth;\n    }\n};\n\n// Arrow functions (ES2015+)\nlet movePlayer = (deltaX, deltaY) =&gt; {\n    player.x += deltaX;\n    player.y += deltaY;\n};\n\n// Arrow function con una expresión\nlet isAlive = (entity) =&gt; entity.health &gt; 0;\n\n// Arrow function sin parámetros\nlet generateRandomID = () =&gt; Math.random().toString(36);\n\n\nParámetros de Función\nJavaScript es muy flexible en el manejo de parámetros de función, ofreciendo características modernas que simplifican el código y lo hacen más robusto. Esta flexibilidad es especialmente útil en videojuegos donde las funciones pueden necesitar comportamientos adaptativos según diferentes contextos de juego:\n// Parámetros por defecto (ES2015+)\nfunction createEnemy(health = 100, damage = 10) {\n    return { health, damage };\n}\n\n// Rest parameters (ES2015+)\nfunction logMessage(level, ...messages) {\n    console.log(`[${level}]`, ...messages);\n}\n\n// Destructuring de parámetros\nfunction updatePosition({ x, y }, { deltaX, deltaY }) {\n    return { x: x + deltaX, y: y + deltaY };\n}\n\n\nClosures y Scope\nLos closures (clausuras) son un concepto avanzado pero fundamental en JavaScript que permite a las funciones “recordar” el entorno en el que fueron creadas. En el contexto de videojuegos, los closures son especialmente útiles para crear sistemas como contadores de puntuación, generadores de identificadores únicos, o sistemas de estado que mantienen información privada.\nUn closure se forma cuando una función interna hace referencia a variables de su función externa, y esa función interna se utiliza fuera de su contexto original. La función interna “cierra” sobre las variables del ámbito externo, manteniéndolas vivas incluso después de que la función externa haya terminado de ejecutarse:\nfunction createCounter(initialValue = 0) {\n    let count = initialValue;\n    \n    return {\n        increment: () =&gt; ++count,\n        decrement: () =&gt; --count,\n        getValue: () =&gt; count\n    };\n}\n\nlet scoreCounter = createCounter(0);\nscoreCounter.increment(); // 1\nscoreCounter.increment(); // 2\nconsole.log(scoreCounter.getValue()); // 2",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#manejo-de-excepciones",
    "href": "ch/part_client/js/js.html#manejo-de-excepciones",
    "title": "7  JavaScript",
    "section": "7.9 Manejo de Excepciones",
    "text": "7.9 Manejo de Excepciones\nEl manejo de excepciones en JavaScript funciona de manera muy similar a Java, utilizando los bloques try, catch y finally. En el desarrollo de videojuegos, el manejo adecuado de errores es crucial para crear experiencias robustas que no se rompan cuando ocurren situaciones inesperadas, como fallos al cargar recursos, errores de red, o datos corruptos en las partidas guardadas.\nJavaScript permite lanzar cualquier tipo de objeto como excepción, aunque la práctica recomendada es usar objetos Error o crear errores personalizados con propiedades name y message descriptivas:\ntry {\n    // Código que puede fallar\n    let gameData = JSON.parse(savedGameString);\n    loadGame(gameData);\n} catch (error) {\n    // Manejo del error\n    console.error('Error loading game:', error.message);\n    showErrorDialog('No se pudo cargar la partida guardada');\n} finally {\n    // Código que siempre se ejecuta\n    hideLoadingSpinner();\n}\n\n// Lanzar excepciones personalizadas\nfunction validatePlayerInput(input) {\n    if (!input || input.trim() === '') {\n        throw new Error('El nombre del jugador no puede estar vacío');\n    }\n    \n    if (input.length &gt; 20) {\n        throw new Error('El nombre del jugador es demasiado largo');\n    }\n}",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#almacenamiento-de-datos-en-el-navegador",
    "href": "ch/part_client/js/js.html#almacenamiento-de-datos-en-el-navegador",
    "title": "7  JavaScript",
    "section": "7.10 Almacenamiento de Datos en el Navegador",
    "text": "7.10 Almacenamiento de Datos en el Navegador\nEn el desarrollo de videojuegos web, frecuentemente necesitamos almacenar información que persista entre sesiones de juego. Esto incluye datos como puntuaciones máximas, configuraciones del jugador, progreso en niveles, preferencias de audio/video, y estados de partidas guardadas. JavaScript proporciona varios mecanismos para almacenar datos en el navegador del usuario, cada uno con características específicas que los hacen apropiados para diferentes situaciones.\n\nLocal Storage\nLocal Storage es una API moderna del navegador que permite almacenar datos de forma persistente en el dispositivo del usuario. A diferencia de las cookies, los datos del Local Storage no se envían automáticamente al servidor con cada petición HTTP, lo que los hace ideales para almacenar información que solo necesita el cliente.\nLas características principales del Local Storage son:\n\nPersistencia: Los datos permanecen hasta que el usuario los elimine manualmente o la aplicación los borre\nCapacidad: Típicamente 5-10MB por dominio (mucho más que las cookies)\nSincronía: Las operaciones son síncronas y bloquean el hilo principal\nÁmbito: Los datos son específicos del dominio y protocolo\n\n\nGuardar datos\nLocal Storage solo acepta strings, por lo que para guardar números u objetos debemos convertirlos primero:\n// Guardar strings y números\nlocalStorage.setItem('playerName', 'Jugador1');\nlocalStorage.setItem('highScore', '15000');\nPara objetos más complejos, utilizamos JSON:\nconst gameConfig = {\n    volume: 0.8,\n    difficulty: 'normal'\n};\nlocalStorage.setItem('gameConfig', JSON.stringify(gameConfig));\n\n\nLeer datos\nPara recuperar los datos utilizamos getItem():\nconst playerName = localStorage.getItem('playerName');\nconst highScore = localStorage.getItem('highScore');\nPara objetos, debemos parsear el JSON de vuelta:\nconst configString = localStorage.getItem('gameConfig');\nconst config = configString ? JSON.parse(configString) : null;\n\n\nVerificar existencia\nPodemos comprobar si existe un dato antes de intentar leerlo:\nif (localStorage.getItem('playerName') !== null) {\n    console.log('El jugador ya tiene un nombre guardado');\n}\n\n\nEliminar datos\nPara eliminar datos específicos:\nlocalStorage.removeItem('playerName');\nPara eliminar todos los datos del dominio:\nlocalStorage.clear();\n\n\nInformación adicional\nPodemos obtener información sobre el storage:\n// Número de elementos almacenados\nconst cantidadItems = localStorage.length;\n\n// Iterar sobre todas las claves\nfor (let i = 0; i &lt; localStorage.length; i++) {\n    const clave = localStorage.key(i);\n    const valor = localStorage.getItem(clave);\n    console.log(clave, valor);\n}\n\n\nManejo de errores\n// Siempre usar try-catch con localStorage\nfunction guardarDatos(clave, valor) {\n    try {\n        localStorage.setItem(clave, valor);\n        return true;\n    } catch (error) {\n        console.error('Error al guardar:', error);\n        // Puede fallar si el storage está lleno o en modo privado\n        return false;\n    }\n}\n\nfunction cargarDatos(clave) {\n    try {\n        return localStorage.getItem(clave);\n    } catch (error) {\n        console.error('Error al cargar:', error);\n        return null;\n    }\n}\n\n\n\nSession Storage\nSession Storage funciona de manera idéntica a Local Storage, pero los datos solo persisten durante la sesión actual del navegador. Cuando el usuario cierra la pestaña o ventana, los datos se eliminan automáticamente.\nLa API es exactamente la misma que localStorage:\n// Guardar datos temporales\nsessionStorage.setItem('tempData', 'valor temporal');\n// Leer datos temporales\nconst tempData = sessionStorage.getItem('tempData');\n// Eliminar datos temporales\nsessionStorage.removeItem('tempData');\nsessionStorage.clear();\nEs especialmente útil para datos que no deben persistir entre sesiones:\n// Estado actual del juego que se pierde al cerrar\nsessionStorage.setItem('currentGameState', JSON.stringify(gameState));\n\n\nCookies\nLas cookies son un mecanismo más antiguo pero siguen siendo útiles cuando el servidor necesita acceso a los datos o para configuraciones que deben enviarse automáticamente con las peticiones HTTP.\nCaracterísticas de las cookies:\n\nTamaño máximo de 4KB por cookie\nSe envían automáticamente con cada petición HTTP al dominio\nTienen fecha de expiración configurable\nPueden configurarse como seguras (solo HTTPS) o HttpOnly\n\n\nEscribir cookies\nLa sintaxis básica para crear una cookie:\ndocument.cookie = \"playerName=Jugador1\";\nPara añadir una fecha de expiración (por ejemplo, 30 días):\nconst fecha = new Date();\nfecha.setTime(fecha.getTime() + (30 * 24 * 60 * 60 * 1000));\ndocument.cookie = `highScore=15000; expires=${fecha.toUTCString()}; path=/`;\n\n\nLeer cookies\nLeer cookies requiere parsear la cadena que devuelve document.cookie:\nfunction getCookie(nombre) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${nombre}=`);\n    if (parts.length === 2) {\n        return parts.pop().split(';').shift();\n    }\n    return null;\n}\nconst playerName = getCookie('playerName');\n\n\nEliminar cookies\nPara eliminar una cookie, establecemos una fecha de expiración en el pasado:\ndocument.cookie = \"playerName=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/\";\n\n\nOpciones de seguridad\nLas cookies pueden incluir opciones adicionales de seguridad:\ndocument.cookie = \"sessionId=abc123; Secure; SameSite=Strict; path=/\";\n\n\nUtilidad para simplificar cookies\nDado que las cookies tienen una sintaxis más compleja, es útil crear funciones auxiliares:\nconst CookieUtil = {\n    set(nombre, valor, dias = 7) {\n        const fecha = new Date();\n        fecha.setTime(fecha.getTime() + (dias * 24 * 60 * 60 * 1000));\n        document.cookie = `${nombre}=${valor}; expires=${fecha.toUTCString()}; path=/`;\n    }\n};\nget(nombre) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${nombre}=`);\n    return parts.length === 2 ? parts.pop().split(';').shift() : null;\n}\ndelete(nombre) {\n    document.cookie = `${nombre}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n}\nUso de la utilidad:\nCookieUtil.set('playerLevel', '5', 30);  // 30 días\nconst level = CookieUtil.get('playerLevel');\nCookieUtil.delete('playerLevel');\n\n\n\nComparación y Recomendaciones de Uso\n\n\n\n\n\n\n\n\n\nCaracterística\nlocalStorage\nsessionStorage\nCookies\n\n\n\n\nCapacidad\n~5-10MB\n~5-10MB\n4KB\n\n\nPersistencia\nHasta eliminar manualmente\nSolo la sesión\nConfigurable\n\n\nEnvío al servidor\nNo\nNo\nAutomático\n\n\nAPI\nSíncrona\nSíncrona\nManual\n\n\n\nRecomendaciones para videojuegos:\n\nlocalStorage: Configuraciones, puntuaciones, progreso del juego\nsessionStorage: Estado temporal, datos de sesión\ncookies: Autenticación, preferencias que el servidor necesita\n\n\n\nEjemplo Práctico: Sistema de Guardado\n// Sistema simple de guardado para un juego\nconst GameSave = {\n    save(gameData) {\n        try {\n            localStorage.setItem('gameSave', JSON.stringify(gameData));\n            console.log('Juego guardado');\n        } catch (error) {\n            console.error('Error al guardar:', error);\n        }\n    },\n\n    load() {\n        try {\n            const data = localStorage.getItem('gameSave');\n            return data ? JSON.parse(data) : null;\n        } catch (error) {\n            console.error('Error al cargar:', error);\n            return null;\n        }\n    },\n\n    delete() {\n        localStorage.removeItem('gameSave');\n        console.log('Partida eliminada');\n    },\n\n    exists() {\n        return localStorage.getItem('gameSave') !== null;\n    }\n};\n\n// Uso\nconst gameData = {\n    level: 5,\n    score: 12500,\n    lives: 3,\n    powerUps: ['speed', 'jump']\n};\n\nGameSave.save(gameData);\nconst loadedData = GameSave.load();\nif (GameSave.exists()) {\n    console.log('Hay una partida guardada');\n}",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#introducción-1",
    "href": "ch/part_client/js/js.html#introducción-1",
    "title": "7  JavaScript",
    "section": "8.1 Introducción",
    "text": "8.1 Introducción\nJavaScript es el lenguaje fundamental para el desarrollo de videojuegos web modernos. A diferencia de otros lenguajes que habéis estudiado, JavaScript utiliza un sistema de orientación a objetos basado en prototipos en lugar de clases tradicionales, aunque las versiones modernas incluyen sintaxis de clases que simplifican el desarrollo.\nEn este capítulo profundizaremos en las características únicas de JavaScript para videojuegos: la orientación a objetos basada en prototipos, las clases modernas ES2015+, y cómo trabajar con objetos dinámicos.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/js/js.html#orientación-a-objetos-en-javascript",
    "href": "ch/part_client/js/js.html#orientación-a-objetos-en-javascript",
    "title": "7  JavaScript",
    "section": "8.2 Orientación a Objetos en JavaScript",
    "text": "8.2 Orientación a Objetos en JavaScript\n\nDiferencias con Java: Clases vs Prototipos\nMientras que Java utiliza un sistema basado en clases donde los objetos son instancias de una clase predefinida, JavaScript tradicionalmente utiliza prototipos. En JavaScript, cualquier objeto puede servir como prototipo para otros objetos, creando una cadena de herencia más flexible.\n\nCreación Básica de Objetos\n// Objeto literal simple\nconst enemigo = {\n    vida: 100,\n    damage: 15,\n    atacar() {\n        return `Enemigo ataca causando ${this.damage} puntos de daño`;\n    }\n};\n\n// Crear otro enemigo basado en el prototipo\nconst goblin = Object.create(enemigo);\ngoblin.vida = 50;\ngoblin.damage = 8;\ngoblin.tipo = \"Goblin\";\n\nconsole.log(goblin.atacar()); // \"Enemigo ataca causando 8 puntos de daño\"\nconsole.log(goblin.vida);     // 50 (propio)\nconsole.log(goblin.toString); // function (heredado de Object)\nEn este ejemplo, goblin hereda el método atacar() del objeto enemigo. Cuando JavaScript busca una propiedad en goblin y no la encuentra, automáticamente busca en su prototipo (enemigo), y si no la encuentra ahí, continúa hacia arriba en la cadena hasta llegar a Object.prototype.\n\n\nHerencia con Prototipos\nPara crear una jerarquía de herencia más compleja con prototipos, necesitamos establecer la cadena de prototipos manualmente:\n// Prototipo base\nconst personajeBase = {\n    mover(x, y) {\n        this.x += x;\n        this.y += y;\n        console.log(`${this.nombre} se mueve a (${this.x}, ${this.y})`);\n    },\n    \n    toString() {\n        return `${this.nombre}: vida=${this.vida}, pos=(${this.x},${this.y})`;\n    }\n};\n\n// Prototipo específico para jugadores\nconst prototipoJugador = Object.create(personajeBase);\nprototipoJugador.atacar = function(objetivo) {\n    return `${this.nombre} ataca a ${objetivo.nombre} por ${this.fuerza} puntos`;\n};\n\nprototipoJugador.levelUp = function() {\n    this.nivel++;\n    this.fuerza += 5;\n    console.log(`${this.nombre} sube a nivel ${this.nivel}!`);\n};\n\n// Crear instancia de jugador\nconst jugador = Object.create(prototipoJugador);\njugador.nombre = \"Aragorn\";\njugador.vida = 100;\njugador.x = 0;\njugador.y = 0;\njugador.fuerza = 20;\njugador.nivel = 1;\n\njugador.mover(5, 3);  // Método heredado de personajeBase\njugador.levelUp();    // Método del prototipoJugador\nEste ejemplo muestra una cadena de herencia: jugador → prototipoJugador → personajeBase → Object.prototype. Cada nivel puede añadir o sobrescribir métodos.\n\n\nAcceso a Propiedades y Métodos de Objetos\nJavaScript permite acceder a las propiedades de un objeto tanto con notación punto como con corchetes:\nconst config = {\n    sonido: true,\n    volumen: 0.8,\n    idioma: \"es\"\n};\n\n// Acceso con notación punto (recomendado)\nconsole.log(config.sonido);     // true\nconfig.volumen = 0.5;\n\n// Acceso con corchetes (útil para propiedades dinámicas)\nconsole.log(config[\"idioma\"]);  // \"es\"\nconst propiedad = \"volumen\";\nconsole.log(config[propiedad]); // 0.5\n\n// Añadir nuevas propiedades dinámicamente\nconfig.dificultad = \"normal\";\nconfig[\"maxJugadores\"] = 4;\nLa notación con corchetes es especialmente útil cuando el nombre de la propiedad está en una variable o cuando queremos iterar sobre las propiedades del objeto.\n\n\nIteración sobre Propiedades\nconst inventario = {\n    espada: 1,\n    pocion: 5,\n    oro: 150\n};\n\n// Iterar sobre todas las propiedades propias\nfor (let item in inventario) {\n    console.log(`${item}: ${inventario[item]}`);\n}\n\n// Verificar si una propiedad existe\nif (\"oro\" in inventario) {\n    console.log(\"El jugador tiene oro\");\n}\n\n// Obtener todas las claves como array\nconst items = Object.keys(inventario);\nconsole.log(items); // [\"espada\", \"pocion\", \"oro\"]\n\n// Obtener todos los valores como array\nconst cantidades = Object.values(inventario);\nconsole.log(cantidades); // [1, 5, 150]\nEl bucle for...in itera sobre todas las propiedades enumerables del objeto, incluyendo las heredadas del prototipo. Si solo queremos las propiedades propias del objeto, podemos usar Object.keys() o verificar con hasOwnProperty().\n\n\nDiferencias entre null y undefined\nJavaScript tiene dos valores especiales para representar “nada”:\nlet jugador = null;        // Ausencia intencional de valor\nlet powerUp;              // undefined - no inicializada\n\n// Verificación segura antes de usar objetos\nif (jugador) {\n    jugador.mover(5, 0);  // Solo se ejecuta si jugador no es null/undefined\n}\n\n// Verificación más específica\nif (jugador !== null && jugador !== undefined) {\n    jugador.atacar();\n}\n\n// Operador de optional chaining (ES2020+)\njugador?.mover?.(5, 0);   // Solo ejecuta si jugador y mover existen\nEsta diferencia es importante en videojuegos donde objetos pueden existir o no (enemigos destruidos, power-ups recogidos, etc.).\n\n\n\nFunción Constructor (Patrón Tradicional)\nAntes de ES2015, el patrón más común para crear “clases” era usar funciones constructor:\nfunction Jugador(nombre, x, y) {\n    this.nombre = nombre;\n    this.x = x;\n    this.y = y;\n    this.vida = 100;\n    this.velocidad = 5;\n}\n\n// Métodos compartidos en el prototipo\nJugador.prototype.mover = function(deltaX, deltaY) {\n    this.x += deltaX * this.velocidad;\n    this.y += deltaY * this.velocidad;\n    console.log(`${this.nombre} se mueve a (${this.x}, ${this.y})`);\n};\n\nJugador.prototype.recibirDanio = function(cantidad) {\n    this.vida -= cantidad;\n    if (this.vida &lt;= 0) {\n        console.log(`${this.nombre} ha sido derrotado!`);\n        return false;\n    }\n    return true;\n};\n\n// Uso del constructor\nconst player1 = new Jugador(\"Aragorn\", 10, 20);\nplayer1.mover(2, 3); // \"Aragorn se mueve a (20, 35)\"\n\n// IMPORTANTE: Siempre usar 'new'\nconst player2 = Jugador(\"Legolas\", 0, 0); // ¡ERROR! Sin 'new'\n// Sin 'new', 'this' apuntaría al objeto global, causando problemas\nLa función constructor se ejecuta cuando usamos el operador new. Este operador crea un nuevo objeto, establece this para que apunte a ese objeto, y al final devuelve el objeto automáticamente.\nLos métodos se definen en Jugador.prototype para que todos los objetos creados con este constructor compartan las mismas funciones en memoria, siendo más eficiente que definir los métodos dentro del constructor.\n\nHerencia con Funciones Constructor\n// Constructor padre\nfunction Personaje(nombre, vida) {\n    this.nombre = nombre;\n    this.vida = vida;\n}\n\nPersonaje.prototype.saludar = function() {\n    return `Hola, soy ${this.nombre}`;\n};\n\n// Constructor hijo\nfunction Guerrero(nombre, vida, fuerza) {\n    Personaje.call(this, nombre, vida); // Llamar al constructor padre\n    this.fuerza = fuerza;\n}\n\n// Establecer herencia de prototipos\nGuerrero.prototype = Object.create(Personaje.prototype);\nGuerrero.prototype.constructor = Guerrero;\n\n// Añadir métodos específicos del guerrero\nGuerrero.prototype.atacar = function() {\n    return `${this.nombre} ataca con fuerza ${this.fuerza}`;\n};\n\nconst conan = new Guerrero(\"Conan\", 150, 25);\nconsole.log(conan.saludar()); // \"Hola, soy Conan\" (heredado)\nconsole.log(conan.atacar());  // \"Conan ataca con fuerza 25\" (propio)\nEste patrón requiere tres pasos: llamar al constructor padre con call(), establecer la cadena de prototipos con Object.create(), y restaurar la propiedad constructor.\n\n\n\nClases ES2015+ (Sintaxis Moderna)\nLas clases modernas ofrecen una sintaxis más familiar para desarrolladores de Java, pero internamente siguen usando prototipos. La palabra clave class es “azúcar sintáctico” sobre el sistema de prototipos existente.\nclass GameObject {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.activo = true;\n    }\n\n    actualizar(deltaTime) {\n        // Lógica base de actualización que pueden sobrescribir las subclases\n        if (!this.activo) return;\n    }\n\n    destruir() {\n        this.activo = false;\n        console.log(\"Objeto destruido\");\n    }\n}\n\nclass Enemigo extends GameObject {\n    constructor(x, y, tipo) {\n        super(x, y);  // Llamada obligatoria al constructor padre\n        this.tipo = tipo;\n        this.vida = 50;\n        this.velocidad = 2;\n        this._direccion = { x: 1, y: 0 };\n    }\n\n    // Getter: se accede como una propiedad, pero ejecuta código\n    get estaVivo() {\n        return this.vida &gt; 0;\n    }\n\n    // Setter: permite validación cuando se asigna un valor\n    set vida(valor) {\n        this._vida = Math.max(0, valor); // No puede ser negativa\n        if (this._vida === 0) {\n            this.destruir();\n        }\n    }\n\n    get vida() {\n        return this._vida;\n    }\n\n    actualizar(deltaTime) {\n        super.actualizar(deltaTime); // Llamar al método padre\n        if (this.estaVivo) {\n            this.x += this._direccion.x * this.velocidad;\n            this.y += this._direccion.y * this.velocidad;\n        }\n    }\n\n    // Método estático: pertenece a la clase, no a las instancias\n    static crearOrc() {\n        const orc = new Enemigo(0, 0, \"Orc\");\n        orc.vida = 80;\n        orc.velocidad = 1.5;\n        return orc;\n    }\n}\nExplicación de elementos clave:\n\nconstructor: Método especial que se ejecuta al crear una instancia. Es equivalente a la función constructor del patrón tradicional.\nsuper(): En el constructor, llama al constructor de la clase padre. Debe ser la primera línea antes de usar this.\nextends: Establece herencia entre clases. Enemigo extends GameObject significa que Enemigo hereda de GameObject.\nget estaVivo(): Es un getter, una propiedad calculada que se accede como enemigo.estaVivo pero ejecuta código. No necesita paréntesis al accederla.\nset vida(valor): Es un setter, permite interceptar y validar cuando se asigna un valor a la propiedad. Se usa como enemigo.vida = 100.\nstatic crearOrc(): Método estático que pertenece a la clase, no a las instancias. Se llama como Enemigo.crearOrc().\nsuper.actualizar(deltaTime): En un método, llama al método del mismo nombre en la clase padre.\n\n\nEjemplo de Uso\n// Crear enemigos usando el constructor normal\nconst goblin = new Enemigo(10, 20, \"Goblin\");\ngoblin.vida = 30; // Usa el setter, valida que no sea negativo\n\n// Usar el getter\nif (goblin.estaVivo) {  // No necesita paréntesis\n    console.log(\"El goblin sigue vivo\");\n}\n\n// Crear enemigo usando método estático\nconst orc = Enemigo.crearOrc();\n\n// Polimorfismo: ambos objetos tienen el mismo interfaz\nconst enemigos = [goblin, orc];\nenemigos.forEach(enemigo =&gt; {\n    enemigo.actualizar(16); // Cada uno usa su propia implementación\n});\n\n\nVentajas de las Clases ES2015+\n\nSintaxis más clara: Más familiar para desarrolladores de otros lenguajes orientados a objetos.\nHerencia simplificada: extends y super() son más directos que manipular prototipos manualmente.\nGetters y setters integrados: Permiten crear propiedades con lógica de validación o cálculo.\nMétodos estáticos: Para funciones que pertenecen a la clase conceptualmente pero no necesitan una instancia.\nMejor soporte de herramientas: Los IDEs y linters comprenden mejor las clases modernas.\n\nLa sintaxis de clases es la recomendada para proyectos nuevos de videojuegos, especialmente cuando trabajáis en equipo o cuando el proyecto va a crecer en complejidad. Sin embargo, entender el sistema de prototipos subyacente os ayudará a comprender mejor cómo funciona JavaScript internamente y a debuggear problemas más efectivamente.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>JavaScript</span>"
    ]
  },
  {
    "objectID": "ch/part_client/htmlcss/htmlcss.html",
    "href": "ch/part_client/htmlcss/htmlcss.html",
    "title": "8  HTML y CSS",
    "section": "",
    "text": "8.1 Introducción\nHTML (HyperText Markup Language) y CSS (Cascading Style Sheets) son las tecnologías fundamentales para crear páginas web. HTML define la estructura y el contenido de la página mediante etiquetas, mientras que CSS controla su presentación visual. En el desarrollo de videojuegos web, HTML proporciona el contenedor donde se ejecuta el juego y los elementos de la interfaz de usuario, mientras que CSS da estilo a estos elementos.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HTML y CSS</span>"
    ]
  },
  {
    "objectID": "ch/part_client/htmlcss/htmlcss.html#html-hypertext-markup-language",
    "href": "ch/part_client/htmlcss/htmlcss.html#html-hypertext-markup-language",
    "title": "8  HTML y CSS",
    "section": "8.2 HTML (HyperText Markup Language)",
    "text": "8.2 HTML (HyperText Markup Language)\n\n¿Qué es HTML?\nHTML es un lenguaje de marcado que utiliza etiquetas (tags) para estructurar el contenido. Una etiqueta se escribe entre corchetes angulares &lt;&gt; y generalmente viene en pares: una etiqueta de apertura &lt;etiqueta&gt; y una de cierre &lt;/etiqueta&gt;. El contenido se coloca entre ambas.\n&lt;p&gt;Este es un párrafo de texto.&lt;/p&gt;\nAlgunas etiquetas no tienen contenido y se auto-cierran:\n&lt;img src=\"imagen.png\" alt=\"Descripción\"&gt;\n&lt;br&gt;\n\n\nEstructura Básica de un Documento HTML\nTodo documento HTML sigue una estructura estándar:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Mi Primera Página Web&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Bienvenido&lt;/h1&gt;\n    &lt;p&gt;Este es el contenido visible de la página.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nExplicación de cada parte:\n\n&lt;!DOCTYPE html&gt;: Declara que este es un documento HTML5 (la versión más reciente).\n&lt;html&gt;: Elemento raíz que contiene todo el documento. El atributo lang=\"es\" indica el idioma.\n&lt;head&gt;: Contiene metadatos e información que no se muestra directamente (título, enlaces a CSS, etc.).\n&lt;meta charset=\"UTF-8\"&gt;: Define la codificación de caracteres para soportar acentos y símbolos especiales.\n&lt;title&gt;: El texto que aparece en la pestaña del navegador.\n&lt;body&gt;: Contiene todo el contenido visible de la página.\n\n\n\nElementos de Texto\nHTML ofrece diversas etiquetas para estructurar texto:\n&lt;!-- Encabezados (h1 es el más importante, h6 el menos) --&gt;\n&lt;h1&gt;Título Principal&lt;/h1&gt;\n&lt;h2&gt;Subtítulo&lt;/h2&gt;\n&lt;h3&gt;Sección&lt;/h3&gt;\n\n&lt;!-- Párrafos --&gt;\n&lt;p&gt;Este es un párrafo de texto normal.&lt;/p&gt;\n\n&lt;!-- Formato de texto --&gt;\n&lt;strong&gt;Texto importante (negrita)&lt;/strong&gt;\n&lt;em&gt;Texto enfatizado (cursiva)&lt;/em&gt;\n&lt;mark&gt;Texto resaltado&lt;/mark&gt;\n&lt;small&gt;Texto pequeño&lt;/small&gt;\n\n&lt;!-- Saltos de línea --&gt;\n&lt;p&gt;Primera línea&lt;br&gt;Segunda línea&lt;/p&gt;\n\n&lt;!-- Línea horizontal --&gt;\n&lt;hr&gt;\nLos encabezados &lt;h1&gt; a &lt;h6&gt; crean una jerarquía de títulos, siendo &lt;h1&gt; el más importante. Solo debe haber un &lt;h1&gt; por página. Los elementos &lt;strong&gt; y &lt;em&gt; no solo cambian la apariencia sino que también indican importancia semántica.\n\n\nListas\nLas listas organizan información relacionada:\n&lt;!-- Lista no ordenada (viñetas) --&gt;\n&lt;ul&gt;\n    &lt;li&gt;Primer elemento&lt;/li&gt;\n    &lt;li&gt;Segundo elemento&lt;/li&gt;\n    &lt;li&gt;Tercer elemento&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;!-- Lista ordenada (numerada) --&gt;\n&lt;ol&gt;\n    &lt;li&gt;Paso 1&lt;/li&gt;\n    &lt;li&gt;Paso 2&lt;/li&gt;\n    &lt;li&gt;Paso 3&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;!-- Listas anidadas --&gt;\n&lt;ul&gt;\n    &lt;li&gt;Jugadores\n        &lt;ul&gt;\n            &lt;li&gt;Jugador 1&lt;/li&gt;\n            &lt;li&gt;Jugador 2&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;Enemigos&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul&gt; crea listas no ordenadas (con viñetas), &lt;ol&gt; crea listas ordenadas (numeradas), y &lt;li&gt; define cada elemento de la lista. Las listas pueden anidarse para crear jerarquías.\n\n\nEnlaces e Imágenes\n&lt;!-- Enlaces --&gt;\n&lt;a href=\"https://www.ejemplo.com\"&gt;Visitar Ejemplo&lt;/a&gt;\n&lt;a href=\"pagina2.html\"&gt;Ir a otra página del sitio&lt;/a&gt;\n&lt;a href=\"#seccion\"&gt;Ir a una sección de esta página&lt;/a&gt;\n&lt;a href=\"documento.pdf\" download&gt;Descargar PDF&lt;/a&gt;\n\n&lt;!-- Imágenes --&gt;\n&lt;img src=\"imagen.jpg\" alt=\"Descripción de la imagen\"&gt;\n&lt;img src=\"sprites/player.png\" alt=\"Sprite del jugador\" width=\"64\" height=\"64\"&gt;\nEl elemento &lt;a&gt; (anchor) crea enlaces. El atributo href especifica la URL de destino. Puede ser una URL completa, una ruta relativa a otro archivo, o un ancla a una sección de la misma página usando #.\nEl elemento &lt;img&gt; inserta imágenes. El atributo src indica la ruta de la imagen y alt proporciona texto alternativo para accesibilidad o cuando la imagen no carga. Los atributos width y height definen las dimensiones en píxeles.\n\n\nContenedores: Div y Span\nLos elementos &lt;div&gt; y &lt;span&gt; son contenedores genéricos sin significado semántico, pero son fundamentales para organizar y dar estilo al contenido:\n&lt;!-- div: contenedor de bloque (ocupa todo el ancho disponible) --&gt;\n&lt;div class=\"game-container\"&gt;\n    &lt;h2&gt;Mi Juego&lt;/h2&gt;\n    &lt;p&gt;Puntuación: 100&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;!-- span: contenedor en línea (solo ocupa el espacio de su contenido) --&gt;\n&lt;p&gt;Vidas: &lt;span class=\"lives-count\"&gt;3&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;Estado: &lt;span id=\"status\"&gt;Jugando&lt;/span&gt;&lt;/p&gt;\n&lt;div&gt; es un contenedor de nivel de bloque: cada &lt;div&gt; comienza en una nueva línea y ocupa todo el ancho disponible. Se usa para agrupar secciones grandes de contenido.\n&lt;span&gt; es un contenedor en línea: no interrumpe el flujo del texto y solo ocupa el espacio necesario para su contenido. Se usa para aplicar estilos a partes específicas de texto.\n\n\nElementos Semánticos\nHTML5 introdujo elementos semánticos que describen el propósito del contenido:\n&lt;header&gt;\n    &lt;h1&gt;Título del Sitio&lt;/h1&gt;\n    &lt;nav&gt;\n        &lt;a href=\"#inicio\"&gt;Inicio&lt;/a&gt;\n        &lt;a href=\"#juego\"&gt;Juego&lt;/a&gt;\n        &lt;a href=\"#contacto\"&gt;Contacto&lt;/a&gt;\n    &lt;/nav&gt;\n&lt;/header&gt;\n\n&lt;main&gt;\n    &lt;section id=\"juego\"&gt;\n        &lt;h2&gt;Área de Juego&lt;/h2&gt;\n        &lt;canvas id=\"game-canvas\"&gt;&lt;/canvas&gt;\n    &lt;/section&gt;\n\n    &lt;aside&gt;\n        &lt;h3&gt;Instrucciones&lt;/h3&gt;\n        &lt;p&gt;Usa las flechas para moverte.&lt;/p&gt;\n    &lt;/aside&gt;\n&lt;/main&gt;\n\n&lt;footer&gt;\n    &lt;p&gt;&copy; 2024 Mi Juego&lt;/p&gt;\n&lt;/footer&gt;\n\n&lt;header&gt;: Encabezado de la página o sección\n&lt;nav&gt;: Bloque de navegación con enlaces\n&lt;main&gt;: Contenido principal del documento (solo uno por página)\n&lt;section&gt;: Sección temática de contenido\n&lt;aside&gt;: Contenido complementario o lateral\n&lt;footer&gt;: Pie de página con información adicional\n\nEstos elementos mejoran la accesibilidad y la estructura del código comparado con usar solo &lt;div&gt;.\n\n\nFormularios\nLos formularios permiten recopilar información del usuario:\n&lt;form id=\"player-form\"&gt;\n    &lt;!-- Campo de texto --&gt;\n    &lt;label for=\"name\"&gt;Nombre:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"name\" name=\"player-name\" placeholder=\"Tu nombre\"&gt;\n\n    &lt;!-- Campo numérico --&gt;\n    &lt;label for=\"age\"&gt;Edad:&lt;/label&gt;\n    &lt;input type=\"number\" id=\"age\" min=\"1\" max=\"100\"&gt;\n\n    &lt;!-- Botones de radio (una opción) --&gt;\n    &lt;p&gt;Dificultad:&lt;/p&gt;\n    &lt;input type=\"radio\" id=\"easy\" name=\"difficulty\" value=\"easy\"&gt;\n    &lt;label for=\"easy\"&gt;Fácil&lt;/label&gt;\n\n    &lt;input type=\"radio\" id=\"hard\" name=\"difficulty\" value=\"hard\"&gt;\n    &lt;label for=\"hard\"&gt;Difícil&lt;/label&gt;\n\n    &lt;!-- Checkbox (múltiples opciones) --&gt;\n    &lt;input type=\"checkbox\" id=\"sound\" name=\"sound\" checked&gt;\n    &lt;label for=\"sound\"&gt;Activar sonido&lt;/label&gt;\n\n    &lt;!-- Menú desplegable --&gt;\n    &lt;label for=\"character\"&gt;Personaje:&lt;/label&gt;\n    &lt;select id=\"character\" name=\"character\"&gt;\n        &lt;option value=\"warrior\"&gt;Guerrero&lt;/option&gt;\n        &lt;option value=\"mage\"&gt;Mago&lt;/option&gt;\n        &lt;option value=\"archer\"&gt;Arquero&lt;/option&gt;\n    &lt;/select&gt;\n\n    &lt;!-- Botón de envío --&gt;\n    &lt;button type=\"submit\"&gt;Comenzar Juego&lt;/button&gt;\n&lt;/form&gt;\nEl elemento &lt;label&gt; asocia texto descriptivo con un campo. El atributo for del label debe coincidir con el id del input. Los diferentes type de input determinan qué tipo de dato se espera: text, number, email, password, etc.\nLos inputs radio con el mismo name forman un grupo donde solo se puede seleccionar una opción. Los checkbox permiten múltiples selecciones. El elemento &lt;select&gt; crea menús desplegables con opciones &lt;option&gt;.\n\n\nCanvas (Elemento para Videojuegos)\nEl elemento &lt;canvas&gt; es fundamental para videojuegos web, proporcionando una superficie de dibujo que JavaScript puede manipular:\n&lt;canvas id=\"game-canvas\" width=\"800\" height=\"600\"&gt;&lt;/canvas&gt;\nEl canvas es un área rectangular donde se pueden dibujar gráficos, formas, imágenes y animaciones mediante JavaScript. Los atributos width y height definen su tamaño en píxeles.\n\n\nReferencias a Scripts y Hojas de Estilo\nPara integrar JavaScript y CSS con HTML:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Mi Juego&lt;/title&gt;\n\n    &lt;!-- Enlazar CSS externo --&gt;\n    &lt;link rel=\"stylesheet\" href=\"css/styles.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"css/game.css\"&gt;\n\n    &lt;!-- CSS interno --&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"game-container\"&gt;&lt;/div&gt;\n\n    &lt;!-- Script externo - al final del body --&gt;\n    &lt;script src=\"js/game.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"js/controls.js\"&gt;&lt;/script&gt;\n\n    &lt;!-- Script interno --&gt;\n    &lt;script&gt;\n        console.log('Página cargada');\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nHojas de estilo CSS: - &lt;link rel=\"stylesheet\" href=\"ruta.css\"&gt; en el &lt;head&gt; enlaza archivos CSS externos - &lt;style&gt; permite escribir CSS directamente en el HTML\nScripts JavaScript: - &lt;script src=\"ruta.js\"&gt; enlaza archivos JavaScript externos - Se recomienda colocarlos al final del &lt;body&gt; para que el HTML cargue primero - &lt;script&gt; sin src permite escribir JavaScript directamente en el HTML\n\n\nAtributos Comunes\nLos atributos proporcionan información adicional sobre los elementos:\n&lt;!-- id: identificador único --&gt;\n&lt;div id=\"game-canvas\"&gt;&lt;/div&gt;\n\n&lt;!-- class: clasificación para estilos (puede repetirse) --&gt;\n&lt;button class=\"menu-btn primary\"&gt;Jugar&lt;/button&gt;\n&lt;button class=\"menu-btn secondary\"&gt;Salir&lt;/button&gt;\n\n&lt;!-- style: estilos CSS inline --&gt;\n&lt;p style=\"color: red; font-size: 20px;\"&gt;Texto rojo&lt;/p&gt;\n\n&lt;!-- data-*: atributos personalizados --&gt;\n&lt;div class=\"enemy\" data-type=\"orc\" data-health=\"100\"&gt;&lt;/div&gt;\n\n&lt;!-- title: tooltip al pasar el mouse --&gt;\n&lt;button title=\"Haz click para pausar\"&gt;Pausa&lt;/button&gt;\nEl id debe ser único en toda la página y se usa para identificar un elemento específico. La class puede repetirse en múltiples elementos y se usa para aplicar estilos compartidos. Los atributos data-* permiten almacenar información personalizada en elementos HTML.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HTML y CSS</span>"
    ]
  },
  {
    "objectID": "ch/part_client/htmlcss/htmlcss.html#css-cascading-style-sheets",
    "href": "ch/part_client/htmlcss/htmlcss.html#css-cascading-style-sheets",
    "title": "8  HTML y CSS",
    "section": "8.3 CSS (Cascading Style Sheets)",
    "text": "8.3 CSS (Cascading Style Sheets)\n\n¿Qué es CSS?\nCSS (Hojas de Estilo en Cascada) es el lenguaje que controla la presentación visual de HTML. Permite definir colores, tamaños, posiciones, animaciones y mucho más. CSS separa el contenido (HTML) de la presentación (estilos).\n\n\nSintaxis Básica\nUna regla CSS consta de un selector que identifica qué elementos afectar, y declaraciones que definen los estilos:\nselector {\n    propiedad: valor;\n    otra-propiedad: otro-valor;\n}\nEjemplo real:\nh1 {\n    color: blue;\n    font-size: 32px;\n    text-align: center;\n}\nEsto hace que todos los elementos &lt;h1&gt; sean azules, con tamaño de fuente de 32 píxeles, y centrados.\n\n\nFormas de Incluir CSS\n1. CSS Externo (recomendado):\n&lt;link rel=\"stylesheet\" href=\"estilos.css\"&gt;\nEl archivo estilos.css contiene todas las reglas CSS. Es la mejor opción porque permite reutilizar estilos en múltiples páginas.\n2. CSS Interno:\n&lt;head&gt;\n    &lt;style&gt;\n        p { color: green; }\n    &lt;/style&gt;\n&lt;/head&gt;\nLos estilos se escriben dentro de &lt;style&gt; en el HTML. Útil para estilos específicos de una página.\n3. CSS Inline:\n&lt;p style=\"color: red; font-size: 18px;\"&gt;Texto rojo&lt;/p&gt;\nLos estilos se aplican directamente en el atributo style del elemento. No se recomienda excepto para estilos dinámicos con JavaScript.\n\n\nSelectores CSS\nLos selectores determinan a qué elementos se aplican los estilos:\n/* Selector de elemento - afecta a TODOS los elementos del tipo */\np {\n    color: black;\n}\n\n/* Selector de ID - afecta al elemento con ese id específico */\n#game-canvas {\n    border: 2px solid black;\n}\n\n/* Selector de clase - afecta a todos los elementos con esa clase */\n.menu-btn {\n    background-color: blue;\n    color: white;\n}\n\n/* Selector de múltiples elementos */\nh1, h2, h3 {\n    font-family: Arial, sans-serif;\n}\n\n/* Selector descendiente - elementos dentro de otros */\n.game-container p {\n    margin: 10px;\n}\n\n/* Selector hijo directo */\nnav &gt; a {\n    display: inline-block;\n}\n\nElemento (p, h1, div): Selecciona todos los elementos de ese tipo\nID (#nombre): Selecciona el elemento con id=\"nombre\" (solo uno)\nClase (.nombre): Selecciona todos los elementos con class=\"nombre\"\nDescendiente (div p): Selecciona todos los &lt;p&gt; dentro de cualquier &lt;div&gt;\nHijo directo (div &gt; p): Selecciona solo los &lt;p&gt; que son hijos directos de &lt;div&gt;\n\n\n\nColores\nCSS permite definir colores de varias formas. La propiedad color controla el color del texto, mientras que background-color controla el color de fondo del elemento.\n.ejemplo {\n    /* Nombres de colores predefinidos */\n    color: red;\n    background-color: white;\n}\nNombres de colores: CSS reconoce 140 nombres de colores en inglés como red, blue, green, black, white, etc. Son fáciles de recordar pero ofrecen pocas opciones.\n.hexadecimal {\n    /* Hexadecimal - formato más común */\n    color: #ff0000;        /* rojo: ff=255 rojo, 00=0 verde, 00=0 azul */\n    color: #00ff00;        /* verde */\n    color: #0000ff;        /* azul */\n    color: #fff;           /* blanco (forma corta de #ffffff) */\n    color: #000;           /* negro (forma corta de #000000) */\n}\nHexadecimal: El formato más usado. Los colores se representan con 6 dígitos hexadecimales (0-9, A-F) precedidos por #. Los primeros dos dígitos son el rojo, los siguientes dos el verde, y los últimos dos el azul. Cuando los pares de dígitos son iguales, se puede usar la forma corta de 3 dígitos: #f00 es igual a #ff0000.\n.rgb {\n    /* RGB - valores de 0 a 255 */\n    color: rgb(255, 0, 0);      /* rojo */\n    color: rgb(0, 255, 0);      /* verde */\n    color: rgb(128, 128, 128);  /* gris medio */\n}\nRGB (Red, Green, Blue): Especifica colores usando tres números del 0 al 255 que representan la intensidad de rojo, verde y azul. Es más intuitivo que hexadecimal para algunas personas.\n.transparencia {\n    /* RGBA - RGB con transparencia (alpha) */\n    background-color: rgba(0, 0, 0, 0.5);    /* negro semi-transparente */\n    background-color: rgba(255, 0, 0, 0.8);  /* rojo casi opaco */\n    background-color: rgba(0, 0, 255, 0.2);  /* azul muy transparente */\n}\nRGBA: Igual que RGB pero añade un cuarto valor (alpha) que controla la transparencia. El valor alpha va de 0 (completamente transparente) a 1 (completamente opaco). Un valor de 0.5 significa 50% transparente.\n\n\nTexto y Fuentes\nCSS ofrece múltiples propiedades para controlar la apariencia del texto:\n.titulo {\n    font-family: Arial, sans-serif;\n}\nfont-family: Define qué tipografía se usa. Se especifica una lista de fuentes separadas por comas porque no todos los sistemas tienen todas las fuentes instaladas. El navegador usa la primera fuente disponible. Es recomendable terminar con una familia genérica (serif, sans-serif, monospace) como respaldo.\n.texto {\n    font-size: 16px;     /* Tamaño absoluto en píxeles */\n    font-size: 1.5em;    /* Tamaño relativo al padre (1.5 veces más grande) */\n    font-size: 100%;     /* Tamaño relativo (100% = igual al padre) */\n}\nfont-size: Controla el tamaño del texto. Las unidades más comunes son píxeles (px), que son fijas, y unidades relativas como em (relativa al tamaño de fuente del elemento padre) o porcentajes.\n.negrita {\n    font-weight: bold;      /* Negrita */\n    font-weight: normal;    /* Normal */\n    font-weight: 700;       /* Negrita (valor numérico) */\n    font-weight: 400;       /* Normal (valor numérico) */\n}\nfont-weight: Controla el grosor del texto. Puede usar palabras clave (normal, bold) o valores numéricos de 100 a 900, donde 400 es normal y 700 es negrita.\n.cursiva {\n    font-style: italic;   /* Cursiva */\n    font-style: normal;   /* Normal (no cursiva) */\n}\nfont-style: Define si el texto está en cursiva (italic) o normal.\n.alineacion {\n    text-align: left;     /* Alineado a la izquierda (predeterminado) */\n    text-align: center;   /* Centrado */\n    text-align: right;    /* Alineado a la derecha */\n    text-align: justify;  /* Justificado (alineado a ambos lados) */\n}\ntext-align: Controla la alineación horizontal del texto dentro de su contenedor.\n\n\nModelo de Caja (Box Model)\nEl concepto más importante de CSS es el modelo de caja. Cada elemento HTML es una caja rectangular compuesta por cuatro áreas que se suman para determinar el espacio total que ocupa:\n┌─────────────── margin ───────────────┐\n│ ┌──────────── border ─────────────┐ │\n│ │ ┌────────── padding ──────────┐ │ │\n│ │ │                              │ │ │\n│ │ │         CONTENIDO            │ │ │\n│ │ │        (width x height)      │ │ │\n│ │ │                              │ │ │\n│ │ └──────────────────────────────┘ │ │\n│ └──────────────────────────────────┘ │\n└──────────────────────────────────────┘\n1. Contenido (content): Es el área donde aparece el texto, imágenes o contenido del elemento. Se controla con width (ancho) y height (alto).\n.contenido {\n    width: 200px;    /* Ancho del área de contenido */\n    height: 100px;   /* Alto del área de contenido */\n}\n2. Relleno (padding): Es el espacio entre el contenido y el borde. Es transparente y adopta el color de fondo del elemento. Sirve para dar “respiración” al contenido.\n.con-padding {\n    padding: 20px;  /* 20px de espacio en los 4 lados */\n}\n\n.padding-individual {\n    padding-top: 10px;     /* Arriba */\n    padding-right: 15px;   /* Derecha */\n    padding-bottom: 10px;  /* Abajo */\n    padding-left: 15px;    /* Izquierda */\n}\n\n.padding-forma-corta {\n    /* Forma corta: arriba derecha abajo izquierda (sentido horario) */\n    padding: 10px 15px 10px 15px;\n\n    /* Si vertical y horizontal son iguales, se puede reducir a 2 valores */\n    padding: 10px 15px;  /* 10px arriba/abajo, 15px izquierda/derecha */\n}\n3. Borde (border): Es una línea que rodea el padding y el contenido. Se puede definir su grosor, estilo y color.\n.con-borde {\n    border: 2px solid black;  /* Grosor Estilo Color */\n}\n\n.borde-detallado {\n    border-width: 3px;           /* Grosor del borde */\n    border-style: solid;         /* Estilo: solid, dashed, dotted, double */\n    border-color: blue;          /* Color del borde */\n    border-radius: 10px;         /* Esquinas redondeadas */\n}\n\n.bordes-individuales {\n    border-top: 1px solid red;      /* Solo borde superior */\n    border-bottom: 2px dashed blue; /* Solo borde inferior */\n}\n4. Margen (margin): Es el espacio externo entre el elemento y otros elementos. Es completamente transparente y sirve para separar elementos entre sí.\n.con-margen {\n    margin: 20px;  /* 20px de espacio exterior en los 4 lados */\n}\n\n.margen-individual {\n    margin-top: 10px;\n    margin-right: 15px;\n    margin-bottom: 10px;\n    margin-left: 15px;\n}\n\n.centrado {\n    width: 200px;\n    margin: 0 auto;  /* Centra horizontalmente: 0 arriba/abajo, auto izquierda/derecha */\n}\nCálculo del tamaño total:\nPor defecto, el tamaño total de un elemento se calcula así:\nAncho total = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n\nAlto total = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom\nEjemplo: si un elemento tiene width: 200px, padding: 10px, border: 2px, el ancho visible será 224px (2 + 10 + 200 + 10 + 2).\nBox-sizing: Para simplificar este cálculo, existe la propiedad box-sizing:\n.caja-tradicional {\n    box-sizing: content-box;  /* Predeterminado: width solo afecta al contenido */\n    width: 200px;\n    padding: 10px;\n    border: 2px;\n    /* Ancho total = 224px (2+10+200+10+2) */\n}\n\n.caja-moderna {\n    box-sizing: border-box;   /* width incluye contenido + padding + border */\n    width: 200px;\n    padding: 10px;\n    border: 2px;\n    /* Ancho total = 200px (el padding y border se restan del contenido) */\n}\nLa mayoría de desarrolladores modernos usan box-sizing: border-box porque hace los cálculos más intuitivos. Es común ver esto al inicio de las hojas de estilo:\n* {\n    box-sizing: border-box;  /* Aplica a todos los elementos */\n}\n\n\nDisplay: Bloque vs Inline\nLa propiedad display es fundamental porque controla cómo se comporta un elemento en el flujo del documento. Los dos valores principales son block e inline.\nElementos de bloque (block):\nLos elementos de bloque ocupan todo el ancho disponible de su contenedor y siempre comienzan en una nueva línea. Son como cajas apiladas verticalmente.\ndiv {\n    display: block;  /* Comportamiento predeterminado de div */\n}\nElementos que son block por defecto: &lt;div&gt;, &lt;p&gt;, &lt;h1&gt;-&lt;h6&gt;, &lt;ul&gt;, &lt;li&gt;, &lt;section&gt;, &lt;header&gt;, etc.\nCaracterísticas: - Ocupan todo el ancho disponible - Empiezan en una nueva línea - Aceptan propiedades de ancho (width) y alto (height) - Se pueden apilar verticalmente con márgenes\nElementos en línea (inline):\nLos elementos inline solo ocupan el espacio de su contenido y no interrumpen el flujo del texto. Son como palabras en una oración.\nspan {\n    display: inline;  /* Comportamiento predeterminado de span */\n}\nElementos que son inline por defecto: &lt;span&gt;, &lt;a&gt;, &lt;strong&gt;, &lt;em&gt;, &lt;img&gt;, etc.\nCaracterísticas: - Solo ocupan el espacio de su contenido - No interrumpen el flujo del texto - NO aceptan width ni height - Los márgenes verticales no funcionan correctamente\nInline-block (lo mejor de ambos mundos):\n.boton {\n    display: inline-block;\n    width: 100px;\n    height: 40px;\n}\ninline-block combina ambos comportamientos: el elemento fluye como inline (no interrumpe la línea) pero acepta dimensiones como block.\nOcultar elementos:\n.oculto {\n    display: none;  /* Elimina completamente el elemento del flujo */\n}\n\n.invisible {\n    visibility: hidden;  /* Oculta el elemento pero mantiene su espacio */\n}\n\n\nPosicionamiento\nEl posicionamiento controla dónde aparece un elemento en la página. Por defecto, los elementos siguen el flujo normal del documento (uno después de otro), pero podemos cambiar esto.\nStatic (posición normal):\n.normal {\n    position: static;  /* Valor predeterminado */\n}\nEl elemento sigue el flujo normal del documento. Las propiedades top, right, bottom, left no tienen efecto.\nRelative (posición relativa):\n.desplazado {\n    position: relative;\n    top: 10px;    /* Se mueve 10px HACIA ABAJO desde su posición original */\n    left: 20px;   /* Se mueve 20px HACIA LA DERECHA desde su posición original */\n}\nEl elemento se desplaza desde su posición original, pero su espacio original se mantiene reservado. Otros elementos se comportan como si este elemento siguiera en su lugar original.\nAbsolute (posición absoluta):\n.contenedor {\n    position: relative;  /* Esto es importante */\n}\n\n.flotante {\n    position: absolute;\n    top: 20px;    /* 20px desde el BORDE SUPERIOR del contenedor */\n    right: 10px;  /* 10px desde el BORDE DERECHO del contenedor */\n}\nEl elemento se extrae completamente del flujo normal y se posiciona respecto al ancestro posicionado más cercano (cualquier elemento con position diferente de static). Si no hay ninguno, se posiciona respecto al &lt;body&gt;.\nUsos comunes: - Menús desplegables - Tooltips - Elementos superpuestos sobre otros\nFixed (posición fija):\n.barra-superior {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    background-color: black;\n}\nEl elemento se posiciona respecto a la ventana del navegador y permanece en el mismo lugar incluso al hacer scroll. Útil para barras de navegación fijas o botones flotantes.\nZ-index (orden de apilamiento):\nCuando los elementos se superponen, z-index controla cuál aparece encima:\n.fondo {\n    position: absolute;\n    z-index: 1;  /* Aparece debajo */\n}\n\n.encima {\n    position: absolute;\n    z-index: 10;  /* Aparece encima (número mayor = más arriba) */\n}\nImportante: z-index solo funciona en elementos posicionados (con position diferente de static).\n\n\nPseudo-clases\nLas pseudo-clases permiten aplicar estilos a elementos según su estado o posición, sin necesidad de añadir clases en el HTML.\nEstados interactivos:\n/* Cuando el mouse pasa sobre el elemento */\na:hover {\n    color: red;\n    text-decoration: underline;\n}\n\n/* Mientras se hace click en el elemento */\nbutton:active {\n    background-color: darkblue;\n}\n\n/* Cuando el elemento tiene el foco (navegación con teclado) */\ninput:focus {\n    border-color: blue;\n    outline: 2px solid lightblue;\n}\nLa pseudo-clase :hover es muy útil para dar feedback visual al usuario. :active captura el momento exacto del click. :focus es importante para accesibilidad cuando se navega con teclado.\nSelectores de posición:\n/* El primer elemento de su tipo */\nli:first-child {\n    font-weight: bold;\n}\n\n/* El último elemento de su tipo */\nli:last-child {\n    border-bottom: none;\n}\n\n/* Elementos pares o impares */\ntr:nth-child(even) {\n    background-color: #f0f0f0;  /* Filas pares en gris claro */\n}\n\ntr:nth-child(odd) {\n    background-color: white;     /* Filas impares en blanco */\n}\nEstas pseudo-clases son útiles para crear efectos visuales como tablas con filas alternadas sin tener que añadir clases manualmente a cada elemento.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HTML y CSS</span>"
    ]
  },
  {
    "objectID": "ch/part_client/htmlcss/htmlcss.html#integración-html-css-y-javascript",
    "href": "ch/part_client/htmlcss/htmlcss.html#integración-html-css-y-javascript",
    "title": "8  HTML y CSS",
    "section": "8.4 Integración HTML, CSS y JavaScript",
    "text": "8.4 Integración HTML, CSS y JavaScript\nEstas tres tecnologías trabajan juntas en el desarrollo web:\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Ejemplo Integrado&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"game-container\"&gt;\n        &lt;h1&gt;Mi Juego&lt;/h1&gt;\n        &lt;div id=\"score\"&gt;Puntuación: &lt;span id=\"score-value\"&gt;0&lt;/span&gt;&lt;/div&gt;\n        &lt;button id=\"start-btn\"&gt;Iniciar&lt;/button&gt;\n    &lt;/div&gt;\n\n    &lt;script src=\"game.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n/* styles.css */\n#game-container {\n    text-align: center;\n    padding: 20px;\n    background-color: #f0f0f0;\n}\n\n#score {\n    font-size: 24px;\n    margin: 20px 0;\n}\n\n#score-value {\n    color: green;\n    font-weight: bold;\n}\n\n#start-btn {\n    padding: 10px 30px;\n    font-size: 18px;\n    background-color: #4CAF50;\n    color: white;\n    border: none;\n    border-radius: 5px;\n    cursor: pointer;\n}\n\n#start-btn:hover {\n    background-color: #45a049;\n}\n// game.js\nconst scoreElement = document.getElementById('score-value');\nconst startBtn = document.getElementById('start-btn');\n\nlet score = 0;\n\nstartBtn.addEventListener('click', function() {\n    score += 10;\n    scoreElement.textContent = score;\n});\nEn este ejemplo: HTML define la estructura (título, puntuación, botón), CSS controla la apariencia (colores, tamaños, efectos hover), y JavaScript añade interactividad (actualiza la puntuación al hacer click).",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>HTML y CSS</span>"
    ]
  },
  {
    "objectID": "ch/part_client/part_intro_phaser.html",
    "href": "ch/part_client/part_intro_phaser.html",
    "title": "Desarrollo de juegos con tecnología web",
    "section": "",
    "text": "Con los fundamentos de JavaScript dominados, estamos listos para dar el siguiente paso: crear juegos completos utilizando tecnología web. Phaser es un motor de juegos 2D potente y versátil que nos permitirá desarrollar juegos directamente en el navegador, aprovechando todo el conocimiento de JavaScript que hemos adquirido. En esta parte exploraremos la arquitectura de Phaser, aprenderemos a gestionar escenas y el ciclo de vida del juego, trabajaremos con sprites y texturas, implementaremos sistemas de físicas, y dominaremos la gestión de entrada del usuario mediante teclado, ratón y dispositivos táctiles. Al finalizar, seremos capaces de desarrollar juegos 2D completos que servirán como base para integrar las funcionalidades multijugador en las siguientes partes del curso.",
    "crumbs": [
      "Desarrollo en el cliente",
      "Desarrollo de juegos con tecnología web"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html",
    "href": "ch/part_client/phaser/phaser.html",
    "title": "9  Phaser 3",
    "section": "",
    "text": "9.1 Características principales\nEn el capítulo anterior hemos aprendido los fundamentos de JavaScript, incluyendo su orientación a objetos, el manejo del DOM y BOM, y cómo configurar un entorno de desarrollo moderno con Node.js y Webpack. Ahora vamos a aplicar todos estos conocimientos para crear videojuegos web utilizando Phaser 3, uno de los frameworks más populares y potentes para el desarrollo de juegos en navegadores.\nPhaser 3 es un framework open source de HTML5 diseñado para la creación de videojuegos que se ejecutan directamente en navegadores web. Liberado en 2018, representa una evolución significativa respecto a versiones anteriores, ofreciendo un sistema más modular y potente para el desarrollo de juegos 2D. Phaser aprovecha todo lo que hemos aprendido sobre JavaScript: utiliza clases ES2015+ para estructurar el código, manipula el DOM para renderizar gráficos en el canvas, y se integra perfectamente con las herramientas de desarrollo modernas como npm y Webpack que ya conocemos.\nEl framework se caracteriza por su versatilidad y accesibilidad. Al estar basado en tecnologías web estándar (HTML5, JavaScript y Canvas/WebGL), permite crear juegos que no requieren instalación adicional por parte del usuario final. Esto facilita enormemente la distribución y accesibilidad de los juegos desarrollados.\nPhaser 3 soporta dos sistemas de renderizado: Canvas, que es el modo por defecto y el más compatible entre navegadores y dispositivos, y WebGL, que permite gráficos más avanzados pero requiere mayor soporte del hardware. La elección entre uno u otro dependerá de las necesidades específicas del proyecto y del público objetivo.\nEstá orientado tanto a escritorio como a dispositivos móviles, lo que lo convierte en una opción ideal para el desarrollo de juegos multiplataforma sin necesidad de reescribir código para diferentes sistemas operativos.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#requisitos-para-empezar",
    "href": "ch/part_client/phaser/phaser.html#requisitos-para-empezar",
    "title": "9  Phaser 3",
    "section": "9.2 Requisitos para empezar",
    "text": "9.2 Requisitos para empezar\nPara comenzar a desarrollar con Phaser 3 necesitamos:\n\nNavegador web\nCualquier navegador moderno funcionará, aunque se recomienda por orden de preferencia: Chrome, Firefox, Safari, Edge u Opera. Chrome suele ofrecer las mejores herramientas de desarrollo integradas.\n\n\nFramework Phaser 3\nPodemos obtenerlo de tres formas:\nDescarga directa: Desde https://phaser.io/download/stable\nRepositorio GitHub: https://github.com/photonstorm/phaser\nCDN (la más rápida para empezar):\n&lt;script src=\"//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js\"&gt;&lt;/script&gt;",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#estructura-básica-de-un-juego-en-phaser-3",
    "href": "ch/part_client/phaser/phaser.html#estructura-básica-de-un-juego-en-phaser-3",
    "title": "9  Phaser 3",
    "section": "9.3 Estructura básica de un juego en Phaser 3",
    "text": "9.3 Estructura básica de un juego en Phaser 3\n\nEl elemento Canvas\nPhaser utiliza el elemento HTML5 &lt;canvas&gt; para renderizar los gráficos del juego. Este elemento es una etiqueta de HTML5 que permite dibujar gráficos mediante JavaScript y CSS.\nEl canvas funciona como un lienzo en blanco donde podemos dibujar formas, imágenes y animaciones. A diferencia de un elemento &lt;img&gt;, el canvas no tiene atributos src ni alt, pero sí tiene width y height que definen el espacio de coordenadas (por defecto 300x300 píxeles).\nEl sistema de coordenadas del canvas coloca el origen (0,0) en la esquina superior izquierda, con el eje X positivo hacia la derecha y el eje Y positivo hacia abajo.\n\n\nConfiguración inicial del juego\nLa estructura mínima de un archivo HTML con Phaser tiene este aspecto:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;script src=\"phaser.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        var config = {\n            type: Phaser.AUTO,\n            width: 800,\n            height: 600,\n            physics: {\n                default: 'arcade',\n                arcade: {\n                    gravity: { y: 300 }\n                }\n            },\n            scene: {\n                preload: preload,\n                create: create,\n                update: update\n            }\n        };\n        \n        var game = new Phaser.Game(config);\n        \n        function preload() {\n            // Cargar recursos\n        }\n        \n        function create() {\n            // Crear objetos del juego\n        }\n        \n        function update() {\n            // Actualizar cada frame\n        }\n    &lt;/script&gt;\n\n    &lt;!-- También podemos cargar directamente el juego con la creación, etc. Recomendado. --&gt;\n    &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nObjeto de configuración\nEl objeto config es el punto de partida de cualquier juego en Phaser 3. Este objeto JavaScript define todos los parámetros fundamentales del juego: cómo se renderizará, qué tamaño tendrá, qué motor de físicas usará, y qué escenas contendrá. Es el equivalente a la “configuración inicial” o “settings” del juego.\nVeamos un ejemplo completo con las opciones más comunes:\nvar config = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 600,\n    backgroundColor: '#2d2d2d',\n    physics: {\n        default: 'arcade',\n        arcade: {\n            gravity: { y: 300 },\n            debug: false\n        }\n    },\n    scene: {\n        preload: preload,\n        create: create,\n        update: update\n    }\n};\n\nvar game = new Phaser.Game(config);\nExplicación detallada de cada propiedad:\n\ntype: Especifica el sistema de renderizado que Phaser usará para dibujar los gráficos. Las opciones son:\n\nPhaser.AUTO: Phaser elige automáticamente el mejor disponible (intenta WebGL primero, si no está disponible usa Canvas)\nPhaser.WEBGL: Fuerza el uso de WebGL (más rápido, gráficos avanzados, requiere soporte GPU)\nPhaser.CANVAS: Fuerza el uso de Canvas 2D (más compatible, funciona en dispositivos antiguos)\n\nRecomendación: Usar Phaser.AUTO en la mayoría de casos para máxima compatibilidad.\nwidth y height: Dimensiones del canvas en píxeles. Definen el área de juego visible. En el ejemplo, 800x600 píxeles es un tamaño clásico que funciona bien en la mayoría de pantallas. Otras opciones comunes:\n\n1024x768 para juegos más grandes\n320x240 para juegos retro de pixel art\nSe puede usar scale para hacer el juego responsive (más sobre esto en configuración avanzada)\n\nbackgroundColor: Color de fondo del canvas en formato hexadecimal. Si no se especifica, será negro por defecto. Útil para dar un estilo visual inicial antes de cargar recursos.\nphysics: Objeto de configuración del motor de físicas. Tiene dos propiedades principales:\n\ndefault: Motor de físicas a usar ('arcade', 'impact', o 'matter'). Arcade es el más usado por su simplicidad y rendimiento.\narcade: Objeto con configuración específica del motor Arcade Physics:\n\ngravity: Objeto con x e y que define la gravedad en píxeles/segundo². { y: 300 } simula gravedad terrestre hacia abajo. Si fuera { y: -300 } sería hacia arriba.\ndebug: Boolean. Si es true, muestra los contornos de los cuerpos físicos en verde/azul, muy útil durante desarrollo para visualizar colisiones.\n\n\nscene: Define las escenas del juego. Puede ser:\n\nUn objeto con las funciones preload, create, update (forma simple para juegos pequeños)\nUn array de clases de escena: scene: [MenuPrincipal, Juego, GameOver] (forma recomendada para juegos más complejos)\nUna sola clase: scene: MiEscena\n\n\n\n\nLas tres funciones principales\nTodo juego en Phaser 3 se estructura alrededor de tres funciones fundamentales que se ejecutan en un orden específico y cumplen roles claramente diferenciados. Estas funciones forman el ciclo de vida básico de una escena del juego.\npreload() - Carga de recursos\nEsta es la primera función que se ejecuta cuando se inicia una escena. Su propósito exclusivo es cargar todos los recursos (assets) que necesitará el juego: imágenes, spritesheets, audio, datos JSON, tilemaps, etc. Phaser ejecuta esta función y espera a que todos los recursos se carguen completamente antes de continuar con create().\nfunction preload() {\n    // Cargar imágenes individuales\n    this.load.image('cielo', 'assets/cielo.png');\n    this.load.image('suelo', 'assets/plataforma.png');\n    this.load.image('estrella', 'assets/estrella.png');\n\n    // Cargar spritesheets para animaciones\n    this.load.spritesheet('jugador', 'assets/jugador.png', {\n        frameWidth: 32,\n        frameHeight: 48\n    });\n\n    // Cargar audio\n    this.load.audio('musica', 'assets/musica.mp3');\n}\nCada recurso se identifica con una clave única (‘cielo’, ‘suelo’, ‘estrella’) que usaremos después para referenciarlos en el juego. Es crucial cargar todos los recursos aquí para evitar problemas de recursos no disponibles durante el juego.\nOtros tipos de recursos: Phaser 3 soporta muchos más tipos de recursos como atlas de texturas, tilemaps, fuentes de bitmap, videos, plugins, shaders y más. Para una lista completa de métodos de carga, consulta la documentación oficial de Phaser 3 Loader.\ncreate() - Inicialización del juego\nSe ejecuta una sola vez después de que preload() haya terminado de cargar todos los recursos. Aquí creamos e inicializamos todos los objetos del juego: colocamos sprites, creamos grupos, configuramos físicas, establecemos colisiones, inicializamos variables, y preparamos todo el estado inicial del juego.\nfunction create() {\n    // Añadir fondo (imagen estática sin físicas)\n    this.add.image(400, 300, 'cielo');\n\n    // Crear plataforma con físicas\n    var plataforma = this.physics.add.image(400, 500, 'suelo');\n    plataforma.setImmovable(true);          // No se mueve al colisionar\n    plataforma.setCollideWorldBounds(true); // No sale de los límites\n\n    // Crear jugador\n    this.jugador = this.physics.add.sprite(100, 450, 'jugador');\n    this.jugador.setBounce(0.2);\n    this.jugador.setCollideWorldBounds(true);\n\n    // Configurar colisión entre jugador y plataforma\n    this.physics.add.collider(this.jugador, plataforma);\n\n    // Configurar controles\n    this.cursors = this.input.keyboard.createCursorKeys();\n\n    // Inicializar puntuación\n    this.puntuacion = 0;\n    this.textoPuntuacion = this.add.text(16, 16, 'Puntos: 0', {\n        fontSize: '32px',\n        fill: '#000'\n    });\n}\nEl orden de creación es importante: los elementos se renderizan en el orden en que se añaden, por lo que si queremos que algo aparezca sobre otra cosa, debemos crearlo después. Observa cómo primero añadimos el fondo, luego las plataformas y finalmente el jugador y el texto, asegurando que cada elemento aparezca en la capa visual correcta.\nupdate(time, delta) - Bucle principal del juego\nEsta función se ejecuta continuamente, aproximadamente 60 veces por segundo (60 FPS), formando el bucle principal del juego (game loop). Aquí colocamos toda la lógica que debe actualizarse constantemente: movimiento del jugador, comportamiento de enemigos, detección de condiciones de victoria o derrota, actualización de puntuación, etc.\nLos parámetros son:\n\ntime: Tiempo total transcurrido desde que se inició el juego, en milisegundos\ndelta: Tiempo transcurrido desde el último frame, en milisegundos (normalmente ~16ms a 60 FPS)\n\nfunction update(time, delta) {\n    // Resetear velocidad horizontal\n    this.jugador.setVelocityX(0);\n\n    // Movimiento izquierda/derecha\n    if (this.cursors.left.isDown) {\n        this.jugador.setVelocityX(-160);\n        this.jugador.anims.play('izquierda', true);\n    } else if (this.cursors.right.isDown) {\n        this.jugador.setVelocityX(160);\n        this.jugador.anims.play('derecha', true);\n    } else {\n        this.jugador.anims.play('quieto');\n    }\n\n    // Saltar solo si está tocando el suelo\n    if (this.cursors.up.isDown && this.jugador.body.touching.down) {\n        this.jugador.setVelocityY(-330);\n    }\n\n    // Usar delta para movimiento independiente de framerate\n    // this.enemigo.x += (100 * delta / 1000); // 100 píxeles por segundo\n}\nEs importante resetear velocidades o estados al inicio de update() para evitar que se acumulen. En el ejemplo, reseteamos la velocidad horizontal a 0 para que el jugador se detenga cuando no se presiona ninguna tecla.\nEl parámetro delta es especialmente útil para movimientos independientes del framerate: si multiplicamos velocidades por delta / 1000, el movimiento será consistente incluso si el juego no mantiene exactamente 60 FPS. Esto es crucial para que el juego se comporte igual en diferentes dispositivos con distintas capacidades de procesamiento.\nResumen del flujo de ejecución:\n\npreload() → Carga recursos una vez al inicio\ncreate() → Inicializa objetos y configuración una vez después de la carga\nupdate() → Se ejecuta continuamente 60 veces por segundo durante todo el juego",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#gestión-de-escenas",
    "href": "ch/part_client/phaser/phaser.html#gestión-de-escenas",
    "title": "9  Phaser 3",
    "section": "9.4 Gestión de escenas",
    "text": "9.4 Gestión de escenas\n\nConcepto de escena\nUna escena en Phaser 3 es una unidad autónoma y autocontenida que representa un estado o pantalla específica del juego. Podemos pensar en las escenas como los diferentes “momentos” o “pantallas” por los que pasa un jugador: el menú principal, la pantalla de carga, cada nivel del juego, el menú de pausa, la pantalla de game over, la tabla de puntuaciones, etc.\nLo revolucionario del sistema de escenas es que cada una es completamente independiente: tiene su propio ciclo de vida con sus propias funciones preload(), create() y update(), mantiene sus propios objetos del juego (sprites, grupos, texto, etc.), gestiona su propia lógica, y puede cargar sus propios recursos específicos. Esta arquitectura modular tiene ventajas enormes:\nOrganización del código: En lugar de tener todo el código del juego en un único archivo gigante, podemos separarlo en escenas lógicas. Por ejemplo, MenuPrincipal.js, Nivel1.js, Nivel2.js, GameOver.js. Esto hace que el código sea mucho más fácil de entender, mantener y depurar.\nReutilización: Podemos tener una escena genérica de pausa que se lance sobre cualquier nivel de juego, o una escena de transición que se use entre diferentes niveles.\nGestión de memoria: Cuando una escena termina, Phaser puede limpiar automáticamente todos sus recursos, liberando memoria. Esto es crucial para juegos grandes con muchos niveles.\nDesarrollo en equipo: Diferentes programadores pueden trabajar en diferentes escenas simultáneamente sin pisarse el código entre sí.\nEjemplo de estructura típica de un juego:\n// Escena 1: Pantalla de carga inicial\nclass Boot extends Phaser.Scene {\n    preload() {\n        // Cargar recursos mínimos (logo, barra de carga)\n    }\n    create() {\n        this.scene.start('MenuPrincipal');\n    }\n}\n\n// Escena 2: Menú principal\nclass MenuPrincipal extends Phaser.Scene {\n    create() {\n        // Mostrar título, botones de jugar, opciones, créditos\n    }\n}\n\n// Escena 3: El juego real\nclass Nivel1 extends Phaser.Scene {\n    preload() {\n        // Cargar recursos específicos del nivel 1\n    }\n    create() {\n        // Crear plataformas, enemigos, jugador\n    }\n    update() {\n        // Lógica del juego\n    }\n}\n\n// Escena 4: Pantalla final\nclass GameOver extends Phaser.Scene {\n    create() {\n        // Mostrar puntuación final, botón para reiniciar\n    }\n}\nCada escena es una clase que extiende Phaser.Scene, permitiendo aprovechar la orientación a objetos de JavaScript que aprendimos en el capítulo anterior.\n\n\nSceneManager\nPhaser 3 incluye un SceneManager que se encarga de gestionar el ciclo de vida de todas las escenas del juego: iniciarlas, pausarlas, detenerlas y cambiar entre ellas. Este gestor nos proporciona una API sencilla para controlar el flujo del juego.\nPara configurar las escenas de nuestro juego, las definimos en el objeto de configuración inicial:\nvar config = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 600,\n    physics: {\n        default: 'arcade',\n        arcade: {\n            gravity: { y: 300 }\n        }\n    },\n    scene: [Boot, MenuPrincipal, Nivel1, Nivel2, GameOver]\n};\n\nvar game = new Phaser.Game(config);\nEl array de escenas define todas las escenas disponibles en el juego. Importante: La primera escena del array (Boot en este ejemplo) es la que se iniciará automáticamente cuando arranque el juego. El orden de las demás escenas no importa, ya que las activaremos explícitamente cuando las necesitemos.\n\n\nGestionar escenas\nPhaser ofrece múltiples formas de controlar el estado de las escenas:\n// Iniciar una escena (apaga la actual)\nthis.scene.start('clave', datos);\n\n// Lanzar en paralelo (mantiene la actual)\nthis.scene.launch('clave', datos);\n\n// Pausar (detiene update pero sigue renderizando)\nthis.scene.pause('clave');\n\n// Reanudar una escena pausada\nthis.scene.resume('clave');\n\n// Dormir (detiene update y renderizado)\nthis.scene.sleep('clave');\n\n// Despertar una escena dormida\nthis.scene.wake('clave');\n\n// Detener completamente (limpia recursos)\nthis.scene.stop('clave');\nLa diferencia clave entre start y launch es que start detiene la escena actual, mientras que launch permite ejecutar múltiples escenas simultáneamente. Esto es útil para mostrar interfaces como menús de pausa sobre el juego activo.\n\nTransiciones entre escenas\nPodemos crear transiciones visuales suaves entre escenas:\nthis.scene.transition({\n    target: 'SiguienteEscena',\n    duration: 1000,  // Duración en milisegundos\n    moveBelow: true,\n    onUpdate: (progress) =&gt; {\n        // Código durante la transición\n    }\n});\nLa función onUpdate se ejecuta durante toda la transición, recibiendo un valor progress que va de 0 a 1, permitiendo crear efectos visuales personalizados como fundidos o desvanecimientos.\n\n\nReordenar escenas\nLas escenas tienen un orden de renderizado que puede modificarse:\n// Mover arriba/abajo en la pila\nthis.scene.moveUp('clave');\nthis.scene.moveDown('clave');\n\n// Intercambiar posición de dos escenas\nthis.scene.swapPosition('claveA', 'claveB');\n\n// Mover encima/debajo de otra escena\nthis.scene.moveAbove('clave', 'claveReferencia');\nthis.scene.moveBelow('clave', 'claveReferencia');\n\n// Traer al frente o enviar al fondo\nthis.scene.bringToTop('clave');\nthis.scene.sendToBack('clave');\nEl orden de renderizado determina qué escenas se dibujan sobre otras. Esto es especialmente útil cuando se ejecutan múltiples escenas en paralelo, como un HUD sobre la pantalla de juego.\nEjemplo práctico: Sistema de menú con pausa\nclass Juego extends Phaser.Scene {\n    constructor() {\n        super('Juego');\n    }\n    \n    create() {\n        // Configurar el juego\n        this.input.keyboard.on('keydown-ESC', () =&gt; {\n            this.scene.pause();\n            this.scene.launch('MenuPausa');\n        });\n    }\n}\n\nclass MenuPausa extends Phaser.Scene {\n    constructor() {\n        super('MenuPausa');\n    }\n    \n    create() {\n        let botonContinuar = this.add.text(400, 300, 'Continuar');\n        botonContinuar.setInteractive();\n        \n        botonContinuar.on('pointerdown', () =&gt; {\n            this.scene.stop();\n            this.scene.resume('Juego');\n        });\n    }\n}\nEste ejemplo muestra cómo implementar un sistema de pausa: cuando el jugador pulsa ESC durante el juego, se pausa la escena principal y se lanza el menú de pausa sobre ella. Al hacer clic en “Continuar”, el menú se cierra y el juego se reanuda desde donde estaba.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#trabajo-con-imágenes",
    "href": "ch/part_client/phaser/phaser.html#trabajo-con-imágenes",
    "title": "9  Phaser 3",
    "section": "9.5 Trabajo con imágenes",
    "text": "9.5 Trabajo con imágenes\n\nCargar y mostrar imágenes\nLas imágenes son elementos fundamentales en cualquier juego. En Phaser, primero debemos cargarlas en preload() y luego añadirlas al juego en create():\nfunction preload() {\n    // Cargar la imagen con un identificador único\n    this.load.image('personaje', 'assets/personaje.png');\n    this.load.image('fondo', 'assets/fondo.jpg');\n}\n\nfunction create() {\n    // Añadir la imagen al canvas en posición (x, y)\n    this.add.image(400, 300, 'fondo');\n    let sprite = this.add.image(200, 150, 'personaje');\n}\nEs importante cargar las imágenes en preload() para garantizar que estén disponibles antes de intentar usarlas. El identificador que asignamos (‘personaje’, ‘fondo’) es la clave que utilizaremos después para referenciar estas imágenes.\n\n\nSistema de coordenadas y origen\nPor defecto, todas las imágenes se posicionan usando su centro como punto de referencia. Podemos cambiar este comportamiento:\n// Establecer el origen en la esquina superior izquierda\nlet imagen = this.add.image(100, 100, 'personaje').setOrigin(0, 0);\n\n// Origen en el centro inferior\nlet imagen2 = this.add.image(200, 200, 'personaje').setOrigin(0.5, 1);\nLos valores de origen van de 0 a 1, donde (0,0) es la esquina superior izquierda y (1,1) es la inferior derecha de la imagen. Cambiar el origen es útil para alinear objetos o hacer que roten alrededor de puntos específicos.\n\n\nTransformaciones básicas\nfunction create() {\n    let jugador = this.add.image(400, 300, 'personaje');\n    \n    // Escalar la imagen (0.5 = mitad del tamaño, 2 = doble)\n    jugador.setScale(1.5);\n    \n    // Escalar de forma independiente en X e Y\n    jugador.setScale(2, 0.5);\n    \n    // Voltear horizontalmente\n    jugador.flipX = true;\n    \n    // Voltear verticalmente\n    jugador.flipY = true;\n    \n    // Rotar (en radianes)\n    jugador.rotation = Math.PI / 4; // 45 grados\n    \n    // Cambiar profundidad (controla qué se dibuja encima)\n    jugador.depth = 10;\n}\nEl escalado independiente en X e Y permite crear efectos de estiramiento. La propiedad depth funciona como las capas en programas de diseño: valores mayores se dibujan sobre valores menores. Para convertir grados a radianes, recordemos que π radianes = 180 grados.\nEjemplo práctico: Sprite que sigue al ratón\nlet jugador;\n\nfunction create() {\n    jugador = this.add.image(400, 300, 'nave');\n}\n\nfunction update() {\n    // Obtener posición del ratón\n    let pointer = this.input.activePointer;\n    \n    // Mover suavemente hacia el ratón\n    jugador.x += (pointer.x - jugador.x) * 0.1;\n    jugador.y += (pointer.y - jugador.y) * 0.1;\n    \n    // Rotar hacia la dirección del movimiento\n    let angulo = Phaser.Math.Angle.Between(\n        jugador.x, jugador.y, \n        pointer.x, pointer.y\n    );\n    jugador.rotation = angulo;\n}\nEste ejemplo crea un efecto de seguimiento suave: en lugar de mover el sprite directamente a la posición del ratón, solo se desplaza el 10% de la distancia en cada frame (multiplicador 0.1). Esto produce un movimiento más natural y fluido. La función Angle.Between calcula automáticamente el ángulo necesario para que el sprite “mire” hacia el cursor.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#motores-de-físicas-en-phaser-3",
    "href": "ch/part_client/phaser/phaser.html#motores-de-físicas-en-phaser-3",
    "title": "9  Phaser 3",
    "section": "9.6 Motores de físicas en Phaser 3",
    "text": "9.6 Motores de físicas en Phaser 3\nLos motores de físicas son componentes esenciales en el desarrollo de videojuegos que simulan el comportamiento del mundo real: gravedad, colisiones, rebotes, fricción y fuerzas. Sin un motor de físicas, tendríamos que programar manualmente cada uno de estos comportamientos, lo cual sería extremadamente complejo y propenso a errores. Un motor de físicas nos proporciona estas funcionalidades de manera optimizada y consistente.\nPhaser 3 incluye tres motores de físicas diferentes, cada uno diseñado para diferentes niveles de complejidad y casos de uso específicos. La elección del motor adecuado dependerá del tipo de juego que estemos desarrollando y del nivel de realismo físico que necesitemos.\n\nArcade Physics\nEs el motor de físicas más simple y el que utilizaremos principalmente. Está optimizado para rendimiento y es perfecto para la mayoría de juegos 2D.\nCaracterísticas:\n\nSolo soporta colisiones con rectángulos y círculos\nMuy eficiente y rápido\nIdeal para juegos arcade clásicos, plataformas simples, etc.\n\nvar config = {\n    physics: {\n        default: 'arcade',\n        arcade: {\n            gravity: { y: 300 },\n            debug: false\n        }\n    }\n};\nLa gravedad se especifica en píxeles por segundo al cuadrado. Un valor de 300 simula una gravedad similar a la terrestre para juegos de plataformas. El modo debug: true muestra los contornos de los cuerpos físicos, muy útil durante el desarrollo.\nEn todos los ejemplos usaremos el motor Arcade, para los otros motores podría ser necesario hacer cambios.\n\n\nImpact Physics\nOriginalmente creado para el motor Impact, permite físicas más complejas que Arcade.\nCaracterísticas:\n\nSoporta pendientes en tiles (muy útil para plataformas)\nMás complejo que Arcade pero menos que Matter\nBueno para juegos de plataformas con terrenos inclinados\n\n\n\nMatter Physics\nEs el motor más avanzado y realista de los tres.\nCaracterísticas:\n\nSoporta formas complejas y polígonos\nSimulación física muy precisa\nMayor costo de rendimiento\nIdeal para puzzles físicos, juegos que requieren realismo\n\n\n\nAñadir físicas a objetos\nPara que un objeto tenga físicas, debe crearse usando physics.add en lugar de solo add:\nfunction create() {\n    // Imagen simple sin físicas\n    this.add.image(400, 300, 'fondo');\n    \n    // Imagen con físicas\n    this.jugador = this.physics.add.image(100, 450, 'personaje');\n    \n    // Configurar propiedades físicas\n    this.jugador.setCollideWorldBounds(true);  // No salir del canvas\n    this.jugador.setBounce(0.3);               // Rebote (0-1)\n    this.jugador.setVelocity(100, -50);        // Velocidad inicial\n    this.jugador.setAcceleration(50, 0);       // Aceleración\n}\nEl rebote (bounce) determina cuánta energía conserva el objeto al chocar: 0 significa que no rebota, 1 que rebota perfectamente sin perder energía. La velocidad se mide en píxeles por segundo, mientras que la aceleración en píxeles por segundo al cuadrado.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#sistema-de-entrada-input",
    "href": "ch/part_client/phaser/phaser.html#sistema-de-entrada-input",
    "title": "9  Phaser 3",
    "section": "9.7 Sistema de entrada (Input)",
    "text": "9.7 Sistema de entrada (Input)\nLa interacción del jugador es el corazón de cualquier videojuego. En el capítulo de JavaScript aprendimos sobre el sistema de eventos del DOM para detectar clics y pulsaciones de teclas. Phaser 3 construye sobre estos conceptos y proporciona un sistema de entrada (input) mucho más potente y especializado para videojuegos, que simplifica la detección de teclado, ratón, táctil y gamepad.\nEl sistema de input de Phaser 3 unifica diferentes tipos de entrada bajo una API consistente, permitiendo que nuestro juego funcione tanto en escritorio (con teclado y ratón) como en dispositivos móviles (con pantalla táctil) sin necesidad de escribir código específico para cada plataforma. Además, Phaser optimiza la detección de entrada para el contexto de videojuegos, donde necesitamos respuestas instantáneas y la capacidad de detectar múltiples entradas simultáneas.\n\nTeclado\n\nDetección de teclas individuales\nfunction create() {\n    // Método 1: Eventos de teclas específicas\n    this.input.keyboard.on('keydown-SPACE', () =&gt; {\n        console.log('¡Salto!');\n    });\n    \n    // Detectar cuando se suelta la tecla\n    this.input.keyboard.on('keyup-SPACE', () =&gt; {\n        console.log('Tecla soltada');\n    });\n}\nEl evento keydown se dispara en el momento exacto que se presiona la tecla, mientras que keyup lo hace al soltarla. Esto es útil para acciones instantáneas como saltos o disparos.\n\n\nUso de cursores\nlet jugador;\nlet cursors;\n\nfunction create() {\n    jugador = this.physics.add.image(400, 300, 'personaje');\n    \n    // Crear objeto de cursores (flechas + espacio + shift)\n    cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update() {\n    // Resetear velocidad\n    jugador.setVelocityX(0);\n    \n    // Comprobar teclas presionadas\n    if (cursors.left.isDown) {\n        jugador.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n        jugador.setVelocityX(160);\n    }\n    \n    if (cursors.up.isDown && jugador.body.touching.down) {\n        jugador.setVelocityY(-330);\n    }\n}\nEs importante resetear la velocidad horizontal en cada frame para que el personaje se detenga inmediatamente al soltar las teclas. La condición jugador.body.touching.down evita el salto infinito, permitiendo saltar solo cuando el jugador toca el suelo.\n\n\nTeclas con modificadores\nfunction create() {\n    this.input.keyboard.on('keydown-A', (event) =&gt; {\n        if (event.ctrlKey) {\n            console.log('CTRL + A: Seleccionar todo');\n        } else if (event.altKey) {\n            console.log('ALT + A: Acción alternativa');\n        } else if (event.shiftKey) {\n            console.log('SHIFT + A: Acción mayúscula');\n        } else {\n            console.log('Solo A');\n        }\n    });\n}\nLos modificadores permiten crear atajos de teclado complejos. El objeto event contiene propiedades booleanas para cada modificador (ctrlKey, altKey, shiftKey), permitiendo detectar combinaciones de teclas.\n\n\nCombos de teclas\nfunction create() {\n    // Combo con letras\n    let combo1 = this.input.keyboard.createCombo('KONAMI');\n    \n    // Combo con keycodes (arriba, arriba, abajo, abajo, izq, der, izq, der)\n    let combo2 = this.input.keyboard.createCombo([38, 38, 40, 40, 37, 39, 37, 39]);\n    \n    // Detectar cuando se completa el combo\n    this.input.keyboard.on('keycombomatch', (combo) =&gt; {\n        console.log('¡Combo desbloqueado!');\n        this.activarModoEspecial();\n    });\n}\nLos combos permiten implementar códigos secretos o trucos. El sistema detecta automáticamente cuando el jugador presiona la secuencia correcta de teclas en orden. El segundo ejemplo muestra el famoso código Konami usando los valores numéricos de las teclas de dirección.\n\n\n\nRatón\n\nEventos básicos del ratón\nfunction create() {\n    // Detectar clic\n    this.input.on('pointerdown', (pointer) =&gt; {\n        if (pointer.leftButtonDown()) {\n            console.log('Clic izquierdo en:', pointer.x, pointer.y);\n        }\n        \n        if (pointer.rightButtonDown()) {\n            console.log('Clic derecho');\n        }\n    });\n    \n    // Detectar cuando se suelta\n    this.input.on('pointerup', (pointer) =&gt; {\n        console.log('Botón soltado');\n    });\n    \n    // Detectar movimiento\n    this.input.on('pointermove', (pointer) =&gt; {\n        console.log('Ratón movido a:', pointer.x, pointer.y);\n    });\n}\nEl sistema de punteros unifica ratón y táctil bajo la misma API. El objeto pointer contiene las coordenadas (x, y) y métodos para detectar qué botón se ha pulsado.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_client/phaser/phaser.html#detección-de-colisiones",
    "href": "ch/part_client/phaser/phaser.html#detección-de-colisiones",
    "title": "9  Phaser 3",
    "section": "9.8 Detección de colisiones",
    "text": "9.8 Detección de colisiones\nLa detección de colisiones es uno de los aspectos más fundamentales en el desarrollo de videojuegos. Determina cuándo dos objetos del juego se tocan o superponen, permitiendo implementar mecánicas como que el jugador camine sobre plataformas, recoja objetos, reciba daño de enemigos, o dispare proyectiles que impacten en objetivos. Sin un sistema robusto de detección de colisiones, los objetos del juego simplemente se atravesarían unos a otros sin ningún tipo de interacción.\nPhaser 3, a través de su sistema Arcade Physics, proporciona herramientas optimizadas para detectar y responder a colisiones de manera eficiente. El sistema está diseñado para manejar desde colisiones simples entre dos objetos hasta complejas interacciones entre grupos de cientos de entidades, todo ello manteniendo un rendimiento fluido de 60 frames por segundo.\n\nConceptos básicos\nPhaser 3 Arcade Physics ofrece dos formas fundamentales de detectar interacciones entre objetos:\nCollider: Detecta y resuelve colisiones físicamente, separando los objetos y aplicando propiedades como masa, velocidad y rebote.\nOverlap: Detecta superposición espacial sin resolución física. Los objetos pueden atravesarse.\n\n\nColisiones básicas\nfunction create() {\n    let jugador = this.physics.add.image(100, 450, 'personaje');\n    let plataforma = this.physics.add.image(400, 500, 'suelo');\n    plataforma.setImmovable(true);\n    \n    // Colisión con resolución física\n    this.physics.add.collider(jugador, plataforma);\n    \n    // Overlap sin resolución física\n    let estrella = this.physics.add.image(200, 200, 'estrella');\n    this.physics.add.overlap(jugador, estrella, (j, e) =&gt; {\n        e.destroy();\n        console.log('¡Estrella recogida!');\n    });\n}\nLa propiedad setImmovable(true) hace que la plataforma no se mueva al recibir impactos. Sin esto, el jugador empujaría la plataforma al caer sobre ella. Los colliders son ideales para plataformas y paredes, mientras que los overlaps funcionan bien para objetos coleccionables.\n\n\nTrabajar con grupos\n\nGrupos estáticos\nIdeales para objetos inmóviles como plataformas:\nfunction create() {\n    let jugador = this.physics.add.image(100, 450, 'personaje');\n    \n    let plataformas = this.physics.add.staticGroup();\n    plataformas.create(400, 568, 'suelo').setScale(2).refreshBody();\n    plataformas.create(600, 400, 'suelo');\n    plataformas.create(50, 250, 'suelo');\n    \n    this.physics.add.collider(jugador, plataformas);\n}\nLos grupos estáticos son más eficientes para objetos que nunca se moverán. Tras modificar propiedades de un objeto estático (como setScale), es crucial llamar a refreshBody() para actualizar su cuerpo físico.\n\n\nGrupos dinámicos\nPara objetos con físicas completas:\nfunction create() {\n    let jugador = this.physics.add.image(100, 450, 'personaje');\n    \n    let estrellas = this.physics.add.group({\n        key: 'estrella',\n        repeat: 11,\n        setXY: { x: 12, y: 0, stepX: 70 }\n    });\n    \n    estrellas.children.iterate((estrella) =&gt; {\n        estrella.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));\n    });\n    \n    this.physics.add.overlap(jugador, estrellas, (j, e) =&gt; {\n        e.disableBody(true, true);\n    });\n}\nEste código crea 12 estrellas (repeat: 11 significa el objeto inicial más 11 repeticiones) espaciadas horizontalmente cada 70 píxeles. La función iterate aplica un rebote aleatorio a cada estrella. El método disableBody(true, true) oculta y desactiva la estrella sin destruirla completamente, lo que es más eficiente para objetos que pueden reutilizarse.\n\n\n\nCallbacks y condiciones\n\nCallback de colisión\nthis.physics.add.collider(jugador, enemigo, (j, e) =&gt; {\n    console.log('¡Colisión!');\n    j.setTint(0xff0000);\n    j.setVelocityX(-200);\n});\nEl callback se ejecuta cada vez que ocurre la colisión. En este ejemplo, el jugador se tiñe de rojo y retrocede al tocar al enemigo. Los parámetros del callback son los dos objetos que colisionaron.\n\n\nProcess callback (condición)\nEl process callback decide si procesar la colisión. Retorna true para procesarla, false para ignorarla:\nfunction create() {\n    this.jugador = this.physics.add.image(100, 450, 'personaje');\n    this.jugador.invulnerable = false;\n    \n    let enemigo = this.physics.add.image(400, 300, 'enemigo');\n    \n    this.physics.add.collider(\n        this.jugador,\n        enemigo,\n        this.dañar,\n        this.puedeRecibirDanio,\n        this\n    );\n}\n\nfunction puedeRecibirDanio(jugador, enemigo) {\n    return !jugador.invulnerable;\n}\n\nfunction dañar(jugador, enemigo) {\n    jugador.invulnerable = true;\n    jugador.setTint(0xff0000);\n    this.time.delayedCall(2000, () =&gt; {\n        jugador.invulnerable = false;\n        jugador.clearTint();\n    });\n}\nEste sistema implementa un período de invulnerabilidad temporal: tras recibir daño, el jugador se vuelve inmune durante 2 segundos (2000 milisegundos). El process callback puedeRecibirDanio se ejecuta antes de la colisión y determina si debe procesarse según el estado de invulnerabilidad.\n\n\n\nColisiones entre grupos\nfunction create() {\n    this.balas = this.physics.add.group();\n    this.enemigos = this.physics.add.group({\n        key: 'enemigo',\n        repeat: 5,\n        setXY: { x: 100, y: 100, stepX: 100 }\n    });\n    \n    // Colisión grupo contra grupo\n    this.physics.add.collider(this.balas, this.enemigos, (bala, enemigo) =&gt; {\n        bala.destroy();\n        enemigo.destroy();\n    });\n}\nLas colisiones entre grupos permiten que cualquier miembro de un grupo colisione con cualquier miembro del otro grupo. Aquí, cada bala puede impactar a cualquier enemigo, destruyendo ambos objetos en el proceso. Esto es mucho más eficiente que crear colliders individuales para cada combinación posible.\n\n\nDetectar colisiones específicas\nfunction update() {\n    // Verificar contacto con superficies\n    if (this.jugador.body.touching.down) {\n        console.log('En el suelo');\n    }\n    \n    // Salto solo si está en el suelo\n    if (this.cursors.up.isDown && this.jugador.body.touching.down) {\n        this.jugador.setVelocityY(-330);\n    }\n}\nPropiedades útiles: touching.down, touching.up, touching.left, touching.right, blocked.down, blocked.up. La diferencia entre touching y blocked es que touching detecta contacto con cualquier objeto, mientras que blocked solo detecta contacto con objetos inmóviles. Estas propiedades son esenciales para controlar mecánicas como saltos o detectar si un personaje está contra una pared.",
    "crumbs": [
      "Desarrollo en el cliente",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Phaser 3</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/part_intro_rest.html",
    "href": "ch/part_servercoms/part_intro_rest.html",
    "title": "Desarrollo en el lado del servidor",
    "section": "",
    "text": "Para crear juegos multijugador verdaderamente funcionales, necesitamos implementar el lado del servidor que gestione la lógica del juego, la persistencia de datos y las interacciones entre jugadores. En esta parte del curso nos sumergiremos en el desarrollo de APIs REST utilizando Node.js y Express, aprendiendo a diseñar endpoints eficientes, implementar middleware, gestionar errores y validar datos. Comenzaremos comprendiendo los principios de la arquitectura REST y los métodos HTTP fundamentales, para luego consumir APIs desde el cliente utilizando la Fetch API y técnicas asíncronas como promesas y async/await. Finalmente, desarrollaremos nuestras propias APIs REST completas que servirán como backend para nuestros juegos, manejando la lógica de negocio y la persistencia de información del juego de forma robusta y escalable.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "Desarrollo en el lado del servidor"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html",
    "href": "ch/part_servercoms/rest/rest_intro.html",
    "title": "10  API REST",
    "section": "",
    "text": "10.1 Introducción\nEn el desarrollo de juegos multijugador modernos, la comunicación entre el cliente y el servidor es fundamental. Después de haber implementado un juego con Phaser 3 el siguiente paso natural es conectar nuestro juego con un servidor mediante una API REST.\nEn una aplicación web tradicional, el cliente (navegador) se comunica con el servidor utilizando el protocolo HTTP. En aplicaciones web sin AJAX, las peticiones HTTP devuelven un documento HTML que será visualizado por el navegador. Sin embargo, en las aplicaciones con AJAX y las aplicaciones SPA (Single Page Application), las peticiones HTTP se utilizan para intercambiar información entre el navegador y el servidor, pero no HTML.\nLas APIs REST permiten esta comunicación mediante el intercambio de datos estructurados. En el contexto de nuestro juego, necesitaremos la API REST para gestionar registro y autenticación de jugadores, almacenamiento de puntuaciones y estadísticas, gestión de partidas y salas de juego, configuración de perfiles de usuario, y consulta de rankings. Posteriormente, cuando implementemos WebSockets, usaremos esa tecnología para la comunicación en tiempo real durante el juego, pero la API REST seguirá siendo esencial para todas las operaciones que no requieren actualización instantánea.\nImaginemos nuestra aplicación de juego haciendo una petición HTTP para obtener información de un jugador:",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#introducción",
    "href": "ch/part_servercoms/rest/rest_intro.html#introducción",
    "title": "10  API REST",
    "section": "",
    "text": "Petición:\nGET http://www.mygame.com/players/alice\n\nRespuesta:\n{\n  \"id\": \"alice\",\n  \"name\": \"Alice Smith\",\n  \"level\": 15,\n  \"score\": 8500,\n  \"achievements\": [\"first_win\", \"speed_demon\"]\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#qué-es-una-api-rest",
    "href": "ch/part_servercoms/rest/rest_intro.html#qué-es-una-api-rest",
    "title": "10  API REST",
    "section": "10.2 ¿Qué es una API REST?",
    "text": "10.2 ¿Qué es una API REST?\nREST es un estilo de arquitectura de software basado en HTTP que sigue una serie de principios específicos. Cuando un servicio web cumple estos principios, se denomina RESTful. Una API REST es el servicio que devuelve un servidor web cuando quiere intercambiar información estructurada en lugar de devolver HTML.\nEl término REST fue acuñado en el año 2000 por Roy Fielding, uno de los principales autores de la especificación del protocolo HTTP, en su tesis doctoral. Aunque existen otros tipos de servicios web como SOAP (basados en XML y mucho más complejos), las APIs REST se han convertido en el estándar de facto debido a su simplicidad y eficiencia.\n\nNiveles de madurez REST\nExiste un modelo de madurez de Richardson que clasifica las APIs en 4 niveles según su conformidad con los principios REST:\nNivel 0 - The Swamp of POX (Plain Old XML): En este nivel más básico, se usa HTTP simplemente como un sistema de transporte para llamadas a procedimientos remotos. Toda la comunicación se realiza típicamente mediante peticiones POST a una única URL, y el cuerpo de la petición contiene información sobre qué operación realizar. Es similar a usar HTTP como un túnel para otros protocolos (como SOAP). No se aprovecha ninguna característica del protocolo HTTP más allá del transporte.\nNivel 1 - Resources: En este nivel, la API introduce el concepto de recursos individuales. En lugar de tener una única URL para todo, cada recurso tiene su propia URI específica. Por ejemplo, /players/alice y /matches/123 son URIs distintas para recursos diferentes. Sin embargo, todavía se usan métodos HTTP de forma incorrecta, típicamente solo POST para todas las operaciones, sin aprovechar la semántica de GET, PUT, DELETE, etc.\nNivel 2 - HTTP Verbs: Este es el nivel más común y el que usaremos en este curso. Aquí se utilizan correctamente los métodos HTTP (GET para obtener, POST para crear, PUT para actualizar, DELETE para eliminar) y los códigos de estado HTTP (200 para éxito, 404 para no encontrado, 500 para error del servidor, etc.). Este nivel aprovecha plenamente la semántica del protocolo HTTP, haciendo que las APIs sean más intuitivas y fáciles de usar.\nNivel 3 - Hypermedia Controls (HATEOAS): El nivel más avanzado, donde las respuestas incluyen enlaces hipermedia que guían al cliente sobre qué acciones puede realizar a continuación. Por ejemplo, al obtener información de un jugador, la respuesta incluiría enlaces a recursos relacionados como sus partidas, amigos, o acciones disponibles. Este nivel permite que los clientes descubran dinámicamente la API, aunque en la práctica pocas APIs implementan HATEOAS por su complejidad.\nEn este curso nos centraremos en el Nivel 2 (HTTP Verbs), que es el enfoque más habitual y práctico, donde se hace uso correcto de los métodos HTTP (GET, POST, PUT, DELETE) y códigos de estado.\nUn servicio REST ofrece operaciones CRUD (Create, Read, Update, Delete) sobre recursos (ítems de información) del servidor web. Se aprovecha de todos los aspectos del protocolo HTTP: URL, métodos, códigos de estado, cabeceras, etc. La información se intercambia típicamente en formato JSON.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#casos-de-uso-de-apis-rest",
    "href": "ch/part_servercoms/rest/rest_intro.html#casos-de-uso-de-apis-rest",
    "title": "10  API REST",
    "section": "10.3 Casos de Uso de APIs REST",
    "text": "10.3 Casos de Uso de APIs REST\nAdemás de navegadores web, muchos otros tipos de aplicaciones utilizan APIs REST. Las aplicaciones móviles son consumidoras intensivas: la aplicación de Google Maps para Android usa la misma API REST que la versión web, permitiendo mantener una única fuente de verdad en el servidor y consistencia entre plataformas. En comunicación Backend a Backend, un servidor puede consumir APIs REST de otros servidores; por ejemplo, el Aula Virtual de la URJC podría usar la API REST de Google Calendar para publicar eventos. Los videojuegos multijugador utilizan APIs REST para sincronizar estado, gestionar perfiles, implementar matchmaking, guardar partidas en la nube y sistemas de logros, incluyendo juegos en consolas y navegador. Finalmente, dispositivos IoT como Smart TVs, wearables y dispositivos embebidos usan APIs REST para comunicarse con servicios en la nube.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#formato-json",
    "href": "ch/part_servercoms/rest/rest_intro.html#formato-json",
    "title": "10  API REST",
    "section": "10.4 Formato JSON",
    "text": "10.4 Formato JSON\nJSON (JavaScript Object Notation) es el formato estándar para el intercambio de datos en APIs REST. Es un formato de texto ligero, fácil de leer para humanos y fácil de parsear para máquinas. JSON construye estructuras con dos tipos principales: objetos (colección de pares clave-valor en {}) y arrays (lista ordenada en []). Los valores pueden ser cadenas de texto, números, booleanos, null, objetos o arrays.\n{\n  \"game\": {\n    \"id\": \"match_12345\",\n    \"type\": \"pong\",\n    \"status\": \"active\",\n    \"players\": [\n      {\n        \"id\": \"alice\",\n        \"name\": \"Alice Smith\",\n        \"score\": 5,\n        \"ready\": true\n      },\n      {\n        \"id\": \"bob\",\n        \"name\": \"Bob Johnson\",\n        \"score\": 3,\n        \"ready\": true\n      }\n    ],\n    \"settings\": {\n      \"max_score\": 11,\n      \"ball_speed\": 300\n    }\n  }\n}\nEste ejemplo muestra cómo representar el estado completo de una partida de Pong. JSON también se usa en ficheros de configuración, almacenamiento de datos en disco, y bases de datos NoSQL como MongoDB.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#funcionamiento-de-un-servicio-rest",
    "href": "ch/part_servercoms/rest/rest_intro.html#funcionamiento-de-un-servicio-rest",
    "title": "10  API REST",
    "section": "10.5 Funcionamiento de un Servicio REST",
    "text": "10.5 Funcionamiento de un Servicio REST\nEl enfoque más habitual en los servicios REST establece cuatro principios fundamentales. En REST, todo es un recurso identificado por una URI única. La URI está compuesta por una parte fija (dominio y ruta base) y una parte variable que identifica el recurso específico. Por ejemplo: http://api.game.com/players/alice, http://api.game.com/matches/12345, http://api.game.com/players/alice/scores, o http://api.game.com/leaderboard.\nLos principios de diseño de URIs incluyen usar sustantivos, no verbos (/players/alice ✓ vs /getPlayer?id=alice ✗); usar plurales para colecciones (/players para colección, /players/alice para uno específico); crear jerarquías lógicas (/players/alice/matches refleja relación entre recursos); y usar minúsculas y guiones (/game-sessions/active).\nREST aprovecha los métodos HTTP para indicar qué operación realizar sobre un recurso. GET obtiene información, es seguro (no modifica el servidor), idempotente (múltiples peticiones producen el mismo resultado) y cacheable. POST crea nuevos recursos, donde el servidor decide el ID y lo devuelve en la respuesta; no es seguro ni idempotente. PUT actualiza un recurso existente enviando el recurso completo; no es seguro pero sí idempotente. DELETE elimina un recurso; no es seguro pero sí idempotente (eliminar varias veces produce el mismo resultado: el recurso no existe).\nLa información se intercambia en formato JSON. Una petición HTTP REST completa tiene la siguiente anatomía:\nPOST /matches HTTP/1.1\nHost: api.game.com\nContent-Type: application/json\nAccept: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\nContent-Length: 89\n\n{\n  \"type\": \"pong\",\n  \"mode\": \"ranked\",\n  \"max_score\": 11,\n  \"player_id\": \"alice\"\n}\nEsta petición tiene tres partes: la línea de petición (POST /matches HTTP/1.1) indica el método (POST), la ruta (/matches) y la versión HTTP; los headers (cabeceras) son metadatos sobre la petición donde Content-Type: application/json indica que enviamos JSON, Accept: application/json indica que queremos recibir JSON, Authorization: Bearer ... incluye el token de autenticación, y Content-Length: 89 indica el tamaño del cuerpo en bytes; y el body (cuerpo) contiene los datos JSON que enviamos al servidor.\nUna respuesta HTTP REST completa tiene la siguiente estructura:\nHTTP/1.1 201 Created\nContent-Type: application/json\nLocation: http://api.game.com/matches/67890\nContent-Length: 156\n\n{\n  \"id\": \"67890\",\n  \"type\": \"pong\",\n  \"mode\": \"ranked\",\n  \"max_score\": 11,\n  \"status\": \"waiting\",\n  \"created_at\": \"2025-01-15T14:30:00Z\",\n  \"players\": [\"alice\"]\n}\nEsta respuesta tiene tres partes: la línea de estado (HTTP/1.1 201 Created) indica la versión HTTP, el código de estado (201) y el mensaje (Created); los headers (cabeceras) son metadatos sobre la respuesta donde Content-Type: application/json indica que la respuesta es JSON, Location: http://... proporciona la URI del recurso creado, y Content-Length: 156 indica el tamaño de la respuesta; y el body (cuerpo) contiene los datos JSON del recurso creado.\nLos códigos de estado HTTP son números de tres dígitos que comunican el resultado de la operación:\n1xx - Respuestas informativas: Indican que la petición fue recibida y el proceso continúa. Raramente usados en REST. El más relevante es 101 Switching Protocols, usado para cambiar de HTTP a WebSockets.\n2xx - Respuestas exitosas: La petición fue procesada correctamente. Los más comunes son 200 OK (éxito general en GET/PUT), 201 Created (recurso creado tras POST, debe incluir header Location), y 204 No Content (éxito sin contenido, típico en DELETE).\n3xx - Redirecciones: El cliente debe tomar acciones adicionales. Incluyen 301 Moved Permanently (recurso movido permanentemente) y 304 Not Modified (usado con caché, el recurso no ha cambiado).\n4xx - Errores del cliente: Error en la petición. Los más importantes son 400 Bad Request (petición mal formada), 401 Unauthorized (autenticación requerida), 403 Forbidden (sin permisos), 404 Not Found (recurso no existe), 409 Conflict (conflicto con estado actual, ej: usuario ya existe), y 422 Unprocessable Entity (formato correcto pero errores de validación).\n5xx - Errores del servidor: El servidor no pudo completar la petición. Los principales son 500 Internal Server Error (error genérico), 503 Service Unavailable (servidor temporalmente no disponible, debe incluir Retry-After), y 504 Gateway Timeout (timeout esperando respuesta de otro servidor).",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_intro.html#ventajas-de-esta-arquitectura",
    "href": "ch/part_servercoms/rest/rest_intro.html#ventajas-de-esta-arquitectura",
    "title": "10  API REST",
    "section": "10.6 Ventajas de esta Arquitectura",
    "text": "10.6 Ventajas de esta Arquitectura\nLa arquitectura REST ofrece varias ventajas clave. Proporciona separación de responsabilidades, donde la API REST maneja operaciones de gestión mientras que el sistema de comandos se encarga de la lógica del juego, permitiendo que cada componente evolucione independientemente. Ofrece escalabilidad, ya que al separar las operaciones de gestión de las de tiempo real, podemos escalar cada servicio según sus necesidades específicas. Mejora la testabilidad, permitiendo probar la API REST de forma independiente al juego, y el sistema de comandos puede probarse sin necesidad de conexión a red. Finalmente, proporciona flexibilidad, ya que la misma API REST puede servir a múltiples clientes: el juego web, una aplicación móvil, o herramientas de administración.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>API REST</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html",
    "href": "ch/part_servercoms/rest/rest_client.html",
    "title": "11  Cliente API REST con Javascript",
    "section": "",
    "text": "11.1 GET - Obtener datos\nLa función fetch() es la API estándar moderna de JavaScript para realizar peticiones HTTP. Está integrada en todos los navegadores modernos y utiliza promesas (Promises) para manejar operaciones asincrónicas de manera elegante.\nCuando trabajamos con fetch(), tenemos dos formas principales de manejar las respuestas asincrónicas. La primera opción es usar callbacks con .then(), donde encadenamos promesas para procesar la respuesta. Primero verificamos si la petición fue exitosa con response.ok, luego convertimos la respuesta a JSON, y finalmente procesamos los datos. Si algo falla en cualquier punto de la cadena, el .catch() captura el error.\nLa segunda opción, más recomendada por su legibilidad, es usar async/await. Aquí declaramos una función asíncrona y usamos await para esperar las promesas. Esto hace que el código se lea de forma más secuencial y natural, similar a código síncrono, aunque sigue siendo asíncrono. Siempre envolvemos el código en un bloque try/catch para manejar posibles errores.\nPara obtener datos de una API, usamos el método GET, que es el predeterminado de fetch(). En el primer ejemplo obtenemos información de un jugador y accedemos directamente a una propiedad específica del objeto retornado. En el segundo ejemplo creamos una función reutilizable que acepta un ID dinámico mediante template literals, lo que nos permite obtener diferentes jugadores cambiando solo el parámetro.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html#get---obtener-datos",
    "href": "ch/part_servercoms/rest/rest_client.html#get---obtener-datos",
    "title": "11  Cliente API REST con Javascript",
    "section": "",
    "text": "// Con callbacks\nfetch('https://api.game.com/players/alice')\n    .then(response =&gt; response.json())\n    .then(player =&gt; console.log(player.name))\n    .catch(error =&gt; console.error(error));\n\n// Con async/await\nasync function getPlayer(id) {\n    const response = await fetch(`https://api.game.com/players/${id}`);\n    return await response.json();\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html#post---crear-recurso",
    "href": "ch/part_servercoms/rest/rest_client.html#post---crear-recurso",
    "title": "11  Cliente API REST con Javascript",
    "section": "11.2 POST - Crear recurso",
    "text": "11.2 POST - Crear recurso\nCuando necesitamos crear un nuevo recurso, usamos el método POST. Aquí debemos especificar tres elementos clave en el segundo parámetro de fetch(): el método HTTP, las cabeceras indicando que enviamos JSON, y el cuerpo de la petición con los datos convertidos a string JSON mediante JSON.stringify(). El servidor procesará estos datos, creará el nuevo jugador, y típicamente nos devolverá el objeto creado con su nuevo ID asignado.\n// Con callbacks\nfetch('https://api.game.com/players', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ username: 'charlie', email: 'charlie@example.com' })\n})\n    .then(response =&gt; response.json())\n    .then(newPlayer =&gt; console.log('Creado:', newPlayer.id))\n    .catch(error =&gt; console.error(error));\n\n// Con async/await\nasync function createPlayer(data) {\n    const response = await fetch('https://api.game.com/players', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data)\n    });\n    return await response.json();\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html#put---actualizar-recurso",
    "href": "ch/part_servercoms/rest/rest_client.html#put---actualizar-recurso",
    "title": "11  Cliente API REST con Javascript",
    "section": "11.3 PUT - Actualizar recurso",
    "text": "11.3 PUT - Actualizar recurso\nPara actualizar un recurso existente, usamos PUT, que reemplaza completamente el recurso en el servidor. La estructura es similar al POST, pero aquí incluimos el ID del recurso en la URL para indicar cuál queremos actualizar. Enviamos los nuevos datos que queremos aplicar, y el servidor actualiza el recurso y nos devuelve la versión actualizada. Es importante notar que PUT típicamente reemplaza todo el recurso, a diferencia de PATCH que solo actualizaría los campos especificados.\n// Con callbacks\nfetch('https://api.game.com/players/charlie', {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ email: 'newemail@example.com', level: 5 })\n})\n    .then(response =&gt; response.json())\n    .then(updated =&gt; console.log('Actualizado'))\n    .catch(error =&gt; console.error(error));\n\n// Con async/await\nasync function updatePlayer(id, updates) {\n    const response = await fetch(`https://api.game.com/players/${id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updates)\n    });\n    return await response.json();\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html#delete---eliminar-recurso",
    "href": "ch/part_servercoms/rest/rest_client.html#delete---eliminar-recurso",
    "title": "11  Cliente API REST con Javascript",
    "section": "11.4 DELETE - Eliminar recurso",
    "text": "11.4 DELETE - Eliminar recurso\nEl método DELETE es el más simple de todos, ya que solo necesitamos especificar el método y la URL con el ID del recurso a eliminar. No necesitamos enviar un cuerpo ni cabeceras especiales. El servidor eliminará el recurso y típicamente responde con un código 204 (sin contenido) o 200 (éxito). Verificamos que la operación fue exitosa usando response.ok, que será true para códigos de estado 2xx.\n// Con callbacks\nfetch('https://api.game.com/players/charlie', {\n    method: 'DELETE'\n})\n    .then(response =&gt; {\n        if (response.ok) console.log('Eliminado');\n    })\n    .catch(error =&gt; console.error(error));\n\n// Con async/await\nasync function deletePlayer(id) {\n    const response = await fetch(`https://api.game.com/players/${id}`, {\n        method: 'DELETE'\n    });\n    return response.ok;\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_client.html#manejo-de-errores-y-códigos-de-estado",
    "href": "ch/part_servercoms/rest/rest_client.html#manejo-de-errores-y-códigos-de-estado",
    "title": "11  Cliente API REST con Javascript",
    "section": "11.5 Manejo de errores y códigos de estado",
    "text": "11.5 Manejo de errores y códigos de estado\nEn aplicaciones reales, necesitamos manejar diferentes situaciones que pueden ocurrir durante las peticiones HTTP. Este ejemplo muestra cómo implementar un manejo robusto de errores usando un switch sobre el código de estado. Cada código HTTP tiene un significado específico: 200 indica éxito y devolvemos los datos, 401 significa que el usuario necesita autenticarse, 403 indica que aunque esté autenticado no tiene permisos para ese recurso, 404 significa que el recurso no existe, y 500 indica un error interno del servidor. Capturando estos casos específicos, podemos proporcionar mensajes de error claros y tomar acciones apropiadas para cada situación, mejorando significativamente la experiencia del usuario.\nasync function fetchWithErrorHandling(url) {\n    try {\n        const response = await fetch(url);\n        \n        switch (response.status) {\n            case 200:\n                return await response.json();\n            case 401:\n                throw new Error('No autenticado');\n            case 403:\n                throw new Error('Sin permisos');\n            case 404:\n                throw new Error('Recurso no encontrado');\n            case 500:\n                throw new Error('Error del servidor');\n            default:\n                throw new Error(`Error: ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error en petición:', error);\n        throw error;\n    }\n}",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Cliente API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html",
    "href": "ch/part_servercoms/rest/rest_server.html",
    "title": "12  Servidor API REST con Javascript",
    "section": "",
    "text": "12.1 Controladores\nExpress.js es un framework web minimalista y flexible para Node.js que se ha convertido en el estándar para crear APIs REST. Proporciona un sistema de enrutamiento robusto, soporte para middlewares que procesan peticiones, manejo de errores integrado y compatibilidad completa con todos los métodos HTTP y códigos de estado. Su popularidad se debe a su simplicidad y a que permite construir servidores HTTP de manera rápida y eficiente.\nPara comenzar a trabajar con Express, primero necesitamos inicializar un proyecto Node.js y luego instalar el framework. El comando npm init -y crea automáticamente un archivo package.json con la configuración por defecto, y posteriormente instalamos Express como dependencia del proyecto:\nPara usar la sintaxis de módulos ES6 (import/export) en lugar de CommonJS (require/module.exports), debemos añadir \"type\": \"module\" en el package.json:\nCon esta configuración, podremos usar import y export en nuestro código.\nUn proyecto Express típico organiza el código en varias carpetas. La carpeta node_modules contiene todas las dependencias instaladas y no debe subirse al repositorio. El código fuente se ubica en src, donde creamos subcarpetas para los controladores y las rutas. El archivo package.json define las dependencias y scripts del proyecto, mientras que package-lock.json asegura que las versiones de las dependencias sean consistentes.\nPara crear un servidor básico con Express, importamos el módulo y creamos una instancia de la aplicación. El middleware express.json() es fundamental porque permite que Express pueda leer y parsear automáticamente el cuerpo de las peticiones que vienen en formato JSON. Sin este middleware, no podríamos acceder a los datos que el cliente envía en las peticiones POST o PUT. Finalmente, el método listen() inicia el servidor en el puerto especificado:\nPara ejecutar el servidor simplemente usamos node src/app.js desde la terminal.\nLos controladores son las funciones que contienen la lógica de negocio de cada endpoint. Son las responsables de procesar las peticiones HTTP, manipular los datos recibidos, realizar operaciones sobre ellos y devolver las respuestas apropiadas al cliente. Mantener esta lógica separada en controladores hace que el código sea más organizado, reutilizable y fácil de mantener.\nUna forma elegante de mantener estado privado en los controladores es mediante closures. Creamos una función factory que inicializa el estado y devuelve las funciones del controlador. Estas funciones tienen acceso al estado compartido pero éste no es accesible desde fuera:\nEste patrón permite que múltiples funciones del controlador compartan el mismo estado (anuncios y nextId) sin exponerlo globalmente. El estado está encapsulado dentro del closure y solo las funciones retornadas pueden acceder a él.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html#controladores",
    "href": "ch/part_servercoms/rest/rest_server.html#controladores",
    "title": "12  Servidor API REST con Javascript",
    "section": "",
    "text": "// src/controllers/anunciosController.js\nconst createAnunciosController = () =&gt; {\n  // Estado privado compartido\n  const anuncios = [];\n  let nextId = 1;\n  \n  const getAll = (req, res) =&gt; {\n    res.json(anuncios);\n  };\n  \n  const create = (req, res) =&gt; {\n    const { nombre, asunto, comentario } = req.body;\n    \n    const nuevoAnuncio = {\n      id: nextId++,\n      nombre,\n      asunto,\n      comentario\n    };\n    \n    anuncios.push(nuevoAnuncio);\n    res.status(201).json(nuevoAnuncio);\n  };\n  \n  return { getAll, create };\n};\n\nexport default createAnunciosController;",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html#rutas",
    "href": "ch/part_servercoms/rest/rest_server.html#rutas",
    "title": "12  Servidor API REST con Javascript",
    "section": "12.2 Rutas",
    "text": "12.2 Rutas\nLas rutas son la capa que conecta las URLs de nuestra API con los controladores correspondientes. Definen qué controlador se ejecutará cuando llegue una petición a una URL específica con un método HTTP determinado. Express proporciona un objeto Router que permite agrupar rutas relacionadas y aplicarles prefijos comunes.\nPara definir rutas, creamos un archivo que importa el Router de Express. Como nuestro controlador es una función factory, la invocamos para obtener las funciones del controlador y luego las asociamos con las rutas:\n// src/routes/anunciosRoutes.js\nimport express from 'express';\nimport createAnunciosController from '../controllers/anunciosController.js';\n\nconst router = express.Router();\nconst controller = createAnunciosController();\n\nrouter.get('/', controller.getAll);\nrouter.post('/', controller.create);\n\nexport default router;\nPara integrar estas rutas en nuestra aplicación, las importamos y las registramos con un prefijo usando app.use(). Esto significa que todas las rutas definidas en el router tendrán ese prefijo automáticamente:\n// src/app.js\nimport express from 'express';\nimport anunciosRoutes from './routes/anunciosRoutes.js';\n\nconst app = express();\napp.use(express.json());\n\napp.use('/anuncios', anunciosRoutes);\n\napp.listen(8080);\nCon esta configuración, la ruta router.get('/') se convierte en GET /anuncios y la ruta router.post('/') se convierte en POST /anuncios.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html#operaciones-crud",
    "href": "ch/part_servercoms/rest/rest_server.html#operaciones-crud",
    "title": "12  Servidor API REST con Javascript",
    "section": "12.3 Operaciones CRUD",
    "text": "12.3 Operaciones CRUD\nLa operación GET se utiliza para recuperar información del servidor sin modificarla. Express proporciona el objeto req.params para acceder a los parámetros de la URL. Por ejemplo, en la ruta /anuncios/:id, el :id es un parámetro dinámico cuyo valor estará disponible en req.params.id. El método res.json() convierte automáticamente un objeto JavaScript a formato JSON y lo envía como respuesta con las cabeceras correctas:\napp.get('/anuncios/:id', (req, res) =&gt; {\n  const { id } = req.params;\n  const anuncio = anuncios.find(a =&gt; a.id === parseInt(id));\n  \n  if (!anuncio) {\n    return res.status(404).json({ error: 'No encontrado' });\n  }\n  \n  res.json(anuncio);\n});\nLa operación POST crea nuevos recursos en el servidor. Los datos que el cliente envía vienen en el cuerpo de la petición y están disponibles en req.body gracias al middleware express.json(). Es importante validar siempre los datos recibidos antes de procesarlos para evitar errores o datos incorrectos. Cuando se crea un recurso exitosamente, el código de estado apropiado es 201 (Created):\napp.post('/anuncios', (req, res) =&gt; {\n  const { nombre, asunto, comentario } = req.body;\n  \n  if (!nombre || !asunto) {\n    return res.status(400).json({ \n      error: 'Nombre y asunto son requeridos' \n    });\n  }\n  \n  const nuevoAnuncio = {\n    id: Date.now(),\n    nombre,\n    asunto,\n    comentario\n  };\n  \n  anuncios.push(nuevoAnuncio);\n  res.status(201).json(nuevoAnuncio);\n});\nLa operación PUT actualiza un recurso existente reemplazándolo completamente con los nuevos datos. Para actualizar necesitamos tanto el identificador del recurso (que viene en la URL) como los nuevos datos (que vienen en el body). Si el recurso no existe, devolvemos un error 404:\napp.put('/anuncios/:id', (req, res) =&gt; {\n  const { id } = req.params;\n  const { nombre, asunto, comentario } = req.body;\n  \n  const anuncio = anuncios.find(a =&gt; a.id === parseInt(id));\n  \n  if (!anuncio) {\n    return res.status(404).json({ error: 'No encontrado' });\n  }\n  \n  anuncio.nombre = nombre;\n  anuncio.asunto = asunto;\n  anuncio.comentario = comentario;\n  \n  res.json(anuncio);\n});\nLa operación DELETE elimina un recurso del servidor. Podemos opcionalmente devolver el recurso eliminado en la respuesta, o simplemente devolver un código 204 (No Content) que indica éxito sin contenido. El método findIndex() nos permite localizar la posición del elemento en el array para poder eliminarlo con splice():\napp.delete('/anuncios/:id', (req, res) =&gt; {\n  const { id } = req.params;\n  const index = anuncios.findIndex(a =&gt; a.id === parseInt(id));\n  \n  if (index === -1) {\n    return res.status(404).json({ error: 'No encontrado' });\n  }\n  \n  const anuncioEliminado = anuncios.splice(index, 1)[0];\n  res.json(anuncioEliminado);\n});",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html#middlewares-en-express",
    "href": "ch/part_servercoms/rest/rest_server.html#middlewares-en-express",
    "title": "12  Servidor API REST con Javascript",
    "section": "12.4 Middlewares en Express",
    "text": "12.4 Middlewares en Express\nLos middlewares son funciones que se ejecutan durante el ciclo de vida de una petición, antes de que llegue al controlador final. Tienen acceso a los objetos de petición req y respuesta res, y a la función next() que permite pasar el control al siguiente middleware o ruta. Los middlewares son útiles para tareas transversales como logging, autenticación, validación o manejo de errores.\nUn middleware de logging básico registra cada petición que llega al servidor. Es importante llamar a next() al final para que la petición continúe su flujo normal hacia el controlador apropiado:\napp.use((req, res, next) =&gt; {\n  console.log(`${req.method} ${req.path}`);\n  next();\n});\nLos middlewares de manejo de errores son especiales porque tienen cuatro parámetros en lugar de tres. Express los identifica automáticamente por esta firma y los invoca cuando ocurre un error. Deben colocarse después de todas las rutas para capturar cualquier error que no haya sido manejado:\napp.use((err, req, res, next) =&gt; {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Error interno del servidor' });\n});",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/rest/rest_server.html#servir-archivos-estáticos",
    "href": "ch/part_servercoms/rest/rest_server.html#servir-archivos-estáticos",
    "title": "12  Servidor API REST con Javascript",
    "section": "12.5 Servir archivos estáticos",
    "text": "12.5 Servir archivos estáticos\nAdemás de servir una API REST, Express puede servir archivos estáticos como HTML, CSS, JavaScript del cliente e imágenes. El middleware express.static() configura un directorio desde el cual se servirán estos archivos automáticamente. Cuando el cliente solicita un archivo, Express lo busca en ese directorio y lo envía si existe:\napp.use(express.static('public'));\nCon esta configuración, si creamos la siguiente estructura de carpetas, los archivos serán accesibles directamente desde la raíz del servidor:\nmi-api-juego/\n├── public/\n│   ├── index.html\n│   ├── script.js\n│   └── style.css\n└── src/\n    └── app.js\nEl archivo public/index.html estará disponible en http://localhost:8080/index.html y public/script.js en http://localhost:8080/script.js",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Servidor API REST con Javascript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/part_intro_ws.html",
    "href": "ch/part_servercoms/part_intro_ws.html",
    "title": "Comunicación asíncrona cliente - servidor",
    "section": "",
    "text": "Mientras que las APIs REST son excelentes para operaciones síncronas y peticiones puntuales, los juegos multijugador en tiempo real requieren una comunicación bidireccional constante y de baja latencia. Aquí es donde entran en juego los WebSockets, una tecnología que permite establecer conexiones persistentes entre el cliente y el servidor para intercambiar mensajes en tiempo real. En esta parte final del curso dominaremos WebSockets y Socket.IO para implementar comunicación bidireccional, gestionar conexiones de múltiples jugadores, trabajar con salas y broadcast, y sincronizar el estado del juego entre todos los clientes conectados. Aprenderemos las diferencias fundamentales entre HTTP y WebSockets, cuándo utilizar cada tecnología, y cómo implementar sistemas de comunicación en tiempo real que permitan crear experiencias multijugador fluidas y responsivas, culminando así con un dominio completo del stack tecnológico para juegos en red.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "Comunicación asíncrona cliente - servidor"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_intro.html",
    "href": "ch/part_servercoms/ws/ws_intro.html",
    "title": "13  Introducción a WebSockets",
    "section": "",
    "text": "13.1 Introducción a los Sockets\nAntes de adentrarnos en WebSockets, es fundamental comprender el concepto básico de sockets en las comunicaciones de red. En el contexto de las comunicaciones fiables, cuando conocemos la dirección IP y el puerto de dos aplicaciones que se ejecutan en máquinas distintas, los sockets permiten establecer una comunicación bidireccional entre ellas.\nUn socket se identifica mediante una dirección IP y un puerto. Podemos pensar en él como uno de los extremos de un canal de comunicación bidireccional entre dos programas. Cuando establecemos una conexión, tanto el cliente como el servidor tienen un socket asociado a través del cual pueden enviar y recibir información simultáneamente.\nImaginemos un escenario típico donde un servidor tiene la IP 212.128.240.50 y está escuchando en el puerto 10000, mientras que un cliente con IP 1XX.XXX.XXX.XX usa un puerto dinámico (por ejemplo, YYYY). El proceso de comunicación funciona así: primero, el servidor se encuentra escuchando en su puerto específico; luego, el cliente inicia una petición de conexión hacia el servidor; una vez aceptada, se establece una conexión bidireccional donde ambas partes pueden enviar y recibir datos simultáneamente.\nEsta comunicación bidireccional es clave: no se trata solo de que el cliente solicite y el servidor responda, sino que ambos pueden iniciar el envío de información en cualquier momento una vez establecida la conexión. Un socket es cada uno de los extremos de esta comunicación bidireccional entre dos programas.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introducción a WebSockets</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_intro.html#qué-son-los-websockets",
    "href": "ch/part_servercoms/ws/ws_intro.html#qué-son-los-websockets",
    "title": "13  Introducción a WebSockets",
    "section": "13.2 ¿Qué son los WebSockets?",
    "text": "13.2 ¿Qué son los WebSockets?\nWebSockets es un protocolo de comunicaciones que permite abrir una sesión interactiva entre un cliente (normalmente un navegador web) y un servidor. La principal innovación de WebSockets es que permite establecer un canal full-duplex, lo que significa que tanto el cliente como el servidor pueden enviar mensajes de forma independiente sin necesidad de abrir una nueva conexión cada vez que se quiere comunicar. La comunicación es bidireccional y simultánea.\nEl funcionamiento de WebSockets sigue estos pasos: inicialmente, el cliente solicita la conexión al servidor; la conexión es aceptada por el servidor; se genera una conexión permanente que permanece abierta; y deberá haber procesos en ambos lados que escuchen para recibir mensajes. Esta persistencia de la conexión es fundamental para aplicaciones en tiempo real como juegos multijugador, donde necesitamos que el servidor pueda enviar actualizaciones al cliente sin que este tenga que estar constantemente preguntando “¿hay algo nuevo?”.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introducción a WebSockets</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_intro.html#websockets-como-estándar",
    "href": "ch/part_servercoms/ws/ws_intro.html#websockets-como-estándar",
    "title": "13  Introducción a WebSockets",
    "section": "13.3 WebSockets como Estándar",
    "text": "13.3 WebSockets como Estándar\nWebSockets está definido como un estándar de comunicación en el RFC 6455 que funciona sobre un único socket TCP. Una de las grandes ventajas de WebSockets es que utiliza el puerto 80 (el mismo que HTTP) de forma multiplexada, lo que significa que puede soportar varias comunicaciones por el mismo puerto, evita problemas con firewalls y proxies que bloquean puertos no estándar, y está pensado principalmente para navegadores y servidores web.\nAunque WebSockets comienza con HTTP, no está limitado a este protocolo. Un cliente puede abrir un socket con el servidor y comunicarse con él a través de HTTP (el protocolo web tradicional) o un protocolo propio diseñado específicamente para la aplicación. Esta flexibilidad es especialmente útil en juegos en red, donde podemos diseñar un protocolo de comunicación optimizado para nuestras necesidades específicas.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introducción a WebSockets</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_intro.html#negociación-de-conexión-websocket",
    "href": "ch/part_servercoms/ws/ws_intro.html#negociación-de-conexión-websocket",
    "title": "13  Introducción a WebSockets",
    "section": "13.4 Negociación de Conexión WebSocket",
    "text": "13.4 Negociación de Conexión WebSocket\nAunque los desarrolladores raramente necesitan implementar manualmente este proceso, entender cómo se negocia una conexión WebSocket nos ayuda a comprender mejor su funcionamiento. La negociación para obtener un WebSocket se inicia sobre HTTP. El cliente envía una petición especial:\nGET /demo HTTP/1.1\nHost: example.com\nConnection: Upgrade\nUpgrade: WebSocket\nOrigin: http://example.com\nEsta petición comienza como una petición HTTP normal (GET /demo HTTP/1.1), pero el header Connection: Upgrade indica que queremos cambiar de protocolo, el header Upgrade: WebSocket especifica que queremos usar WebSocket, y el header Origin indica desde dónde se origina la petición (importante para seguridad). En esencia, le estamos diciendo al servidor: “Hola, quiero establecer una conexión WebSocket contigo en la ruta /demo”.\nSi el servidor acepta la conexión WebSocket, responde con:\nHTTP/1.1 101 WebSocket Protocol Handshake\nUpgrade: WebSocket\nConnection: Upgrade\nSec-WebSocket-Origin: http://example.com\nSec-WebSocket-Location: ws://example.com/demo\nEl código 101 indica que se acepta el cambio de protocolo, Upgrade: WebSocket confirma que vamos a usar WebSocket, Connection: Upgrade confirma el cambio de protocolo, Sec-WebSocket-Origin confirma el origen de la conexión, y Sec-WebSocket-Location indica la ubicación del WebSocket con el nuevo protocolo.\nFíjate en la última línea: ws://example.com/demo. WebSocket introduce dos nuevos esquemas de protocolo: ws:// para WebSocket en claro (equivalente a http://) y wss:// para WebSocket seguro sobre TLS (equivalente a https://). Una vez completado este “handshake” (apretón de manos), la conexión HTTP se transforma en una conexión WebSocket persistente, y ambas partes pueden comenzar a intercambiar mensajes libremente.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introducción a WebSockets</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_intro.html#uso-normal-de-websockets",
    "href": "ch/part_servercoms/ws/ws_intro.html#uso-normal-de-websockets",
    "title": "13  Introducción a WebSockets",
    "section": "13.5 Uso Normal de WebSockets",
    "text": "13.5 Uso Normal de WebSockets\nEn la práctica, normalmente no tenemos que preocuparnos por la negociación HTTP que acabamos de ver. Las conexiones se realizan automáticamente utilizando los protocolos ws:// para WebSocket normal y wss:// para WebSocket seguro. Cuando creamos una conexión WebSocket desde JavaScript (como veremos en el siguiente tema), simplemente usamos:\nnew WebSocket('ws://example.com/demo');\nY todo el proceso de negociación que hemos explicado ocurre automáticamente entre bastidores. El navegador y el servidor se encargan de todo el intercambio HTTP inicial y del cambio al protocolo WebSocket.\nPara concluir este tema, es importante destacar por qué WebSockets es especialmente útil en el contexto de juegos en red: proporciona comunicación en tiempo real donde los jugadores reciben actualizaciones instantáneas sin demoras; es bidireccional, permitiendo que el servidor envíe eventos a los clientes sin que estos pregunten constantemente; es eficiente, ya que una sola conexión persistente consume menos recursos que múltiples peticiones HTTP; ofrece baja latencia, ideal para juegos que requieren respuestas rápidas; y es un estándar compatible que funciona en todos los navegadores modernos sin necesidad de plugins.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Introducción a WebSockets</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_client.html",
    "href": "ch/part_servercoms/ws/ws_client.html",
    "title": "14  Cliente WebSockets con JavasScript",
    "section": "",
    "text": "14.1 La API WebSocket en JavaScript\nJavaScript proporciona una API nativa para crear y administrar conexiones WebSocket desde el navegador. Esta API nos permite establecer conexiones con servidores WebSocket de forma sencilla y manejar toda la comunicación bidireccional. La gran ventaja de esta API es que está integrada directamente en el navegador, por lo que no necesitamos instalar librerías adicionales para usar WebSockets en nuestras aplicaciones web.\nLa API está implementada en el objeto WebSocket. Para crear una conexión, simplemente instanciamos este objeto pasándole como parámetro la URL del servidor al que queremos conectarnos:\nDonde ws:// es el protocolo WebSocket (o wss:// para conexiones seguras), IP es la dirección IP o dominio del servidor, PUERTO es el puerto donde escucha el servidor WebSocket, y RUTA es el path específico del endpoint WebSocket en el servidor.\nImagina que tenemos un servidor WebSocket ejecutándose localmente en el puerto 8080, con un endpoint llamado /echo:\nCon esta única línea hemos creado la conexión. El navegador automáticamente inicia el handshake HTTP que vimos en el tema anterior, negocia el cambio al protocolo WebSocket, y establece la conexión persistente. Ahora tenemos un objeto connection que representa nuestro extremo de la comunicación bidireccional.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Cliente WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_client.html#la-api-websocket-en-javascript",
    "href": "ch/part_servercoms/ws/ws_client.html#la-api-websocket-en-javascript",
    "title": "14  Cliente WebSockets con JavasScript",
    "section": "",
    "text": "WebSocket('ws://IP:PUERTO/RUTA');\n\n\nvar connection = new WebSocket('ws://127.0.0.1:8080/echo');",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Cliente WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_client.html#métodos-del-objeto-websocket",
    "href": "ch/part_servercoms/ws/ws_client.html#métodos-del-objeto-websocket",
    "title": "14  Cliente WebSockets con JavasScript",
    "section": "14.2 Métodos del Objeto WebSocket",
    "text": "14.2 Métodos del Objeto WebSocket\nEl objeto WebSocket tiene dos métodos principales que utilizaremos para interactuar con el servidor. El método send() transmite datos al servidor a través de la conexión WebSocket:\nconnection.send('Hi');\nEste método es muy simple: le pasamos los datos que queremos enviar y el objeto WebSocket se encarga de transmitirlos al servidor. Podemos enviar texto simple como 'Hola servidor', o datos más complejos (típicamente JSON convertido a string):\nvar data = {\n  action: 'move',\n  x: 100,\n  y: 250\n};\nconnection.send(JSON.stringify(data));\nEn juegos en red, es común enviar objetos JSON que describen las acciones del jugador. Por ejemplo, si el jugador se mueve, podríamos enviar:\nconnection.send(JSON.stringify({\n  type: 'player_move',\n  x: 150,\n  y: 200\n}));\nEl método close() cierra la conexión WebSocket de forma ordenada:\nconnection.close();\nCuando llamamos a este método, se inicia el proceso de cierre de la conexión, se envía una señal al servidor indicando que vamos a cerrar, y se libera la conexión. Esto es útil cuando el jugador sale del juego o cuando queremos limpiar recursos.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Cliente WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_client.html#event-listeners---la-clave-de-websockets",
    "href": "ch/part_servercoms/ws/ws_client.html#event-listeners---la-clave-de-websockets",
    "title": "14  Cliente WebSockets con JavasScript",
    "section": "14.3 Event Listeners - La Clave de WebSockets",
    "text": "14.3 Event Listeners - La Clave de WebSockets\nAquí viene la parte más importante: los event listeners. Un objeto WebSocket tiene diferentes atributos que actúan como listeners, es decir, funciones que se ejecutan automáticamente cuando ocurren ciertos eventos. Estos listeners son la forma en que nuestro código “escucha” lo que está pasando con la conexión WebSocket.\nEl listener onopen es llamado cuando la conexión del WebSocket cambia a un estado abierto (OPEN):\nconnection.onopen = function () {\n  connection.send('Hi');\n}\nEste evento se dispara justo después de que la conexión se establece exitosamente. Es el momento perfecto para enviar un mensaje inicial al servidor, notificar al usuario que está conectado, o inicializar el estado del juego. En el ejemplo anterior, tan pronto como se abre la conexión, enviamos el mensaje ‘Hi’ al servidor. Podríamos hacer algo más elaborado:\nconnection.onopen = function() {\n  console.log('¡Conectado al servidor!');\n\n  // Enviar información inicial del jugador\n  connection.send(JSON.stringify({\n    type: 'player_join',\n    username: 'Jugador1'\n  }));\n};\nEl listener onerror es llamado cuando se produce un error en la conexión:\nconnection.onerror = function(e) {\n  console.log(\"WS error: \" + e);\n}\nEste evento se dispara cuando algo sale mal: no se puede establecer la conexión con el servidor, hay un problema de red, o el servidor rechaza la conexión. Es importante manejar estos errores para informar al usuario de que algo no funciona correctamente:\nconnection.onerror = function(error) {\n  console.log(\"WS error: \" + error);\n  alert('No se pudo conectar al servidor. Por favor, verifica tu conexión.');\n};\nEl listener onmessage es llamado cuando se recibe un mensaje del servidor. Este es probablemente el listener más importante, ya que aquí es donde procesamos toda la información que nos envía el servidor:\nconnection.onmessage = function(msg) {\n  console.log(\"WS message: \" + msg.data);\n}\nEl parámetro msg es un objeto evento que contiene la información del mensaje. El dato real que envió el servidor está en msg.data. Veamos un ejemplo más completo:\nconnection.onmessage = function(msg) {\n  console.log(\"Mensaje recibido: \" + msg.data);\n\n  // Si el servidor envía JSON, lo parseamos\n  var data = JSON.parse(msg.data);\n\n  // Procesamos según el tipo de mensaje\n  if (data.type === 'player_position') {\n    actualizarPosicionJugador(data.playerId, data.x, data.y);\n  } else if (data.type === 'game_over') {\n    mostrarPantallaFinJuego(data.winner);\n  }\n};\nEn un juego multijugador, este listener recibiría constantemente actualizaciones del servidor sobre posiciones de otros jugadores, estado del juego, y eventos importantes (un jugador ganó, apareció un enemigo, etc.).\nEl listener onclose es llamado cuando la conexión del WebSocket cambia a un estado cerrado (CLOSED):\nconnection.onclose = function(event) {\n  console.log('Conexión cerrada');\n};\nEste evento se dispara cuando llamamos a connection.close() nosotros mismos, el servidor cierra la conexión, o se pierde la conexión de red. Es un buen lugar para limpiar recursos o intentar reconectar:\nconnection.onclose = function(event) {\n  console.log('Desconectado del servidor');\n  console.log('Código de cierre:', event.code);\n\n  // Notificar al usuario\n  alert('Se ha perdido la conexión con el servidor');\n\n  // Intentar reconectar después de 3 segundos\n  setTimeout(function() {\n    connection = new WebSocket('ws://127.0.0.1:8080/echo');\n    configurarListeners(connection);\n  }, 3000);\n};",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Cliente WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_server.html",
    "href": "ch/part_servercoms/ws/ws_server.html",
    "title": "15  Servidor WebSockets con JavasScript",
    "section": "",
    "text": "15.1 Servidor WebSocket con Node.js\nPara implementar un servidor WebSocket en Node.js, utilizaremos la librería ws, que es una implementación robusta y eficiente del protocolo WebSocket. Esta librería nos permite crear servidores WebSocket que pueden manejar múltiples conexiones simultáneas de clientes.\nPrimero necesitamos inicializar un proyecto Node.js e instalar las dependencias necesarias:\nInstalamos tanto ws para el servidor WebSocket como express para servir archivos estáticos (la interfaz del cliente). Para usar la sintaxis moderna de módulos ES6, debemos configurar el package.json:\nLa propiedad \"type\": \"module\" nos permite usar import y export en lugar de require y module.exports.\nUn servidor WebSocket completo que también sirve archivos estáticos tiene la siguiente estructura:\nEn este código estamos creando un servidor HTTP con createServer(app) que servirá tanto las peticiones HTTP normales (archivos estáticos) como las conexiones WebSocket; configurando Express para servir archivos estáticos desde la carpeta public, donde estará nuestra interfaz HTML/CSS/JS del cliente; y creando el servidor WebSocket asociándolo al mismo servidor HTTP, lo que permite que ambos protocolos compartan el mismo puerto.\nEl servidor WebSocket funciona mediante eventos. El evento más importante es connection, que se dispara cada vez que un cliente establece una conexión:\nEl parámetro ws representa la conexión individual con ese cliente. Cada cliente que se conecta tiene su propio objeto ws, lo que nos permite comunicarnos de forma independiente con cada uno.\nPara recibir mensajes que envían los clientes, configuramos un listener para el evento message en cada conexión:\nLos mensajes llegan como objetos Buffer, por lo que usamos .toString() para convertirlos a strings. Si esperamos recibir JSON, podemos parsearlo:\nPara enviar un mensaje a un cliente específico, usamos el método send() del objeto de conexión:\nSi queremos enviar objetos JavaScript (como JSON), debemos convertirlos a string primero:\nEs fundamental limpiar recursos cuando un cliente se desconecta. Para esto escuchamos el evento close:\nTambién podemos manejar errores de conexión con el evento error:",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Servidor WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_server.html#servidor-websocket-con-node.js",
    "href": "ch/part_servercoms/ws/ws_server.html#servidor-websocket-con-node.js",
    "title": "15  Servidor WebSockets con JavasScript",
    "section": "",
    "text": "npm init -y\nnpm install ws express\n\n{\n  \"name\": \"websocket-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"ws\": \"^8.0.0\",\n    \"express\": \"^4.18.0\"\n  }\n}\n\n\nimport express from 'express';\nimport { WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\nconst app = express();\nconst server = createServer(app);\n\n// Configurar Express para servir archivos estáticos\napp.use(express.static('public'));\n\n// Crear el servidor WebSocket\nconst wss = new WebSocketServer({ server });\n\n// Iniciar el servidor HTTP\nconst PORT = 8080;\nserver.listen(PORT, () =&gt; {\n  console.log(`Servidor ejecutándose en http://localhost:${PORT}`);\n});\n\n\nwss.on('connection', (ws) =&gt; {\n  console.log('Nuevo cliente conectado');\n\n  // Aquí manejamos los eventos de este cliente específico\n});\n\n\nwss.on('connection', (ws) =&gt; {\n  console.log('Nuevo cliente conectado');\n\n  ws.on('message', (message) =&gt; {\n    console.log('Mensaje recibido:', message.toString());\n\n    // Procesar el mensaje aquí\n    const data = message.toString();\n  });\n});\n\nws.on('message', (message) =&gt; {\n  const data = JSON.parse(message.toString());\n  console.log('Nombre:', data.nombre);\n  console.log('Mensaje:', data.mensaje);\n});\n\nws.on('message', (message) =&gt; {\n  const received = message.toString();\n\n  // Enviar respuesta de vuelta al mismo cliente\n  ws.send(`Echo: ${received}`);\n});\n\nws.on('message', (message) =&gt; {\n  const respuesta = {\n    tipo: 'confirmacion',\n    timestamp: new Date().toISOString(),\n    mensaje: 'Mensaje recibido correctamente'\n  };\n\n  ws.send(JSON.stringify(respuesta));\n});\n\nwss.on('connection', (ws) =&gt; {\n  console.log('Nuevo cliente conectado');\n\n  ws.on('close', () =&gt; {\n    console.log('Cliente desconectado');\n    // Aquí podríamos limpiar cualquier dato asociado a este cliente\n  });\n\n  ws.on('message', (message) =&gt; {\n    // ... manejar mensajes\n  });\n});\n\nws.on('error', (error) =&gt; {\n  console.error('Error en la conexión:', error);\n});",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Servidor WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_server.html#ejemplo-completo-servidor-echo",
    "href": "ch/part_servercoms/ws/ws_server.html#ejemplo-completo-servidor-echo",
    "title": "15  Servidor WebSockets con JavasScript",
    "section": "15.2 Ejemplo completo: Servidor Echo",
    "text": "15.2 Ejemplo completo: Servidor Echo\nUn servidor echo completo que devuelve cualquier mensaje que recibe se vería así:\nimport express from 'express';\nimport { WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(express.static('public'));\n\nconst wss = new WebSocketServer({ server });\n\nwss.on('connection', (ws) =&gt; {\n  console.log('Nuevo cliente conectado');\n  \n  ws.on('message', (message) =&gt; {\n    const data = message.toString();\n    console.log('Mensaje recibido:', data);\n    \n    // Enviar el mensaje de vuelta al cliente\n    ws.send(`Echo: ${data}`);\n  });\n  \n  ws.on('close', () =&gt; {\n    console.log('Cliente desconectado');\n  });\n  \n  ws.on('error', (error) =&gt; {\n    console.error('Error:', error);\n  });\n});\n\nconst PORT = 8080;\nserver.listen(PORT, () =&gt; {\n  console.log(`Servidor ejecutándose en http://localhost:${PORT}`);\n});",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Servidor WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_server.html#ejemplo-completo-servidor-de-chat-con-json",
    "href": "ch/part_servercoms/ws/ws_server.html#ejemplo-completo-servidor-de-chat-con-json",
    "title": "15  Servidor WebSockets con JavasScript",
    "section": "15.3 Ejemplo completo: Servidor de Chat con JSON",
    "text": "15.3 Ejemplo completo: Servidor de Chat con JSON\nUn servidor de chat más sofisticado que maneja mensajes en formato JSON:\nimport express from 'express';\nimport { WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(express.static('public'));\n\nconst wss = new WebSocketServer({ server });\n\nwss.on('connection', (ws) =&gt; {\n  console.log('Nuevo cliente conectado al chat');\n  \n  ws.on('message', (message) =&gt; {\n    try {\n      // Parsear el mensaje JSON del cliente\n      const datos = JSON.parse(message.toString());\n      console.log(`${datos.nombre}: ${datos.mensaje}`);\n      \n      // Crear respuesta en formato JSON\n      const respuesta = {\n        nombre: datos.nombre,\n        mensaje: datos.mensaje,\n        timestamp: new Date().toISOString()\n      };\n      \n      // Broadcast: enviar a todos los clientes\n      wss.clients.forEach((client) =&gt; {\n        if (client.readyState === ws.OPEN) {\n          client.send(JSON.stringify(respuesta));\n        }\n      });\n      \n    } catch (error) {\n      console.error('Error al parsear mensaje:', error);\n      ws.send(JSON.stringify({ \n        error: 'Formato de mensaje inválido' \n      }));\n    }\n  });\n  \n  ws.on('close', () =&gt; {\n    console.log('Cliente desconectado del chat');\n  });\n  \n  ws.on('error', (error) =&gt; {\n    console.error('Error en la conexión:', error);\n  });\n});\n\nconst PORT = 8080;\nserver.listen(PORT, () =&gt; {\n  console.log(`Servidor de chat ejecutándose en http://localhost:${PORT}`);\n});\nEn este ejemplo de chat, recibimos mensajes JSON que contienen el nombre del usuario y su mensaje; validamos el formato usando un bloque try-catch para manejar errores de parsing; enriquecemos el mensaje añadiendo un timestamp del servidor; y hacemos broadcast enviando el mensaje a todos los clientes conectados en formato JSON.\nA menudo necesitamos mantener información sobre los clientes conectados. Podemos usar estructuras de datos como Map para asociar datos adicionales a cada conexión:\nconst clientes = new Map();\n\nwss.on('connection', (ws) =&gt; {\n  // Asignar un ID único al cliente\n  const clientId = Date.now();\n  clientes.set(ws, { id: clientId, nombre: null });\n\n  console.log(`Cliente ${clientId} conectado`);\n\n  ws.on('message', (message) =&gt; {\n    const datos = JSON.parse(message.toString());\n\n    // Guardar el nombre del cliente\n    const clienteInfo = clientes.get(ws);\n    clienteInfo.nombre = datos.nombre;\n\n    // Procesar el mensaje...\n  });\n\n  ws.on('close', () =&gt; {\n    const clienteInfo = clientes.get(ws);\n    console.log(`Cliente ${clienteInfo.id} desconectado`);\n    clientes.delete(ws);\n  });\n});",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Servidor WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "ch/part_servercoms/ws/ws_server.html#integración-con-express",
    "href": "ch/part_servercoms/ws/ws_server.html#integración-con-express",
    "title": "15  Servidor WebSockets con JavasScript",
    "section": "15.4 Integración con Express",
    "text": "15.4 Integración con Express\nPodemos combinar rutas REST de Express con WebSockets en el mismo servidor:\nimport express from 'express';\nimport { WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(express.json());\napp.use(express.static('public'));\n\n// Rutas REST\napp.get('/api/status', (req, res) =&gt; {\n  res.json({\n    clientesConectados: wss.clients.size,\n    estado: 'activo'\n  });\n});\n\n// Servidor WebSocket\nconst wss = new WebSocketServer({ server });\n\nwss.on('connection', (ws) =&gt; {\n  // ... manejar conexiones WebSocket\n});\n\nserver.listen(8080, () =&gt; {\n  console.log('Servidor ejecutándose en http://localhost:8080');\n});\nEsta arquitectura híbrida es muy útil porque HTTP/REST es ideal para operaciones puntuales como autenticación, consultas y subida de archivos, mientras que WebSocket es perfecto para comunicación en tiempo real como notificaciones, actualizaciones en vivo y chat. Ambos protocolos comparten el mismo servidor HTTP y puerto, simplificando el despliegue y la configuración del cliente.",
    "crumbs": [
      "Desarrollo en el servidor y comunicación",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Servidor WebSockets con JavasScript</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Aldridge, David. 2011. “I Shot You First: Networking the Gameplay\nof Halo: Reach.” In Game Developers Conference.\n\n\nAnalytics, IoT. 2020. “Internet of Things (IoT) and Non-IoT Active\nDevice Connections Worldwide from 2010 to 2025 (in Billions).”\nStatista. https://www.statista.com/statistics/1101442/iot-number-of-connected-devices-worldwide/.\n\n\nBBC Brasil. 2019. “[Image from: Article Title].” https://www.bbc.com/portuguese/geral-50162526.\n\n\nBernier, Yahn W. 2001. “Latency Compensating Methods in\nClient/Server in-Game Protocol Design and Optimization.” In\nGame Developers Conference.\n\n\nClaypool, Mark, and Kajal Claypool. 2006. “Latency and Player\nActions in Online Games.” Commun. ACM 49 (11): 40–45. https://doi.org/10.1145/1167838.1167860.\n\n\nDoglio, Fernando. 2015. Pro REST API Development with Node.js.\nBerkeley, CA: Apress.\n\n\nFette, Ian, and Alexey Melnikov. 2011. “The WebSocket\nProtocol.” RFC 6455. Internet Engineering Task Force. https://tools.ietf.org/html/rfc6455.\n\n\nFiedler, Glenn. 2024. “Gaffer on Games: Networking for Game\nProgrammers.” https://gafferongames.com/.\n\n\nFielding, Roy Thomas. 2000. “Architectural Styles and the Design\nof Network-Based Software Architectures.” PhD thesis, University\nof California, Irvine.\n\n\nFlanagan, David. 2020. JavaScript: The Definitive Guide. 7th\ned. Sebastopol, CA: O’Reilly Media.\n\n\nGambetta, Gabriel. 2014. “Fast-Paced Multiplayer.” https://www.gabrielgambetta.com/client-server-game-architecture.html.\n\n\nGlazer, Joshua, and Sanjay Madhav. 2015. Multiplayer Game\nProgramming: Architecting Networked Games. Boston, MA:\nAddison-Wesley Professional.\n\n\nHahn, Evan. 2014. Express in Action: Writing, Building, and Testing\nNode.js Applications. Shelter Island, NY: Manning Publications.\n\n\nHaverbeke, Marijn. 2018. Eloquent JavaScript: A Modern Introduction\nto Programming. 3rd ed. San Francisco, CA: No Starch Press.\n\n\nKurose, James F., and Keith W. Ross. 2017. Computer Networks: A\nTop-down Approach. 7th ed. Boston, MA: Pearson.\n\n\n———. 2021. Computer Networks: A Top-down Approach. 8th ed.\nBoston, MA: Pearson.\n\n\nMasse, Mark. 2011. REST API Design Rulebook. Sebastopol, CA:\nO’Reilly Media.\n\n\nMozilla Developer Network. 2024. “JavaScript Guide.” https://developer.mozilla.org/.\n\n\nPhotonstorm. 2024. “Phaser 3 Documentation.” https://phaser.io/.\n\n\nRichardson, Leonard, and Sam Ruby. 2013. RESTful Web APIs.\nSebastopol, CA: O’Reilly Media.\n\n\nRitchie, Hannah, Edouard Mathieu, Max Roser, and Esteban Ortiz-Ospina.\n2023. “Internet.” Our World in Data. https://ourworldindata.org/internet.\n\n\nSturgeon, Phil. 2016. Build APIs You Won’t Hate. LeanPub.\n\n\nTanenbaum, Andrew S., and David J. Wetherall. 2021. Computer\nNetworks. 6th ed. Harlow, England: Pearson.\n\n\nWang, Vanessa, Frank Salim, and Peter Moskovits. 2013. The\nDefinitive Guide to HTML5 WebSocket. Berkeley, CA: Apress.\n\n\nWilson, Jim. 2018. Node.js 8 the Right Way: Practical, Server-Side\nJavaScript That Scales. Raleigh, NC: Pragmatic Bookshelf.\n\n\nYoung, Alex, Bradley Meck, and Mike Cantelon. 2017. Node.js in\nAction. 2nd ed. Shelter Island, NY: Manning Publications.",
    "crumbs": [
      "Referencias"
    ]
  },
  {
    "objectID": "ch/slides/slides.html",
    "href": "ch/slides/slides.html",
    "title": "16  Diapositivas de la asignatura",
    "section": "",
    "text": "16.1 Introducción a la asignatura",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-network-intro",
    "href": "ch/slides/slides.html#sec-slides-network-intro",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.2 Introducción a las Redes de Ordenadores",
    "text": "16.2 Introducción a las Redes de Ordenadores",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-access-layer",
    "href": "ch/slides/slides.html#sec-slides-access-layer",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.3 Capa de Acceso",
    "text": "16.3 Capa de Acceso",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-network-layer",
    "href": "ch/slides/slides.html#sec-slides-network-layer",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.4 Capa de Red",
    "text": "16.4 Capa de Red",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-transport-layer",
    "href": "ch/slides/slides.html#sec-slides-transport-layer",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.5 Capa de Transporte",
    "text": "16.5 Capa de Transporte",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-application-layer",
    "href": "ch/slides/slides.html#sec-slides-application-layer",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.6 Capa de Aplicación",
    "text": "16.6 Capa de Aplicación",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-javascript",
    "href": "ch/slides/slides.html#sec-slides-javascript",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.7 JavaScript",
    "text": "16.7 JavaScript",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-javascript-oop",
    "href": "ch/slides/slides.html#sec-slides-javascript-oop",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.8 JavaScript OOP",
    "text": "16.8 JavaScript OOP",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-phaser",
    "href": "ch/slides/slides.html#sec-slides-phaser",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.9 Phaser",
    "text": "16.9 Phaser",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-rest",
    "href": "ch/slides/slides.html#sec-slides-rest",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.10 APIs REST",
    "text": "16.10 APIs REST",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/slides/slides.html#sec-slides-websockets",
    "href": "ch/slides/slides.html#sec-slides-websockets",
    "title": "16  Diapositivas de la asignatura",
    "section": "16.11 WebSockets",
    "text": "16.11 WebSockets",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Diapositivas de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html",
    "href": "ch/exercises/_exercises.html",
    "title": "17  Ejercicios de la asignatura",
    "section": "",
    "text": "17.1 Introducción a Redes",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-network-intro",
    "href": "ch/exercises/_exercises.html#sec-ex-network-intro",
    "title": "17  Ejercicios de la asignatura",
    "section": "",
    "text": "Investigación del Modelo TCP/IP\nInvestiga y compara el modelo de capas TCP/IP con tu propia experiencia navegando por Internet.\nTareas:\n\nTraza la ruta de una petición web:\n\nEjecuta el comando traceroute www.google.com (Linux/Mac) o tracert www.google.com (Windows)\nDocumenta cuántos saltos (hops) hay hasta llegar al destino\nIdentifica si alguno de los routers intermedios pertenece a tu ISP\n\nAnálisis por capas: Para acceder a una página web (ej: https://www.google.com), describe qué ocurre en cada capa del modelo TCP/IP:\n\nCapa de Aplicación: ¿Qué protocolo se utiliza?\nCapa de Transporte: ¿TCP o UDP? ¿Por qué?\nCapa de Red: ¿Qué información contienen los paquetes IP?\nCapa de Acceso a la Red: ¿Qué tecnología física usas (WiFi, Ethernet, 4G)?\n\nEncapsulación:\n\nDibuja un diagrama mostrando cómo se encapsulan los datos en cada capa\nIndica qué información añade cada capa (cabeceras)\n\nReflexión:\n\n¿Por qué crees que el modelo está organizado en capas?\n¿Qué ventajas tiene esta separación?\nDa un ejemplo de cómo puedes cambiar una capa sin afectar a las demás",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-access-layer",
    "href": "ch/exercises/_exercises.html#sec-ex-access-layer",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.2 Capa de Acceso",
    "text": "17.2 Capa de Acceso\n\nAnálisis de Direcciones MAC y ARP\nInvestiga las direcciones MAC en tu red local y el protocolo ARP.\nTareas:\n\nDescubre tu dirección MAC:\n\nEn Linux/Mac: ip link show o ifconfig\nEn Windows: ipconfig /all\nAnota la dirección MAC de tu interfaz de red principal\n\nAnaliza la tabla ARP:\n\nEn Linux/Mac: arp -a o ip neigh show\nEn Windows: arp -a\nDocumenta:\n\n¿Cuántas entradas tiene tu tabla ARP?\n¿Reconoces alguna de las IPs? (router, otros dispositivos)\n¿Hay entradas incompletas o que fallan?\n\n\nExperimento con ARP:\n\nHaz ping a tu router/gateway: ping 192.168.1.1\nVuelve a consultar la tabla ARP\n¿Qué ha cambiado?\n\nInvestigación:\n\n¿Qué pasaría si dos dispositivos en la misma red tuvieran la misma dirección MAC?\n¿Por qué las direcciones MAC no se usan para enrutamiento en Internet?\n¿Cuál es la diferencia entre una dirección MAC y una dirección IP en términos de alcance?\n\nAnaliza la estructura de la dirección MAC:\n\nTu MAC tiene formato: XX:XX:XX:YY:YY:YY\nLos primeros 3 bytes (XX:XX:XX) son el OUI (Organizationally Unique Identifier)\nBusca el fabricante de tu tarjeta de red en: https://maclookup.app/",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-network-layer",
    "href": "ch/exercises/_exercises.html#sec-ex-network-layer",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.3 Capa de Red",
    "text": "17.3 Capa de Red\n\nAnálisis de Direccionamiento IP y Subredes\nDada la siguiente salida del comando ip addr en un sistema Linux, analiza la configuración de red y responde las preguntas:\n$ ip addr show\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP\n    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5054:ff:fe12:3456/64 scope link\n       valid_lft forever preferred_lft forever\n\n3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP\n    link/ether a4:5e:60:ab:cd:ef brd ff:ff:ff:ff:ff:ff\n    inet 10.0.5.42/22 brd 10.0.7.255 scope global wlan0\n       valid_lft forever preferred_lft forever\nPreguntas:\n\nDirecciones de red: Para cada interfaz con IPv4, calcula:\n\nLa dirección de red\nLa dirección de broadcast\nEl rango de IPs válidas para hosts\nEl número total de hosts disponibles\n\nClasificación:\n\n¿Qué interfaces tienen direcciones IP privadas? ¿Por qué?\n¿La dirección de loopback es pública o privada? ¿Para qué se utiliza?\n\nMáscara de subred:\n\nConvierte las máscaras CIDR (/8, /24, /22) a formato decimal (ej: 255.255.255.0)\n¿Cuál es la diferencia entre /24 y /22 en términos de número de hosts?\n\nEscenario práctico:\n\nSi quieres enviar un paquete desde esta máquina (192.168.1.100) a un servidor web en Internet (8.8.8.8), ¿qué interfaz se utilizaría?\n¿Necesitarías NAT? ¿Por qué?\n\nMTU:\n\n¿Qué significa MTU 1500?\nSi envías un datagrama IP de 2000 bytes por eth0, ¿qué ocurrirá?",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-transport-layer",
    "href": "ch/exercises/_exercises.html#sec-ex-transport-layer",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.4 Capa de Transporte",
    "text": "17.4 Capa de Transporte\n\nAnálisis de Conexiones TCP y UDP\nInvestiga las conexiones activas en tu sistema y analiza el comportamiento de TCP y UDP.\nTareas:\n\nVisualiza conexiones activas:\n\nEn Linux/Mac: netstat -tunap o ss -tunap\nEn Windows: netstat -ano\nIdentifica:\n\n¿Cuántas conexiones TCP tienes activas?\n¿Hay conexiones UDP? ¿A qué puertos?\n¿Reconoces algún servicio por su puerto? (80=HTTP, 443=HTTPS, 53=DNS, etc.)\n\n\nAnaliza estados TCP:\n\nBusca conexiones en estado ESTABLISHED, LISTEN, TIME_WAIT\n¿Qué significa cada estado?\n¿Por qué hay puertos en estado LISTEN?\n\nCompara TCP vs UDP: Completa la tabla:\n\n\n\nCaracterística\nTCP\nUDP\n\n\n\n\nOrientado a conexión\n?\n?\n\n\nGarantiza entrega\n?\n?\n\n\nGarantiza orden\n?\n?\n\n\nControl de flujo\n?\n?\n\n\nOverhead\n?\n?\n\n\nVelocidad\n?\n?\n\n\nEjemplo de uso\n?\n?\n\n\n\nInvestiga el handshake de TCP:\n\nDibuja el proceso de establecimiento de conexión (3-way handshake)\n¿Qué flags se utilizan? (SYN, ACK)\n¿Qué ocurre si se pierde uno de los paquetes?\n\nCaso práctico: Para un videojuego multijugador, ¿usarías TCP o UDP para los siguientes casos?\n\nChat de texto entre jugadores\nPosición de los jugadores en tiempo real\nTransferencia de archivos (mapas, texturas)\nSistema de login/autenticación\n\nJustifica cada respuesta.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-application-layer",
    "href": "ch/exercises/_exercises.html#sec-ex-application-layer",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.5 Capa de Aplicación",
    "text": "17.5 Capa de Aplicación\n\nAnálisis de Petición HTTP\nInvestiga cómo funciona el protocolo HTTP usando herramientas de línea de comandos.\nTareas:\n\nRealiza una petición HTTP simple:\ncurl -v http://example.com\n\nAnaliza la salida\nIdentifica las cabeceras de petición (Request headers)\nIdentifica las cabeceras de respuesta (Response headers)\n¿Qué código de estado se recibe?\n\nCompara HTTP vs HTTPS:\ncurl -v http://google.com\ncurl -v https://google.com\n\n¿Qué diferencias observas?\n¿Hay una redirección en la versión HTTP?\n¿Qué información adicional aparece en HTTPS?\n\nInvestiga los métodos HTTP: Para cada método, describe:\n\nGET\nPOST\nPUT\nDELETE\n¿Cuándo usarías cada uno en un videojuego?\n\nAnaliza códigos de estado HTTP: Agrupa estos códigos por categoría (1xx, 2xx, 3xx, 4xx, 5xx):\n\n200, 201, 301, 302, 400, 401, 403, 404, 500, 502, 503\n¿Qué significa cada categoría?\nDa un ejemplo de cuándo podrías recibir cada código en un juego\n\nInvestiga DNS:\nnslookup google.com\n\n¿Qué IP(s) se resuelven?\n¿Por qué hay múltiples IPs?\n¿Qué pasaría si el DNS no funcionara?",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-javascript",
    "href": "ch/exercises/_exercises.html#sec-ex-javascript",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.6 JavaScript",
    "text": "17.6 JavaScript\n\nSistema de Inventario de Videojuego\nCrea un sistema de inventario para un videojuego utilizando JavaScript moderno (ES2015+). El sistema debe:\n\nCrear una clase Inventario que pueda almacenar items con las siguientes propiedades:\n\nnombre (string)\ncantidad (number)\ntipo (string): “arma”, “consumible”, o “quest”\n\nLa clase Inventario debe tener los siguientes métodos:\n\nagregarItem(nombre, cantidad, tipo): Añade un item al inventario. Si el item ya existe, incrementa su cantidad.\nusarItem(nombre, cantidad): Reduce la cantidad del item especificado. Si llega a 0, elimina el item.\nobtenerItemsPorTipo(tipo): Retorna un array con todos los items de un tipo específico.\nget totalItems(): Getter que retorna el número total de items diferentes en el inventario.\n\nImplementa validaciones:\n\nLa cantidad nunca puede ser negativa\nEl tipo debe ser uno de los válidos (“arma”, “consumible”, “quest”)\nNo se puede usar más cantidad de la disponible\n\nGuarda el inventario en localStorage cada vez que se modifique y permite cargarlo cuando se crea una nueva instancia.\n\nRequisitos técnicos:\n\nUtiliza la sintaxis de clases ES2015+\nUsa getters/setters cuando sea apropiado\nEmplea métodos de arrays modernos (map, filter, etc.)\nImplementa manejo de errores con try-catch\nUsa template literals para mensajes\n\nEjemplo de uso:\nconst inventario = new Inventario();\ninventario.agregarItem(\"Espada de Fuego\", 1, \"arma\");\ninventario.agregarItem(\"Poción de Salud\", 5, \"consumible\");\ninventario.agregarItem(\"Llave Antigua\", 1, \"quest\");\n\nconsole.log(`Total de items: ${inventario.totalItems}`); // 3\n\ninventario.usarItem(\"Poción de Salud\", 2);\nconst consumibles = inventario.obtenerItemsPorTipo(\"consumible\");\nconsole.log(consumibles); // [{ nombre: \"Poción de Salud\", cantidad: 3, tipo: \"consumible\" }]",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-phaser",
    "href": "ch/exercises/_exercises.html#sec-ex-phaser",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.7 Phaser",
    "text": "17.7 Phaser\n\nSistema de Puntuación Persistente\nCrea un sistema de puntuación para un juego Phaser que:\n\nMuestre la puntuación actual en pantalla durante el juego\nGuarde la puntuación más alta (high score) en localStorage\nMuestre el high score en la pantalla principal\nPermita resetear el high score\n\nRequisitos:\n\nCrea una escena de Phaser con:\n\nUn texto que muestre “Score: X”\nUn texto que muestre “High Score: Y”\nUn botón o tecla para incrementar la puntuación (simular evento del juego)\nUn botón para resetear el high score\n\nImplementa la lógica para:\n\nIncrementar la puntuación cuando ocurra un evento (ej: presionar SPACE)\nComparar la puntuación actual con el high score\nActualizar el high score si se supera\nPersistir el high score en localStorage\nCargar el high score guardado al iniciar\n\n\nPista: Utiliza localStorage.setItem() y localStorage.getItem() para la persistencia.\nEstructura sugerida:\nclass GameScene extends Phaser.Scene {\n    constructor() {\n        super('GameScene');\n        this.score = 0;\n        this.highScore = 0;\n    }\n\n    create() {\n        // Cargar high score\n        // Crear textos\n        // Configurar controles\n    }\n\n    update() {\n        // Actualizar puntuación\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-rest-intro",
    "href": "ch/exercises/_exercises.html#sec-ex-rest-intro",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.8 REST - Introducción",
    "text": "17.8 REST - Introducción\n\nDiseño de API REST para Videojuego\nDiseña una API RESTful para un sistema de gestión de jugadores y partidas de un videojuego.\nRequisitos:\n\nDefine los recursos principales:\n\nJugadores (players)\nPartidas (games)\nPuntuaciones (scores)\n\nDiseña los endpoints siguiendo principios REST: Para cada operación, especifica:\n\nMétodo HTTP (GET, POST, PUT, DELETE)\nRuta del endpoint\nCódigo de estado esperado\nEjemplo de request/response\n\nOperaciones requeridas:\n\nListar todos los jugadores\nObtener un jugador específico\nCrear un nuevo jugador\nActualizar información de un jugador\nEliminar un jugador\nObtener todas las partidas de un jugador\nCrear una nueva partida\nObtener el top 10 de puntuaciones\n\nAplica convenciones RESTful:\n\nUsa nombres en plural para recursos\nUsa IDs en la URL para recursos específicos\nUsa query parameters para filtros y paginación\nDiseña URLs jerárquicas para relaciones\n\nDiseña las estructuras de datos: Define el formato JSON para:\n\nUn jugador (Player)\nUna partida (Game)\nUna puntuación (Score)\n\n\nEjemplo de formato:\nGET /api/players/123\nRespuesta: 200 OK\n{\n  \"id\": 123,\n  \"username\": \"player1\",\n  ...\n}",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-rest-client",
    "href": "ch/exercises/_exercises.html#sec-ex-rest-client",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.9 REST - Cliente",
    "text": "17.9 REST - Cliente\n\nCliente REST con Fetch API\nImplementa un cliente JavaScript que consuma la API REST de un videojuego usando Fetch API.\nRequisitos:\n\nCrea funciones para consumir la API: Implementa las siguientes funciones usando fetch():\nasync function getPlayers() { ... }\nasync function getPlayer(id) { ... }\nasync function createPlayer(playerData) { ... }\nasync function updatePlayer(id, updates) { ... }\nasync function deletePlayer(id) { ... }\nasync function getTopScores(limit = 10) { ... }\nManejo de errores:\n\nVerifica el código de estado de la respuesta\nLanza excepciones personalizadas para errores HTTP\nManeja errores de red (ej: servidor no disponible)\n\nImplementa una clase GameAPI: Encapsula todas las funciones en una clase con:\n\nBase URL configurable\nMétodos para cada operación\nManejo centralizado de errores\nHeaders comunes (Content-Type, Authorization si aplica)\n\nCrea una interfaz de usuario simple:\n\nBotón para obtener el top 10 de puntuaciones\nMostrar los resultados en una lista HTML\nIndicador de carga durante la petición\nMensaje de error si falla\n\n\nEstructura sugerida:\nclass GameAPI {\n    constructor(baseURL) {\n        this.baseURL = baseURL;\n    }\n\n    async request(endpoint, options = {}) {\n        // Método helper para hacer peticiones\n    }\n\n    async getPlayers() { ... }\n    async createPlayer(data) { ... }\n    // ... más métodos\n}\nUso esperado:\nconst api = new GameAPI('https://api.mygame.com');\n\n// Obtener jugador\nconst player = await api.getPlayer(123);\nconsole.log(player.username);\n\n// Crear nuevo jugador\nconst newPlayer = await api.createPlayer({\n    username: 'newbie',\n    email: 'newbie@example.com'\n});",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-rest-server",
    "href": "ch/exercises/_exercises.html#sec-ex-rest-server",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.10 REST - Servidor",
    "text": "17.10 REST - Servidor\n\nImplementar un Servidor REST con Express\nCrea un servidor REST básico para gestionar jugadores de un videojuego usando Node.js y Express.\nRequisitos:\n\nConfigura un proyecto Express:\nnpm init -y\nnpm install express\nImplementa los siguientes endpoints:\n\nGET /api/players - Listar todos los jugadores\nGET /api/players/:id - Obtener un jugador por ID\nPOST /api/players - Crear un nuevo jugador\nPUT /api/players/:id - Actualizar un jugador\nDELETE /api/players/:id - Eliminar un jugador\n\nAlmacenamiento en memoria:\n\nUsa un array para almacenar los jugadores temporalmente\nCada jugador debe tener: id, username, level, score\n\nValidaciones:\n\nVerificar que username no esté vacío\nVerificar que level y score sean números\nRetornar error 400 si los datos son inválidos\nRetornar error 404 si el jugador no existe\n\nMiddleware:\n\nUsa express.json() para parsear JSON\nAñade un middleware de logging que imprima cada petición\n\n\nEstructura sugerida:\nconst express = require('express');\nconst app = express();\n\n// Datos en memoria\nlet players = [\n    { id: 1, username: \"player1\", level: 5, score: 1000 },\n    { id: 2, username: \"player2\", level: 3, score: 500 }\n];\nlet nextId = 3;\n\n// Middleware\napp.use(express.json());\n\n// TODO: Implementar endpoints\n\napp.listen(3000, () =&gt; {\n    console.log('Server running on http://localhost:3000');\n});\nBonus:\n\nAñade un endpoint GET /api/players?level=X para filtrar por nivel\nImplementa paginación con limit y offset",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-ws-intro",
    "href": "ch/exercises/_exercises.html#sec-ex-ws-intro",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.11 WebSockets - Introducción",
    "text": "17.11 WebSockets - Introducción\n\nComparación REST vs WebSockets\nAnaliza las diferencias entre REST y WebSockets y determina cuándo usar cada uno.\nTareas:\n\nCompleta la tabla comparativa:\n\n\n\nAspecto\nREST (HTTP)\nWebSockets\n\n\n\n\nProtocolo base\n?\n?\n\n\nConexión\n?\n?\n\n\nComunicación\n? (cliente→servidor)\n?\n\n\nOverhead\n?\n?\n\n\nTiempo real\n?\n?\n\n\nEscalabilidad\n?\n?\n\n\nComplejidad\n?\n?\n\n\n\nCasos de uso - ¿REST o WebSocket? Para cada escenario de videojuego, indica si usarías REST, WebSocket o ambos, y justifica:\n\nChat entre jugadores en tiempo real\nCargar lista de mapas disponibles\nSincronizar posición de jugadores en un shooter multijugador\nSubir una puntuación al leaderboard\nNotificaciones de amigos que se conectan\nDescargar un mapa de 50MB\nPartida de ajedrez online por turnos\nSistema de login/autenticación\n\nInvestigación:\n\n¿Qué es el “handshake” de WebSocket?\n¿Por qué WebSocket usa HTTP inicialmente?\n¿Pueden atravesar WebSockets un firewall/proxy más fácilmente que un socket TCP puro?\n\nDiseño arquitectónico: Para un juego multijugador tipo battle royale:\n\n¿Qué información enviarías por REST?\n¿Qué información enviarías por WebSocket?\nDibuja un diagrama simple de la arquitectura",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-ws-client",
    "href": "ch/exercises/_exercises.html#sec-ex-ws-client",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.12 WebSockets - Cliente",
    "text": "17.12 WebSockets - Cliente\n\nCliente WebSocket para Chat de Juego\nImplementa un cliente WebSocket simple para un sistema de chat en tiempo real de un videojuego.\nRequisitos:\n\nCrea una clase GameChat:\n\nConstructor que reciba la URL del servidor WebSocket\nMétodo connect() para establecer conexión\nMétodo sendMessage(message) para enviar mensajes\nMétodo disconnect() para cerrar la conexión\nCallbacks para eventos: onMessage, onConnect, onDisconnect, onError\n\nManejo de estados de conexión:\n\nMostrar indicador cuando se está conectando\nMostrar indicador cuando está conectado\nMostrar error si falla la conexión\nIntentar reconectar automáticamente si se pierde la conexión\n\nInterfaz de usuario HTML:\n\nInput para el nombre de usuario\nBotón para conectar\nÁrea de mensajes (mostrar historial)\nInput para escribir mensaje\nBotón para enviar mensaje\nIndicador de estado de conexión\n\nFormato de mensajes JSON:\n// Cliente → Servidor (enviar mensaje)\n{\n  type: \"message\",\n  username: \"player1\",\n  text: \"Hola a todos\"\n}\n\n// Servidor → Cliente (mensaje broadcast)\n{\n  type: \"message\",\n  username: \"player2\",\n  text: \"Hola player1!\",\n  timestamp: \"2025-11-06T10:30:00Z\"\n}\n\n// Servidor → Cliente (usuario conectado)\n{\n  type: \"user_joined\",\n  username: \"player3\"\n}\n\nEstructura sugerida:\nclass GameChat {\n    constructor(serverURL) {\n        this.serverURL = serverURL;\n        this.ws = null;\n        this.username = null;\n\n        // Callbacks\n        this.onMessage = null;\n        this.onConnect = null;\n        this.onDisconnect = null;\n        this.onError = null;\n    }\n\n    connect(username) {\n        // TODO: Establecer conexión WebSocket\n    }\n\n    sendMessage(text) {\n        // TODO: Enviar mensaje al servidor\n    }\n\n    disconnect() {\n        // TODO: Cerrar conexión\n    }\n}\nBonus:\n\nMostrar quién está escribiendo (“player2 is typing…”)\nSoporte para comandos especiales (“/help”, “/users”)\nEmoticones o formato básico de texto",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/exercises/_exercises.html#sec-ex-ws-server",
    "href": "ch/exercises/_exercises.html#sec-ex-ws-server",
    "title": "17  Ejercicios de la asignatura",
    "section": "17.13 WebSockets - Servidor",
    "text": "17.13 WebSockets - Servidor\n\nServidor WebSocket para Chat de Juego\nImplementa un servidor WebSocket simple usando Node.js y la librería ws.\nRequisitos:\n\nInstala las dependencias:\nnpm init -y\nnpm install ws\nImplementa el servidor WebSocket:\n\nServidor escuchando en el puerto 8080\nManejar conexiones de múltiples clientes simultáneamente\nBroadcast de mensajes a todos los clientes conectados\nGestionar usuarios (username por cliente)\n\nTipos de mensajes:\n\nregister: Cliente envía su username al conectar\nmessage: Cliente envía mensaje de chat\nuser_joined: Servidor notifica cuando alguien se une\nuser_left: Servidor notifica cuando alguien se va\n\nFuncionalidades:\n\nAlmacenar usuarios conectados con su websocket y username\nBroadcast a todos excepto al emisor\nNotificar a todos cuando un usuario se conecta/desconecta\nManejo de errores y desconexiones\n\n\nEstructura sugerida:\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\n// Almacenar clientes conectados\nconst clients = new Map(); // ws -&gt; {username, ws}\n\nwss.on('connection', (ws) =&gt; {\n    console.log('New client connected');\n\n    ws.on('message', (message) =&gt; {\n        // TODO: Manejar mensajes\n    });\n\n    ws.on('close', () =&gt; {\n        // TODO: Manejar desconexión\n    });\n});\nBonus:\n\nLogging con timestamp de cada evento\nComando “/users” para listar usuarios conectados\nLímite máximo de clientes simultáneos\nHeartbeat/ping para detectar conexiones muertas",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Ejercicios de la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/code/code.html",
    "href": "ch/code/code.html",
    "title": "18  Software utilizado en la asignatura",
    "section": "",
    "text": "18.1 Visualizaciones\nUbicación: jergames.dslabapps.es\nDescripción: Página web con visualizaciones interactivas que incluye:\nIdentificador SWH:\nEnlace permanente: Software Heritage Archive",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Software utilizado en la asignatura</span>"
    ]
  },
  {
    "objectID": "ch/code/code.html#visualizaciones",
    "href": "ch/code/code.html#visualizaciones",
    "title": "18  Software utilizado en la asignatura",
    "section": "",
    "text": "Juego del Router: Simula protocolos de enrutamiento y reenvío de paquetes\nCIDR y Coincidencia de Prefijo Más Largo: Comprende el enmascaramiento de subredes y las decisiones de enrutamiento\nDistribución Estática de Ancho de Banda TCP: Visualiza el reparto de ancho de banda entre conexiones TCP\nDistribución Dinámica de Ancho de Banda TCP: Simulación interactiva de asignación de ancho de banda\n\n\nswh:1:dir:e759621272f530009eb589570687a2d56d0d4bcd;\norigin=https://github.com/rrunix/jer-visualizations;\nvisit=swh:1:snp:486873193776051caea0e315d0a88a076d0ce242;\nanchor=swh:1:rev:3f99cd855ca1298ff61620308ba51d1dd37b7a41",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Software utilizado en la asignatura</span>"
    ]
  }
]